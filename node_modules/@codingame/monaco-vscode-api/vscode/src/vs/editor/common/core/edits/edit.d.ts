import { OffsetRange } from "../ranges/offsetRange.js";
export declare abstract class BaseEdit<T extends BaseReplacement<T> = BaseReplacement<any>, TEdit extends BaseEdit<T, TEdit> = BaseEdit<T, any>> {
    readonly replacements: readonly T[];
    constructor(replacements: readonly T[]);
    protected abstract _createNew(replacements: readonly T[]): TEdit;
    /**
     * Returns true if and only if this edit and the given edit are structurally equal.
     * Note that this does not mean that the edits have the same effect on a given input!
     * See `.normalize()` or `.normalizeOnBase(base)` for that.
    */
    equals(other: TEdit): boolean;
    toString(): string;
    /**
     * Normalizes the edit by removing empty replacements and joining touching replacements (if the replacements allow joining).
     * Two edits have an equal normalized edit if and only if they have the same effect on any input.
     *
     * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_normalize.drawio.png)
     *
     * Invariant:
     * ```
     * (forall base: TEdit.apply(base).equals(other.apply(base))) <-> this.normalize().equals(other.normalize())
     * ```
     * and
     * ```
     * forall base: TEdit.apply(base).equals(this.normalize().apply(base))
     * ```
     *
     */
    normalize(): TEdit;
    /**
     * Combines two edits into one with the same effect.
     *
     * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_compose.drawio.png)
     *
     * Invariant:
     * ```
     * other.apply(this.apply(s0)) = this.compose(other).apply(s0)
     * ```
     */
    compose(other: TEdit): TEdit;
    decomposeSplit(shouldBeInE1: (repl: T) => boolean): {
        e1: TEdit;
        e2: TEdit;
    };
    /**
     * Returns the range of each replacement in the applied value.
    */
    getNewRanges(): OffsetRange[];
    getJoinedReplaceRange(): OffsetRange | undefined;
    isEmpty(): boolean;
    getLengthDelta(): number;
    getNewDataLength(dataLength: number): number;
    applyToOffset(originalOffset: number): number;
    applyToOffsetRange(originalRange: OffsetRange): OffsetRange;
    applyInverseToOffset(postEditsOffset: number): number;
    /**
     * Return undefined if the originalOffset is within an edit
     */
    applyToOffsetOrUndefined(originalOffset: number): number | undefined;
    /**
     * Return undefined if the originalRange is within an edit
     */
    applyToOffsetRangeOrUndefined(originalRange: OffsetRange): OffsetRange | undefined;
}
export declare abstract class BaseReplacement<TSelf extends BaseReplacement<TSelf>> {
    /**
     * The range to be replaced.
    */
    readonly replaceRange: OffsetRange;
    constructor(
    /**
     * The range to be replaced.
    */
    replaceRange: OffsetRange);
    abstract getNewLength(): number;
    /**
     * Precondition: TEdit.range.endExclusive === other.range.start
    */
    abstract tryJoinTouching(other: TSelf): TSelf | undefined;
    abstract slice(newReplaceRange: OffsetRange, rangeInReplacement?: OffsetRange): TSelf;
    delta(offset: number): TSelf;
    getLengthDelta(): number;
    abstract equals(other: TSelf): boolean;
    toString(): string;
    get isEmpty(): boolean;
    getRangeAfterReplace(): OffsetRange;
}
export type AnyEdit = BaseEdit<AnyReplacement, AnyEdit>;
export type AnyReplacement = BaseReplacement<AnyReplacement>;
export declare class Edit<T extends BaseReplacement<T>> extends BaseEdit<T, Edit<T>> {
    /**
     * Represents a set of edits to a string.
     * All these edits are applied at once.
    */
    static readonly empty: Edit<never>;
    static create<T extends BaseReplacement<T>>(replacements: readonly T[]): Edit<T>;
    static single<T extends BaseReplacement<T>>(replacement: T): Edit<T>;
    protected _createNew(replacements: readonly T[]): Edit<T>;
}
export declare class AnnotationReplacement<TAnnotation> extends BaseReplacement<AnnotationReplacement<TAnnotation>> {
    readonly newLength: number;
    readonly annotation: TAnnotation;
    constructor(range: OffsetRange, newLength: number, annotation: TAnnotation);
    equals(other: AnnotationReplacement<TAnnotation>): boolean;
    getNewLength(): number;
    tryJoinTouching(other: AnnotationReplacement<TAnnotation>): AnnotationReplacement<TAnnotation> | undefined;
    slice(range: OffsetRange, rangeInReplacement?: OffsetRange): AnnotationReplacement<TAnnotation>;
}
