
import '../../../../../../../base/browser/dom.js';
import '../../../../../../../base/browser/ui/keybindingLabel/keybindingLabel.js';
import { numberComparator } from '../../../../../../../base/common/arrays.js';
import { findFirstMin } from '../../../../../../../base/common/arraysFind.js';
import '../../../../../../../base/common/lifecycle.js';
import '../../../../../../../base/common/observableInternal/index.js';
import '../../../../../../../base/common/platform.js';
import { splitLines } from '../../../../../../../base/common/strings.js';
import { CharCode } from '../../../../../../../base/common/charCode.js';
import '../../../../../../../base/common/marshallingIds.js';
import '../../../../../../../base/common/path.js';
import '../../../../../../../platform/actions/browser/menuEntryActionViewItem.js';
import { observableCodeEditor } from '../../../../../../browser/observableCodeEditor.js';
import { Rect } from '../../../../../../common/core/2d/rect.js';
import { EditorOption } from '../../../../../../common/config/editorOptions.js';
import { OffsetRange } from '../../../../../../common/core/ranges/offsetRange.js';
import { Position } from '../../../../../../common/core/position.js';
import { Range } from '../../../../../../common/core/range.js';
import { TextReplacement, TextEdit } from '../../../../../../common/core/edits/textEdit.js';
import { RangeMapping } from '../../../../../../common/diff/rangeMapping.js';
import { indentOfLine } from '../../../../../../common/model/textModel.js';
import { BugIndicatingError } from '../../../../../../../base/common/errors.js';
import { Size2D } from '../../../../../../common/core/2d/size.js';
import { derivedObservableWithCache } from '../../../../../../../base/common/observableInternal/utils/utils.js';
import { derived, derivedOpts } from '../../../../../../../base/common/observableInternal/observables/derived.js';
import { DebugLocation } from '../../../../../../../base/common/observableInternal/debugLocation.js';
import { observableValue } from '../../../../../../../base/common/observableInternal/observables/observableValue.js';
import { observableSignalFromEvent } from '../../../../../../../base/common/observableInternal/observables/observableSignalFromEvent.js';

function maxContentWidthInRange(editor, range, reader) {
    editor.layoutInfo.read(reader);
    editor.value.read(reader);
    const model = editor.model.read(reader);
    if (!model) {
        return 0;
    }
    let maxContentWidth = 0;
    editor.scrollTop.read(reader);
    for (let i = range.startLineNumber; i < range.endLineNumberExclusive; i++) {
        const lineContentWidth = editor.editor.getWidthOfLine(i);
        maxContentWidth = Math.max(maxContentWidth, lineContentWidth);
    }
    const lines = range.mapToLineArray(l => model.getLineContent(l));
    if (maxContentWidth < 5 && ( lines.some(l => l.length > 0)) && model.uri.scheme !== 'file') {
        console.error('unexpected width');
    }
    return maxContentWidth;
}
function getContentSizeOfLines(editor, range, reader) {
    editor.layoutInfo.read(reader);
    editor.value.read(reader);
    observableSignalFromEvent(editor, editor.editor.onDidChangeLineHeight).read(reader);
    const model = editor.model.read(reader);
    if (!model) {
        throw ( new BugIndicatingError('Model is required'));
    }
    const sizes = [];
    editor.scrollTop.read(reader);
    for (let i = range.startLineNumber; i < range.endLineNumberExclusive; i++) {
        let lineContentWidth = editor.editor.getWidthOfLine(i);
        if (lineContentWidth === -1) {
            const column = model.getLineMaxColumn(i);
            const typicalHalfwidthCharacterWidth = editor.editor.getOption(EditorOption.fontInfo).typicalHalfwidthCharacterWidth;
            const approximation = column * typicalHalfwidthCharacterWidth;
            lineContentWidth = approximation;
        }
        const height = editor.editor.getLineHeightForPosition(( new Position(i, 1)));
        sizes.push(( new Size2D(lineContentWidth, height)));
    }
    return sizes;
}
function getOffsetForPos(editor, pos, reader) {
    editor.layoutInfo.read(reader);
    editor.value.read(reader);
    const model = editor.model.read(reader);
    if (!model) {
        return 0;
    }
    editor.scrollTop.read(reader);
    const lineContentWidth = editor.editor.getOffsetForColumn(pos.lineNumber, pos.column);
    return lineContentWidth;
}
function getPrefixTrim(diffRanges, originalLinesRange, modifiedLines, editor, reader = undefined) {
    const textModel = editor.getModel();
    if (!textModel) {
        return { prefixTrim: 0, prefixLeftOffset: 0 };
    }
    const replacementStart = ( diffRanges.map(r => r.isSingleLine() ? r.startColumn - 1 : 0));
    const originalIndents = originalLinesRange.mapToLineArray(line => indentOfLine(textModel.getLineContent(line)));
    const modifiedIndents = ( modifiedLines.filter(line => line !== '').map(line => indentOfLine(line)));
    const prefixTrim = Math.min(...replacementStart, ...originalIndents, ...modifiedIndents);
    let prefixLeftOffset;
    const startLineIndent = textModel.getLineIndentColumn(originalLinesRange.startLineNumber);
    if (startLineIndent >= prefixTrim + 1) {
        observableCodeEditor(editor).scrollTop.read(reader);
        prefixLeftOffset = editor.getOffsetForColumn(originalLinesRange.startLineNumber, prefixTrim + 1);
    }
    else if (modifiedLines.length > 0) {
        prefixLeftOffset = getContentRenderWidth(modifiedLines[0].slice(0, prefixTrim), editor, textModel);
    }
    else {
        return { prefixTrim: 0, prefixLeftOffset: 0 };
    }
    return { prefixTrim, prefixLeftOffset };
}
function getContentRenderWidth(content, editor, textModel) {
    const w = editor.getOption(EditorOption.fontInfo).typicalHalfwidthCharacterWidth;
    const tabSize = textModel.getOptions().tabSize * w;
    const numTabs = content.split('\t').length - 1;
    const numNoneTabs = content.length - numTabs;
    return numNoneTabs * w + numTabs * tabSize;
}
function getEditorValidOverlayRect(editor) {
    const contentLeft = editor.layoutInfoContentLeft;
    const width = derived({ name: 'editor.validOverlay.width' }, r => {
        const hasMinimapOnTheRight = editor.layoutInfoMinimap.read(r).minimapLeft !== 0;
        const editorWidth = editor.layoutInfoWidth.read(r) - contentLeft.read(r);
        if (hasMinimapOnTheRight) {
            const minimapAndScrollbarWidth = editor.layoutInfoMinimap.read(r).minimapWidth + editor.layoutInfoVerticalScrollbarWidth.read(r);
            return editorWidth - minimapAndScrollbarWidth;
        }
        return editorWidth;
    });
    const height = derived({ name: 'editor.validOverlay.height' }, r => editor.layoutInfoHeight.read(r) + editor.contentHeight.read(r));
    return derived({ name: 'editor.validOverlay' }, r => Rect.fromLeftTopWidthHeight(contentLeft.read(r), 0, width.read(r), height.read(r)));
}
function applyEditToModifiedRangeMappings(rangeMapping, edit) {
    const updatedMappings = [];
    for (const m of rangeMapping) {
        const updatedRange = edit.mapRange(m.modifiedRange);
        updatedMappings.push(( new RangeMapping(m.originalRange, updatedRange)));
    }
    return updatedMappings;
}
function classNames(...classes) {
    return classes.filter(c => typeof c === 'string').join(' ');
}
function offsetRangeToRange(columnOffsetRange, startPos) {
    return ( new Range(
        startPos.lineNumber,
        startPos.column + columnOffsetRange.start,
        startPos.lineNumber,
        startPos.column + columnOffsetRange.endExclusive
    ));
}
function getIndentationSize(line, tabSize) {
    let currentSize = 0;
    loop: for (let i = 0, len = line.length; i < len; i++) {
        switch (line.charCodeAt(i)) {
            case CharCode.Tab:
                currentSize += tabSize;
                break;
            case CharCode.Space:
                currentSize++;
                break;
            default: break loop;
        }
    }
    return currentSize - (currentSize % tabSize);
}
function indentSizeToIndentLength(line, indentSize, tabSize) {
    let remainingSize = indentSize - (indentSize % tabSize);
    let i = 0;
    for (; i < line.length; i++) {
        if (remainingSize === 0) {
            break;
        }
        switch (line.charCodeAt(i)) {
            case CharCode.Tab:
                remainingSize -= tabSize;
                break;
            case CharCode.Space:
                remainingSize--;
                break;
            default: throw ( new BugIndicatingError('Unexpected character found while calculating indent length'));
        }
    }
    return i;
}
function createReindentEdit(text, range, tabSize) {
    const newLines = splitLines(text);
    const edits = [];
    const minIndentSize = findFirstMin(range.mapToLineArray(l => getIndentationSize(newLines[l - 1], tabSize)), numberComparator);
    range.forEach(lineNumber => {
        const indentLength = indentSizeToIndentLength(newLines[lineNumber - 1], minIndentSize, tabSize);
        edits.push(( new TextReplacement(offsetRangeToRange(( new OffsetRange(0, indentLength)), ( new Position(lineNumber, 1))), '')));
    });
    return ( new TextEdit(edits));
}
class PathBuilder {
    constructor() {
        this._data = '';
    }
    moveTo(point) {
        this._data += `M ${point.x} ${point.y} `;
        return this;
    }
    lineTo(point) {
        this._data += `L ${point.x} ${point.y} `;
        return this;
    }
    curveTo(cp, to) {
        this._data += `Q ${cp.x} ${cp.y} ${to.x} ${to.y} `;
        return this;
    }
    curveTo2(cp1, cp2, to) {
        this._data += `C ${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${to.x} ${to.y} `;
        return this;
    }
    build() {
        return this._data;
    }
}
function mapOutFalsy(obs) {
    const nonUndefinedObs = derivedObservableWithCache(undefined, (reader, lastValue) => obs.read(reader) || lastValue);
    return derivedOpts({
        debugName: () => `${obs.debugName}.mapOutFalsy`
    }, reader => {
        nonUndefinedObs.read(reader);
        const val = obs.read(reader);
        if (!val) {
            return undefined;
        }
        return nonUndefinedObs;
    });
}
function rectToProps(fn, debugLocation = DebugLocation.ofCaller()) {
    return {
        left: derived({ name: 'editor.validOverlay.left' }, reader =>  fn(reader)?.left, debugLocation),
        top: derived({ name: 'editor.validOverlay.top' }, reader =>  fn(reader)?.top, debugLocation),
        width: derived({ name: 'editor.validOverlay.width' }, reader => {
            const val = fn(reader);
            if (!val) {
                return undefined;
            }
            return val.width;
        }, debugLocation),
        height: derived({ name: 'editor.validOverlay.height' }, reader => {
            const val = fn(reader);
            if (!val) {
                return undefined;
            }
            return val.height;
        }, debugLocation),
    };
}
function observeEditorBoundingClientRect(editor, store) {
    const dom = editor.getContainerDomNode();
    const initialDomRect = observableValue('domRect', dom.getBoundingClientRect());
    store.add(editor.onDidLayoutChange(e => {
        initialDomRect.set(dom.getBoundingClientRect(), undefined);
    }));
    return initialDomRect;
}

export { PathBuilder, applyEditToModifiedRangeMappings, classNames, createReindentEdit, getContentRenderWidth, getContentSizeOfLines, getEditorValidOverlayRect, getOffsetForPos, getPrefixTrim, mapOutFalsy, maxContentWidthInRange, observeEditorBoundingClientRect, rectToProps };
