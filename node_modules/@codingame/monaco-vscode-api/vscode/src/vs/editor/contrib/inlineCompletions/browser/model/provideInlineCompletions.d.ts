import { AsyncIterableProducer } from "../../../../../base/common/async.js";
import { CancellationToken } from "../../../../../base/common/cancellation.js";
import { IDisposable } from "../../../../../base/common/lifecycle.js";
import { ICommandService } from "../../../../../platform/commands/common/commands.service.js";
import { ISingleEditOperation } from "../../../../common/core/editOperation.js";
import { Position } from "../../../../common/core/position.js";
import { Range } from "../../../../common/core/range.js";
import { InlineCompletionEndOfLifeReason, InlineCompletion, InlineCompletionContext, InlineCompletions, InlineCompletionsProvider, PartialAcceptInfo, InlineCompletionsDisposeReason, ProviderId, IInlineCompletionHint } from "../../../../common/languages.js";
import { ILanguageConfigurationService } from "../../../../common/languages/languageConfigurationRegistry.service.js";
import { ITextModel } from "../../../../common/model.js";
import { InlineCompletionViewData, InlineCompletionViewKind } from "../view/inlineEdits/inlineEditsViewInterface.js";
import { URI } from "../../../../../base/common/uri.js";
import { InlineSuggestionEditKind } from "./editKind.js";
import { InlineSuggestAlternativeAction } from "./InlineSuggestAlternativeAction.js";
export type InlineCompletionContextWithoutUuid = Omit<InlineCompletionContext, "requestUuid">;
export declare function provideInlineCompletions(providers: InlineCompletionsProvider[], position: Position, model: ITextModel, context: InlineCompletionContextWithoutUuid, requestInfo: InlineSuggestRequestInfo, languageConfigurationService?: ILanguageConfigurationService): IInlineCompletionProviderResult;
/** If the token is eventually cancelled, this will not leak either. */
export declare function runWhenCancelled(token: CancellationToken, callback: () => void): IDisposable;
export interface IInlineCompletionProviderResult {
    get didAllProvidersReturn(): boolean;
    contextWithUuid: InlineCompletionContext;
    cancelAndDispose(reason: InlineCompletionsDisposeReason): void;
    lists: AsyncIterableProducer<InlineSuggestionList>;
}
export type InlineSuggestSku = {
    type: string;
    plan: string;
};
export type InlineSuggestRequestInfo = {
    startTime: number;
    editorType: InlineCompletionEditorType;
    languageId: string;
    reason: string;
    typingInterval: number;
    typingIntervalCharacterCount: number;
    availableProviders: ProviderId[];
    sku: InlineSuggestSku | undefined;
};
export type InlineSuggestProviderRequestInfo = {
    startTime: number;
    endTime: number;
};
export type PartialAcceptance = {
    characters: number;
    count: number;
    ratio: number;
};
export type RenameInfo = {
    createdRename: boolean;
    duration: number;
    timedOut?: boolean;
    droppedOtherEdits?: number;
    droppedRenameEdits?: number;
};
export type InlineSuggestViewData = {
    editorType: InlineCompletionEditorType;
    renderData?: InlineCompletionViewData;
    viewKind?: InlineCompletionViewKind;
};
export type IInlineSuggestDataAction = IInlineSuggestDataActionEdit | IInlineSuggestDataActionJumpTo;
export interface IInlineSuggestDataActionEdit {
    kind: "edit";
    range: Range;
    insertText: string;
    snippetInfo: SnippetInfo | undefined;
    uri: URI | undefined;
    alternativeAction: InlineSuggestAlternativeAction | undefined;
}
export interface IInlineSuggestDataActionJumpTo {
    kind: "jumpTo";
    position: Position;
    uri: URI | undefined;
}
export declare class InlineSuggestData {
    private _action;
    readonly hint: IInlineCompletionHint | undefined;
    readonly additionalTextEdits: readonly ISingleEditOperation[];
    readonly sourceInlineCompletion: InlineCompletion;
    readonly source: InlineSuggestionList;
    readonly context: InlineCompletionContext;
    readonly isInlineEdit: boolean;
    readonly supportsRename: boolean;
    private readonly _requestInfo;
    private readonly _providerRequestInfo;
    private readonly _correlationId;
    private _didShow;
    private _timeUntilShown;
    private _timeUntilActuallyShown;
    private _showStartTime;
    private _shownDuration;
    private _showUncollapsedStartTime;
    private _showUncollapsedDuration;
    private _notShownReason;
    private _viewData;
    private _didReportEndOfLife;
    private _lastSetEndOfLifeReason;
    private _isPreceeded;
    private _partiallyAcceptedCount;
    private _partiallyAcceptedSinceOriginal;
    private _renameInfo;
    private _editKind;
    get action(): IInlineSuggestDataAction | undefined;
    constructor(_action: IInlineSuggestDataAction | undefined, hint: IInlineCompletionHint | undefined, additionalTextEdits: readonly ISingleEditOperation[], sourceInlineCompletion: InlineCompletion, source: InlineSuggestionList, context: InlineCompletionContext, isInlineEdit: boolean, supportsRename: boolean, _requestInfo: InlineSuggestRequestInfo, _providerRequestInfo: InlineSuggestProviderRequestInfo, _correlationId: string | undefined);
    get showInlineEditMenu(): boolean;
    get partialAccepts(): PartialAcceptance;
    reportInlineEditShown(commandService: ICommandService, updatedInsertText: string, viewKind: InlineCompletionViewKind, viewData: InlineCompletionViewData, editKind: InlineSuggestionEditKind | undefined, timeWhenShown: number): Promise<void>;
    reportPartialAccept(acceptedCharacters: number, info: PartialAcceptInfo, partialAcceptance: PartialAcceptance): void;
    /**
     * Sends the end of life event to the provider.
     * If no reason is provided, the last set reason is used.
     * If no reason was set, the default reason is used.
    */
    reportEndOfLife(reason?: InlineCompletionEndOfLifeReason): void;
    setIsPreceeded(partialAccepts: PartialAcceptance): void;
    setNotShownReason(reason: string): void;
    /**
     * Sets the end of life reason, but does not send the event to the provider yet.
    */
    setEndOfLifeReason(reason: InlineCompletionEndOfLifeReason): void;
    private updateShownDuration;
    private reportInlineEditHidden;
    setRenameProcessingInfo(info: RenameInfo): void;
    withAction(action: IInlineSuggestDataAction): InlineSuggestData;
    private performance;
    addPerformanceMarker(marker: string): void;
}
export interface SnippetInfo {
    snippet: string;
    range: Range;
}
export declare enum InlineCompletionEditorType {
    TextEditor = "textEditor",
    DiffEditor = "diffEditor",
    Notebook = "notebook"
}
/**
 * A ref counted pointer to the computed `InlineCompletions` and the `InlineCompletionsProvider` that
 * computed them.
 */
export declare class InlineSuggestionList {
    readonly inlineSuggestions: InlineCompletions;
    readonly inlineSuggestionsData: readonly InlineSuggestData[];
    readonly provider: InlineCompletionsProvider;
    private refCount;
    constructor(inlineSuggestions: InlineCompletions, inlineSuggestionsData: readonly InlineSuggestData[], provider: InlineCompletionsProvider);
    addRef(): void;
    removeRef(reason?: InlineCompletionsDisposeReason): void;
}
