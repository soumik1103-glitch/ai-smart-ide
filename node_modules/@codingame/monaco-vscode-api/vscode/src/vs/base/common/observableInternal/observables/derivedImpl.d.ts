import { IObservable, IObservableWithChange, IObserver, IReaderWithStore, ISettableObservable, ITransaction } from "../base.js";
import { BaseObservable } from "./baseObservable.js";
import { DebugNameData } from "../debugName.js";
import { DisposableStore, EqualityComparer } from "../commonFacade/deps.js";
import { IChangeTracker } from "../changeTracker.js";
import { DebugLocation } from "../debugLocation.js";
export interface IDerivedReader<TChange = void> extends IReaderWithStore {
    /**
     * Call this to report a change delta or to force report a change, even if the new value is the same as the old value.
    */
    reportChange(change: TChange): void;
}
export declare enum DerivedState {
    /** Initial state, no previous value, recomputation needed */
    initial = 0,
    /**
     * A dependency could have changed.
     * We need to explicitly ask them if at least one dependency changed.
     */
    dependenciesMightHaveChanged = 1,
    /**
     * A dependency changed and we need to recompute.
     * After recomputation, we need to check the previous value to see if we changed as well.
     */
    stale = 2,
    /**
     * No change reported, our cached value is up to date.
     */
    upToDate = 3
}
export declare class Derived<T, TChangeSummary = any, TChange = void> extends BaseObservable<T, TChange> implements IDerivedReader<TChange>, IObserver {
    readonly _debugNameData: DebugNameData;
    readonly _computeFn: (reader: IDerivedReader<TChange>, changeSummary: TChangeSummary) => T;
    private readonly _changeTracker;
    private readonly _handleLastObserverRemoved;
    private readonly _equalityComparator;
    private _state;
    private _value;
    private _updateCount;
    private _dependencies;
    private _dependenciesToBeRemoved;
    private _changeSummary;
    private _isUpdating;
    private _isComputing;
    private _didReportChange;
    private _isInBeforeUpdate;
    private _isReaderValid;
    private _store;
    private _delayedStore;
    private _removedObserverToCallEndUpdateOn;
    get debugName(): string;
    constructor(_debugNameData: DebugNameData, _computeFn: (reader: IDerivedReader<TChange>, changeSummary: TChangeSummary) => T, _changeTracker: IChangeTracker<TChangeSummary> | undefined, _handleLastObserverRemoved: (() => void) | undefined, _equalityComparator: EqualityComparer<T>, debugLocation: DebugLocation);
    protected onLastObserverRemoved(): void;
    get(): T;
    private _recompute;
    toString(): string;
    beginUpdate<T>(_observable: IObservable<T>): void;
    endUpdate<T>(_observable: IObservable<T>): void;
    handlePossibleChange<T>(observable: IObservable<T>): void;
    handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void;
    private _ensureReaderValid;
    readObservable<T>(observable: IObservable<T>): T;
    reportChange(change: TChange): void;
    get store(): DisposableStore;
    get delayedStore(): DisposableStore;
    addObserver(observer: IObserver): void;
    removeObserver(observer: IObserver): void;
    debugGetState(): {
        state: DerivedState;
        stateStr: string;
        updateCount: number;
        isComputing: boolean;
        dependencies: Set<IObservable<any>>;
        value: T | undefined;
    };
    debugSetValue(newValue: unknown): void;
    debugRecompute(): void;
    setValue(newValue: T, tx: ITransaction, change: TChange): void;
}
export declare class DerivedWithSetter<T, TChangeSummary = any, TOutChanges = any> extends Derived<T, TChangeSummary, TOutChanges> implements ISettableObservable<T, TOutChanges> {
    readonly set: (value: T, tx: ITransaction | undefined, change: TOutChanges) => void;
    constructor(debugNameData: DebugNameData, computeFn: (reader: IDerivedReader<TOutChanges>, changeSummary: TChangeSummary) => T, changeTracker: IChangeTracker<TChangeSummary> | undefined, handleLastObserverRemoved: (() => void) | undefined, equalityComparator: EqualityComparer<T>, set: (value: T, tx: ITransaction | undefined, change: TOutChanges) => void, debugLocation: DebugLocation);
}
