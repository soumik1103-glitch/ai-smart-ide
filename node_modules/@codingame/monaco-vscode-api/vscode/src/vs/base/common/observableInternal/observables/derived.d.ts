import { IObservable, IReader, ITransaction, ISettableObservable, IObservableWithChange } from "../base.js";
import { IChangeTracker } from "../changeTracker.js";
import { DisposableStore, EqualityComparer, IDisposable } from "../commonFacade/deps.js";
import { DebugLocation } from "../debugLocation.js";
import { DebugOwner, IDebugNameData } from "../debugName.js";
import { IDerivedReader } from "./derivedImpl.js";
/**
 * Creates an observable that is derived from other observables.
 * The value is only recomputed when absolutely needed.
 *
 * {@link computeFn} should start with a JS Doc using `@description` to name the derived.
 */
export declare function derived<T, TChange = void>(computeFn: (reader: IDerivedReader<TChange>, debugLocation?: DebugLocation) => T): IObservableWithChange<T, TChange>;
export declare function derived<T, TChange = void>(owner: DebugOwner, computeFn: (reader: IDerivedReader<TChange>) => T, debugLocation?: DebugLocation): IObservableWithChange<T, TChange>;
export declare function derivedWithSetter<T>(owner: DebugOwner | undefined, computeFn: (reader: IReader) => T, setter: (value: T, transaction: ITransaction | undefined) => void, debugLocation?: DebugLocation): ISettableObservable<T>;
export declare function derivedOpts<T>(options: IDebugNameData & {
    equalsFn?: EqualityComparer<T>;
    onLastObserverRemoved?: (() => void);
}, computeFn: (reader: IReader) => T, debugLocation?: DebugLocation): IObservable<T>;
/**
 * Represents an observable that is derived from other observables.
 * The value is only recomputed when absolutely needed.
 *
 * {@link computeFn} should start with a JS Doc using `@description` to name the derived.
 *
 * Use `createEmptyChangeSummary` to create a "change summary" that can collect the changes.
 * Use `handleChange` to add a reported change to the change summary.
 * The compute function is given the last change summary.
 * The change summary is discarded after the compute function was called.
 *
 * @see derived
 */
export declare function derivedHandleChanges<T, TDelta, TChangeSummary>(options: IDebugNameData & {
    changeTracker: IChangeTracker<TChangeSummary>;
    equalityComparer?: EqualityComparer<T>;
}, computeFn: (reader: IDerivedReader<TDelta>, changeSummary: TChangeSummary) => T, debugLocation?: DebugLocation): IObservableWithChange<T, TDelta>;
/**
 * @deprecated Use `derived(reader => { reader.store.add(...) })` instead!
*/
export declare function derivedWithStore<T>(computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;
/**
 * @deprecated Use `derived(reader => { reader.store.add(...) })` instead!
*/
export declare function derivedWithStore<T>(owner: DebugOwner, computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;
export declare function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;
export declare function derivedDisposable<T extends IDisposable | undefined>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;
