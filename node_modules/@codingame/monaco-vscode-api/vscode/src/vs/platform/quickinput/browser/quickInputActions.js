
import { KeyMod as KeyMod$1, KeyCode } from '../../../base/common/keyCodes.js';
import { isMacintosh } from '../../../base/common/platform.js';
import { localize } from '../../../nls.js';
import { ContextKeyExpr } from '../../contextkey/common/contextkey.js';
import { InputFocusedContext } from '../../contextkey/common/contextkeys.js';
import { KeybindingsRegistry, KeybindingWeight } from '../../keybinding/common/keybindingsRegistry.js';
import { inQuickInputContext, quickInputTypeContextKeyValue, endOfQuickInputBoxContext } from './quickInput.js';
import { QuickInputType, QuickPickFocus } from '../common/quickInput.js';
import { IQuickInputService } from '../common/quickInput.service.js';

function registerQuickInputCommandAndKeybindingRule(rule, options = {}) {
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        weight: KeybindingWeight.WorkbenchContrib,
        when: inQuickInputContext,
        metadata: { description: ( localize(
            2025,
            "Used while in the context of any kind of quick input. If you change one keybinding for this command, you should change all of the other keybindings (modifier variants) of this command as well."
        )) },
        ...rule,
        secondary: getSecondary(rule.primary, rule.secondary ?? [], options)
    });
}
function registerQuickPickCommandAndKeybindingRule(rule, options = {}) {
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        weight: KeybindingWeight.WorkbenchContrib,
        when: ( ContextKeyExpr.and(( ContextKeyExpr.or((
        ContextKeyExpr.equals(quickInputTypeContextKeyValue, QuickInputType.QuickPick)), ( ContextKeyExpr.equals(quickInputTypeContextKeyValue, QuickInputType.QuickTree)))), inQuickInputContext)),
        metadata: { description: ( localize(
            2026,
            "Used while in the context of the quick pick. If you change one keybinding for this command, you should change all of the other keybindings (modifier variants) of this command as well."
        )) },
        ...rule,
        secondary: getSecondary(rule.primary, rule.secondary ?? [], options)
    });
}
const ctrlKeyMod = isMacintosh ? KeyMod$1.WinCtrl : KeyMod$1.CtrlCmd;
function getSecondary(primary, secondary, options = {}) {
    if (options.withAltMod) {
        secondary.push(KeyMod$1.Alt + primary);
    }
    if (options.withCtrlMod) {
        secondary.push(ctrlKeyMod + primary);
        if (options.withAltMod) {
            secondary.push(KeyMod$1.Alt + ctrlKeyMod + primary);
        }
    }
    if (options.withCmdMod && isMacintosh) {
        secondary.push(KeyMod$1.CtrlCmd + primary);
        if (options.withCtrlMod) {
            secondary.push(KeyMod$1.CtrlCmd + KeyMod$1.WinCtrl + primary);
        }
        if (options.withAltMod) {
            secondary.push(KeyMod$1.CtrlCmd + KeyMod$1.Alt + primary);
            if (options.withCtrlMod) {
                secondary.push(KeyMod$1.CtrlCmd + KeyMod$1.Alt + KeyMod$1.WinCtrl + primary);
            }
        }
    }
    return secondary;
}
function focusHandler(focus, focusOnQuickNatigate) {
    return accessor => {
        const currentQuickPick = accessor.get(IQuickInputService).currentQuickInput;
        if (!currentQuickPick) {
            return;
        }
        if (focusOnQuickNatigate && currentQuickPick.quickNavigate) {
            return currentQuickPick.focus(focusOnQuickNatigate);
        }
        return currentQuickPick.focus(focus);
    };
}
registerQuickPickCommandAndKeybindingRule({ id: 'quickInput.pageNext', primary: KeyCode.PageDown, handler: focusHandler(QuickPickFocus.NextPage) }, { withAltMod: true, withCtrlMod: true, withCmdMod: true });
registerQuickPickCommandAndKeybindingRule({ id: 'quickInput.pagePrevious', primary: KeyCode.PageUp, handler: focusHandler(QuickPickFocus.PreviousPage) }, { withAltMod: true, withCtrlMod: true, withCmdMod: true });
registerQuickPickCommandAndKeybindingRule({ id: 'quickInput.first', primary: ctrlKeyMod + KeyCode.Home, handler: focusHandler(QuickPickFocus.First) }, { withAltMod: true, withCmdMod: true });
registerQuickPickCommandAndKeybindingRule({ id: 'quickInput.last', primary: ctrlKeyMod + KeyCode.End, handler: focusHandler(QuickPickFocus.Last) }, { withAltMod: true, withCmdMod: true });
registerQuickPickCommandAndKeybindingRule({ id: 'quickInput.next', primary: KeyCode.DownArrow, handler: focusHandler(QuickPickFocus.Next) }, { withCtrlMod: true });
registerQuickPickCommandAndKeybindingRule({ id: 'quickInput.previous', primary: KeyCode.UpArrow, handler: focusHandler(QuickPickFocus.Previous) }, { withCtrlMod: true });
const nextSeparatorFallbackDesc = ( localize(
    2027,
    "If we're in quick access mode, this will navigate to the next item. If we are not in quick access mode, this will navigate to the next separator."
));
const prevSeparatorFallbackDesc = ( localize(
    2028,
    "If we're in quick access mode, this will navigate to the previous item. If we are not in quick access mode, this will navigate to the previous separator."
));
if (isMacintosh) {
    registerQuickPickCommandAndKeybindingRule({
        id: 'quickInput.nextSeparatorWithQuickAccessFallback',
        primary: KeyMod$1.CtrlCmd + KeyCode.DownArrow,
        handler: focusHandler(QuickPickFocus.NextSeparator, QuickPickFocus.Next),
        metadata: { description: nextSeparatorFallbackDesc }
    });
    registerQuickPickCommandAndKeybindingRule({
        id: 'quickInput.nextSeparator',
        primary: KeyMod$1.CtrlCmd + KeyMod$1.Alt + KeyCode.DownArrow,
        secondary: [KeyMod$1.CtrlCmd + KeyMod$1.WinCtrl + KeyCode.DownArrow],
        handler: focusHandler(QuickPickFocus.NextSeparator)
    }, { withCtrlMod: true });
    registerQuickPickCommandAndKeybindingRule({
        id: 'quickInput.previousSeparatorWithQuickAccessFallback',
        primary: KeyMod$1.CtrlCmd + KeyCode.UpArrow,
        handler: focusHandler(QuickPickFocus.PreviousSeparator, QuickPickFocus.Previous),
        metadata: { description: prevSeparatorFallbackDesc }
    });
    registerQuickPickCommandAndKeybindingRule({
        id: 'quickInput.previousSeparator',
        primary: KeyMod$1.CtrlCmd + KeyMod$1.Alt + KeyCode.UpArrow,
        secondary: [KeyMod$1.CtrlCmd + KeyMod$1.WinCtrl + KeyCode.UpArrow],
        handler: focusHandler(QuickPickFocus.PreviousSeparator)
    }, { withCtrlMod: true });
}
else {
    registerQuickPickCommandAndKeybindingRule({
        id: 'quickInput.nextSeparatorWithQuickAccessFallback',
        primary: KeyMod$1.Alt + KeyCode.DownArrow,
        handler: focusHandler(QuickPickFocus.NextSeparator, QuickPickFocus.Next),
        metadata: { description: nextSeparatorFallbackDesc }
    });
    registerQuickPickCommandAndKeybindingRule({
        id: 'quickInput.nextSeparator',
        primary: KeyMod$1.CtrlCmd + KeyMod$1.Alt + KeyCode.DownArrow,
        handler: focusHandler(QuickPickFocus.NextSeparator)
    });
    registerQuickPickCommandAndKeybindingRule({
        id: 'quickInput.previousSeparatorWithQuickAccessFallback',
        primary: KeyMod$1.Alt + KeyCode.UpArrow,
        handler: focusHandler(QuickPickFocus.PreviousSeparator, QuickPickFocus.Previous),
        metadata: { description: prevSeparatorFallbackDesc }
    });
    registerQuickPickCommandAndKeybindingRule({
        id: 'quickInput.previousSeparator',
        primary: KeyMod$1.CtrlCmd + KeyMod$1.Alt + KeyCode.UpArrow,
        handler: focusHandler(QuickPickFocus.PreviousSeparator)
    });
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'quickInput.accept',
    primary: KeyCode.Enter,
    weight: KeybindingWeight.WorkbenchContrib,
    when: ( ContextKeyExpr.and((
    ContextKeyExpr.notEquals(quickInputTypeContextKeyValue, QuickInputType.QuickWidget)), inQuickInputContext, ContextKeyExpr.not('isComposing'))),
    metadata: { description: ( localize(
        2029,
        "Used while in the context of some quick input. If you change one keybinding for this command, you should change all of the other keybindings (modifier variants) of this command as well."
    )) },
    handler: (accessor) => {
        const currentQuickPick = accessor.get(IQuickInputService).currentQuickInput;
        currentQuickPick?.accept();
    },
    secondary: getSecondary(KeyCode.Enter, [], { withAltMod: true, withCtrlMod: true, withCmdMod: true })
});
registerQuickPickCommandAndKeybindingRule({
    id: 'quickInput.acceptInBackground',
    when: ( ContextKeyExpr.and(inQuickInputContext, ( ContextKeyExpr.equals(quickInputTypeContextKeyValue, QuickInputType.QuickPick)), ( ContextKeyExpr.or(( InputFocusedContext.negate()), endOfQuickInputBoxContext)))),
    primary: KeyCode.RightArrow,
    weight: KeybindingWeight.WorkbenchContrib + 50,
    handler: (accessor) => {
        const currentQuickPick = accessor.get(IQuickInputService).currentQuickInput;
        currentQuickPick?.accept(true);
    },
}, { withAltMod: true, withCtrlMod: true, withCmdMod: true });
registerQuickInputCommandAndKeybindingRule({
    id: 'quickInput.hide',
    primary: KeyCode.Escape,
    handler: (accessor) => {
        const currentQuickPick = accessor.get(IQuickInputService).currentQuickInput;
        currentQuickPick?.hide();
    }
}, { withAltMod: true, withCtrlMod: true, withCmdMod: true });
registerQuickPickCommandAndKeybindingRule({
    id: 'quickInput.toggleCheckbox',
    when: ( ContextKeyExpr.and(inQuickInputContext, ( ContextKeyExpr.or(( ContextKeyExpr.equals(quickInputTypeContextKeyValue, QuickInputType.QuickPick)), ( ContextKeyExpr.equals(quickInputTypeContextKeyValue, QuickInputType.QuickTree)))), ( InputFocusedContext.negate()))),
    primary: KeyCode.Space,
    handler: accessor => {
        const quickInputService = accessor.get(IQuickInputService);
        quickInputService.toggle();
    }
});
registerQuickPickCommandAndKeybindingRule({
    id: 'quickInput.toggleHover',
    primary: ctrlKeyMod | KeyCode.Space,
    handler: accessor => {
        const quickInputService = accessor.get(IQuickInputService);
        quickInputService.toggleHover();
    }
});
