import { Event } from "../../../base/common/event.js";
import { Disposable, IDisposable } from "../../../base/common/lifecycle.js";
import { URI } from "../../../base/common/uri.js";
import { ILocalizedString } from "../../action/common/action.js";
import { RawContextKey } from "../../contextkey/common/contextkey.js";
import { IEnvironmentService } from "../../environment/common/environment.service.js";
import { ILogService, type ILoggerService } from "./log.service.js";
export declare function isLogLevel(thing: unknown): thing is LogLevel;
export declare enum LogLevel {
    Off = 0,
    Trace = 1,
    Debug = 2,
    Info = 3,
    Warning = 4,
    Error = 5
}
export declare const DEFAULT_LOG_LEVEL: LogLevel;
export interface ILogger extends IDisposable {
    readonly onDidChangeLogLevel: Event<LogLevel>;
    getLevel(): LogLevel;
    setLevel(level: LogLevel): void;
    trace(message: string, ...args: unknown[]): void;
    debug(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string, ...args: unknown[]): void;
    error(message: string | Error, ...args: unknown[]): void;
    /**
     * An operation to flush the contents. Can be synchronous.
     */
    flush(): void;
}
export declare function canLog(loggerLevel: LogLevel, messageLevel: LogLevel): boolean;
export declare function log(logger: ILogger, level: LogLevel, message: string): void;
export type LoggerGroup = {
    readonly id: string;
    readonly name: string;
};
export interface ILoggerOptions {
    /**
     * Id of the logger.
     */
    id?: string;
    /**
     * Name of the logger.
     */
    name?: string;
    /**
     * Do not create rotating files if max size exceeds.
     */
    donotRotate?: boolean;
    /**
     * Do not use formatters.
     */
    donotUseFormatters?: boolean;
    /**
     * When to log. Set to `always` to log always.
     */
    logLevel?: "always" | LogLevel;
    /**
     * Whether the log should be hidden from the user.
     */
    hidden?: boolean;
    /**
     * Condition which must be true to show this logger
     */
    when?: string;
    /**
     * Id of the extension that created this logger.
     */
    extensionId?: string;
    /**
     * Group of the logger.
     */
    group?: LoggerGroup;
}
export interface ILoggerResource {
    readonly resource: URI;
    readonly id: string;
    readonly name?: string;
    readonly logLevel?: LogLevel;
    readonly hidden?: boolean;
    readonly when?: string;
    readonly extensionId?: string;
    readonly group?: LoggerGroup;
}
export type DidChangeLoggersEvent = {
    readonly added: Iterable<ILoggerResource>;
    readonly removed: Iterable<ILoggerResource>;
};
export declare abstract class AbstractLogger extends Disposable implements ILogger {
    private level;
    private readonly _onDidChangeLogLevel;
    get onDidChangeLogLevel(): Event<LogLevel>;
    setLevel(level: LogLevel): void;
    getLevel(): LogLevel;
    protected checkLogLevel(level: LogLevel): boolean;
    protected canLog(level: LogLevel): boolean;
    abstract trace(message: string, ...args: unknown[]): void;
    abstract debug(message: string, ...args: unknown[]): void;
    abstract info(message: string, ...args: unknown[]): void;
    abstract warn(message: string, ...args: unknown[]): void;
    abstract error(message: string | Error, ...args: unknown[]): void;
    abstract flush(): void;
}
export declare abstract class AbstractMessageLogger extends AbstractLogger implements ILogger {
    private readonly logAlways?;
    constructor(logAlways?: boolean | undefined);
    protected checkLogLevel(level: LogLevel): boolean;
    trace(message: string, ...args: unknown[]): void;
    debug(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string, ...args: unknown[]): void;
    error(message: string | Error, ...args: unknown[]): void;
    flush(): void;
    protected abstract log(level: LogLevel, message: string): void;
}
export declare class ConsoleMainLogger extends AbstractLogger implements ILogger {
    private useColors;
    constructor(logLevel?: LogLevel);
    trace(message: string, ...args: unknown[]): void;
    debug(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string | Error, ...args: unknown[]): void;
    error(message: string, ...args: unknown[]): void;
    flush(): void;
}
export declare class ConsoleLogger extends AbstractLogger implements ILogger {
    private readonly useColors;
    constructor(logLevel?: LogLevel, useColors?: boolean);
    trace(message: string, ...args: unknown[]): void;
    debug(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string | Error, ...args: unknown[]): void;
    error(message: string, ...args: unknown[]): void;
    flush(): void;
}
export declare class AdapterLogger extends AbstractLogger implements ILogger {
    private readonly adapter;
    constructor(adapter: {
        log: (logLevel: LogLevel, args: any[]) => void;
    }, logLevel?: LogLevel);
    trace(message: string, ...args: unknown[]): void;
    debug(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string | Error, ...args: unknown[]): void;
    error(message: string | Error, ...args: unknown[]): void;
    private extractMessage;
    flush(): void;
}
export declare class MultiplexLogger extends AbstractLogger implements ILogger {
    private readonly loggers;
    constructor(loggers: ReadonlyArray<ILogger>);
    setLevel(level: LogLevel): void;
    trace(message: string, ...args: unknown[]): void;
    debug(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string, ...args: unknown[]): void;
    error(message: string | Error, ...args: unknown[]): void;
    flush(): void;
    dispose(): void;
}
export declare abstract class AbstractLoggerService extends Disposable implements ILoggerService {
    protected logLevel: LogLevel;
    private readonly logsHome;
    readonly _serviceBrand: undefined;
    private readonly _loggers;
    private _onDidChangeLoggers;
    readonly onDidChangeLoggers: Event<{
        added: ILoggerResource[];
        removed: ILoggerResource[];
    }>;
    private _onDidChangeLogLevel;
    readonly onDidChangeLogLevel: Event<LogLevel | [
        URI,
        LogLevel
    ]>;
    private _onDidChangeVisibility;
    readonly onDidChangeVisibility: Event<[
        URI,
        boolean
    ]>;
    constructor(logLevel: LogLevel, logsHome: URI, loggerResources?: Iterable<ILoggerResource>);
    private getLoggerEntry;
    getLogger(resourceOrId: URI | string): ILogger | undefined;
    createLogger(idOrResource: URI | string, options?: ILoggerOptions): ILogger;
    protected toResource(idOrResource: string | URI): URI;
    setLogLevel(logLevel: LogLevel): void;
    setLogLevel(resource: URI, logLevel: LogLevel): void;
    setVisibility(resourceOrId: URI | string, visibility: boolean): void;
    getLogLevel(resource?: URI): LogLevel;
    registerLogger(resource: ILoggerResource): void;
    deregisterLogger(idOrResource: URI | string): void;
    getRegisteredLoggers(): Iterable<ILoggerResource>;
    getRegisteredLogger(resource: URI): ILoggerResource | undefined;
    dispose(): void;
    protected abstract doCreateLogger(resource: URI, logLevel: LogLevel, options?: ILoggerOptions): ILogger;
}
export declare class NullLogger implements ILogger {
    readonly onDidChangeLogLevel: Event<LogLevel>;
    setLevel(level: LogLevel): void;
    getLevel(): LogLevel;
    trace(message: string, ...args: unknown[]): void;
    debug(message: string, ...args: unknown[]): void;
    info(message: string, ...args: unknown[]): void;
    warn(message: string, ...args: unknown[]): void;
    error(message: string | Error, ...args: unknown[]): void;
    critical(message: string | Error, ...args: unknown[]): void;
    dispose(): void;
    flush(): void;
}
export declare class NullLogService extends NullLogger implements ILogService {
    readonly _serviceBrand: undefined;
}
export declare class NullLoggerService extends AbstractLoggerService {
    constructor();
    protected doCreateLogger(resource: URI, logLevel: LogLevel, options?: ILoggerOptions): ILogger;
}
export declare function getLogLevel(environmentService: IEnvironmentService): LogLevel;
export declare function LogLevelToString(logLevel: LogLevel): string;
export declare function LogLevelToLocalizedString(logLevel: LogLevel): ILocalizedString;
export declare function parseLogLevel(logLevel: string): LogLevel | undefined;
export declare const CONTEXT_LOG_LEVEL: RawContextKey<string>;
