import { Event } from "../../../base/common/event.js";
import { Disposable, DisposableStore } from "../../../base/common/lifecycle.js";
import { IStorage, IStorageChangeEvent, StorageValue } from "../../../base/parts/storage/common/storage.js";
import { IUserDataProfile } from "../../userDataProfile/common/userDataProfile.js";
import { IAnyWorkspaceIdentifier } from "../../workspace/common/workspace.js";
import { IStorageService } from "./storage.service.js";
export declare const IS_NEW_KEY = "__$__isNewStorageMarker";
export declare const TARGET_KEY = "__$__targetStorageMarker";
export declare enum WillSaveStateReason {
    /**
     * No specific reason to save state.
     */
    NONE = 0,
    /**
     * A hint that the workbench is about to shutdown.
     */
    SHUTDOWN = 1
}
export interface IWillSaveStateEvent {
    readonly reason: WillSaveStateReason;
}
export interface IStorageEntry {
    readonly key: string;
    readonly value: StorageValue;
    readonly scope: StorageScope;
    readonly target: StorageTarget;
}
export interface IWorkspaceStorageValueChangeEvent extends IStorageValueChangeEvent {
    readonly scope: StorageScope.WORKSPACE;
}
export interface IProfileStorageValueChangeEvent extends IStorageValueChangeEvent {
    readonly scope: StorageScope.PROFILE;
}
export interface IApplicationStorageValueChangeEvent extends IStorageValueChangeEvent {
    readonly scope: StorageScope.APPLICATION;
}
export declare enum StorageScope {
    /**
     * The stored data will be scoped to all workspaces across all profiles.
     */
    APPLICATION = -1,
    /**
     * The stored data will be scoped to all workspaces of the same profile.
     */
    PROFILE = 0,
    /**
     * The stored data will be scoped to the current workspace.
     */
    WORKSPACE = 1
}
export declare enum StorageTarget {
    /**
     * The stored data is user specific and applies across machines.
     */
    USER = 0,
    /**
     * The stored data is machine specific.
     */
    MACHINE = 1
}
export interface IStorageValueChangeEvent {
    /**
     * The scope for the storage entry that changed
     * or was removed.
     */
    readonly scope: StorageScope;
    /**
     * The `key` of the storage entry that was changed
     * or was removed.
     */
    readonly key: string;
    /**
     * The `target` can be `undefined` if a key is being
     * removed.
     */
    readonly target: StorageTarget | undefined;
    /**
     * A hint how the storage change event was triggered. If
     * `true`, the storage change was triggered by an external
     * source, such as:
     * - another process (for example another window)
     * - operations such as settings sync or profiles change
     */
    readonly external?: boolean;
}
export interface IStorageTargetChangeEvent {
    /**
     * The scope for the target that changed. Listeners
     * should use `keys(scope, target)` to get an updated
     * list of keys for the given `scope` and `target`.
     */
    readonly scope: StorageScope;
}
interface IKeyTargets {
    [key: string]: StorageTarget;
}
export interface IStorageServiceOptions {
    readonly flushInterval: number;
}
export declare function loadKeyTargets(storage: IStorage): IKeyTargets;
export declare abstract class AbstractStorageService extends Disposable implements IStorageService {
    readonly _serviceBrand: undefined;
    private static DEFAULT_FLUSH_INTERVAL;
    private readonly _onDidChangeValue;
    private readonly _onDidChangeTarget;
    readonly onDidChangeTarget: Event<IStorageTargetChangeEvent>;
    private readonly _onWillSaveState;
    readonly onWillSaveState: Event<IWillSaveStateEvent>;
    private initializationPromise;
    private readonly flushWhenIdleScheduler;
    private readonly runFlushWhenIdle;
    constructor(options?: IStorageServiceOptions);
    onDidChangeValue(scope: StorageScope.WORKSPACE, key: string | undefined, disposable: DisposableStore): Event<IWorkspaceStorageValueChangeEvent>;
    onDidChangeValue(scope: StorageScope.PROFILE, key: string | undefined, disposable: DisposableStore): Event<IProfileStorageValueChangeEvent>;
    onDidChangeValue(scope: StorageScope.APPLICATION, key: string | undefined, disposable: DisposableStore): Event<IApplicationStorageValueChangeEvent>;
    private doFlushWhenIdle;
    protected shouldFlushWhenIdle(): boolean;
    protected stopFlushWhenIdle(): void;
    initialize(): Promise<void>;
    protected emitDidChangeValue(scope: StorageScope, event: IStorageChangeEvent): void;
    protected emitWillSaveState(reason: WillSaveStateReason): void;
    get(key: string, scope: StorageScope, fallbackValue: string): string;
    get(key: string, scope: StorageScope): string | undefined;
    getBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;
    getBoolean(key: string, scope: StorageScope): boolean | undefined;
    getNumber(key: string, scope: StorageScope, fallbackValue: number): number;
    getNumber(key: string, scope: StorageScope): number | undefined;
    getObject(key: string, scope: StorageScope, fallbackValue: object): object;
    getObject(key: string, scope: StorageScope): object | undefined;
    storeAll(entries: Array<IStorageEntry>, external: boolean): void;
    store(key: string, value: StorageValue, scope: StorageScope, target: StorageTarget, external?: boolean): void;
    remove(key: string, scope: StorageScope, external?: boolean): void;
    private withPausedEmitters;
    keys(scope: StorageScope, target: StorageTarget): string[];
    private updateKeyTarget;
    private _workspaceKeyTargets;
    private get workspaceKeyTargets();
    private _profileKeyTargets;
    private get profileKeyTargets();
    private _applicationKeyTargets;
    private get applicationKeyTargets();
    private getKeyTargets;
    private loadKeyTargets;
    isNew(scope: StorageScope): boolean;
    flush(reason?: WillSaveStateReason): Promise<void>;
    log(): Promise<void>;
    optimize(scope: StorageScope): Promise<void>;
    switch(to: IAnyWorkspaceIdentifier | IUserDataProfile, preserveData: boolean): Promise<void>;
    protected canSwitchProfile(from: IUserDataProfile, to: IUserDataProfile): boolean;
    protected switchData(oldStorage: Map<string, string>, newStorage: IStorage, scope: StorageScope): void;
    abstract hasScope(scope: IAnyWorkspaceIdentifier | IUserDataProfile): boolean;
    protected abstract doInitialize(): Promise<void>;
    protected abstract getStorage(scope: StorageScope): IStorage | undefined;
    protected abstract getLogDetails(scope: StorageScope): string | undefined;
    protected abstract switchToProfile(toProfile: IUserDataProfile, preserveData: boolean): Promise<void>;
    protected abstract switchToWorkspace(toWorkspace: IAnyWorkspaceIdentifier | IUserDataProfile, preserveData: boolean): Promise<void>;
}
export declare function isProfileUsingDefaultStorage(profile: IUserDataProfile): boolean;
export declare class InMemoryStorageService extends AbstractStorageService {
    private readonly applicationStorage;
    private readonly profileStorage;
    private readonly workspaceStorage;
    constructor();
    protected getStorage(scope: StorageScope): IStorage;
    protected getLogDetails(scope: StorageScope): string | undefined;
    protected doInitialize(): Promise<void>;
    protected switchToProfile(): Promise<void>;
    protected switchToWorkspace(): Promise<void>;
    protected shouldFlushWhenIdle(): boolean;
    hasScope(scope: IAnyWorkspaceIdentifier | IUserDataProfile): boolean;
}
export declare function logStorage(application: Map<string, string>, profile: Map<string, string>, workspace: Map<string, string>, applicationPath: string, profilePath: string, workspacePath: string): Promise<void>;
export {};
