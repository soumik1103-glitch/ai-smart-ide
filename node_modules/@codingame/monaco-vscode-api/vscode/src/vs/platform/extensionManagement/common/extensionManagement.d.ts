import { CancellationToken } from "../../../base/common/cancellation.js";
import { IStringDictionary } from "../../../base/common/collections.js";
import { Platform } from "../../../base/common/platform.js";
import { URI } from "../../../base/common/uri.js";
import { IExtension, TargetPlatform } from "../../extensions/common/extensions.js";
import { IFileService } from "../../files/common/files.service.js";
import { IExtensionGalleryManifest } from "./extensionGalleryManifest.js";
export declare const EXTENSION_IDENTIFIER_PATTERN = "^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$";
export declare const EXTENSION_IDENTIFIER_REGEX: RegExp;
export declare const WEB_EXTENSION_TAG = "__web_extension";
export declare const EXTENSION_INSTALL_SKIP_WALKTHROUGH_CONTEXT = "skipWalkthrough";
export declare const EXTENSION_INSTALL_SKIP_PUBLISHER_TRUST_CONTEXT = "skipPublisherTrust";
export declare const EXTENSION_INSTALL_SOURCE_CONTEXT = "extensionInstallSource";
export declare const EXTENSION_INSTALL_DEP_PACK_CONTEXT = "dependecyOrPackExtensionInstall";
export declare const EXTENSION_INSTALL_CLIENT_TARGET_PLATFORM_CONTEXT = "clientTargetPlatform";
export declare enum ExtensionInstallSource {
    COMMAND = "command",
    SETTINGS_SYNC = "settingsSync"
}
export interface IProductVersion {
    readonly version: string;
    readonly date?: string;
}
export declare function TargetPlatformToString(targetPlatform: TargetPlatform): "Web" | "Mac" | TargetPlatform.UNIVERSAL | TargetPlatform.UNKNOWN | TargetPlatform.UNDEFINED | "Windows 64 bit" | "Windows ARM" | "Linux 64 bit" | "Linux ARM 64" | "Linux ARM" | "Alpine Linux 64 bit" | "Alpine ARM 64" | "Mac Silicon";
export declare function toTargetPlatform(targetPlatform: string): TargetPlatform;
export declare function getTargetPlatform(platform: Platform | "alpine", arch: string | undefined): TargetPlatform;
export declare function isNotWebExtensionInWebTargetPlatform(allTargetPlatforms: TargetPlatform[], productTargetPlatform: TargetPlatform): boolean;
export declare function isTargetPlatformCompatible(extensionTargetPlatform: TargetPlatform, allTargetPlatforms: TargetPlatform[], productTargetPlatform: TargetPlatform): boolean;
export interface IGalleryExtensionProperties {
    dependencies?: string[];
    extensionPack?: string[];
    engine?: string;
    enabledApiProposals?: string[];
    localizedLanguages?: string[];
    targetPlatform: TargetPlatform;
    isPreReleaseVersion: boolean;
    executesCode?: boolean;
}
export interface IGalleryExtensionAsset {
    uri: string;
    fallbackUri: string;
}
export interface IGalleryExtensionAssets {
    manifest: IGalleryExtensionAsset | null;
    readme: IGalleryExtensionAsset | null;
    changelog: IGalleryExtensionAsset | null;
    license: IGalleryExtensionAsset | null;
    repository: IGalleryExtensionAsset | null;
    download: IGalleryExtensionAsset;
    icon: IGalleryExtensionAsset | null;
    signature: IGalleryExtensionAsset | null;
    coreTranslations: [
        string,
        IGalleryExtensionAsset
    ][];
}
export declare function isIExtensionIdentifier(obj: unknown): obj is IExtensionIdentifier;
export interface IExtensionIdentifier {
    id: string;
    uuid?: string;
}
export interface IGalleryExtensionIdentifier extends IExtensionIdentifier {
    uuid: string;
}
export interface IGalleryExtensionVersion {
    version: string;
    date: string;
    isPreReleaseVersion: boolean;
    targetPlatforms: TargetPlatform[];
}
export interface IGalleryExtension {
    type: "gallery";
    name: string;
    identifier: IGalleryExtensionIdentifier;
    version: string;
    displayName: string;
    publisherId: string;
    publisher: string;
    publisherDisplayName: string;
    publisherDomain?: {
        link: string;
        verified: boolean;
    };
    publisherLink?: string;
    publisherSponsorLink?: string;
    description: string;
    installCount: number;
    rating: number;
    ratingCount: number;
    categories: readonly string[];
    tags: readonly string[];
    releaseDate: number;
    lastUpdated: number;
    preview: boolean;
    private: boolean;
    hasPreReleaseVersion: boolean;
    hasReleaseVersion: boolean;
    isSigned: boolean;
    allTargetPlatforms: TargetPlatform[];
    assets: IGalleryExtensionAssets;
    properties: IGalleryExtensionProperties;
    detailsLink?: string;
    ratingLink?: string;
    supportLink?: string;
    telemetryData?: IStringDictionary<unknown>;
    queryContext?: IStringDictionary<unknown>;
}
export type InstallSource = "gallery" | "vsix" | "resource";
export interface IGalleryMetadata {
    id: string;
    publisherId: string;
    private: boolean;
    publisherDisplayName: string;
    isPreReleaseVersion: boolean;
    targetPlatform?: TargetPlatform;
}
export type Metadata = Partial<IGalleryMetadata & {
    isApplicationScoped: boolean;
    isMachineScoped: boolean;
    isBuiltin: boolean;
    isSystem: boolean;
    updated: boolean;
    preRelease: boolean;
    hasPreReleaseVersion: boolean;
    installedTimestamp: number;
    pinned: boolean;
    source: InstallSource;
    size: number;
}>;
export interface ILocalExtension extends IExtension {
    isWorkspaceScoped: boolean;
    isMachineScoped: boolean;
    isApplicationScoped: boolean;
    publisherId: string | null;
    installedTimestamp?: number;
    isPreReleaseVersion: boolean;
    hasPreReleaseVersion: boolean;
    private: boolean;
    preRelease: boolean;
    updated: boolean;
    pinned: boolean;
    source: InstallSource;
    size: number;
}
export declare enum SortBy {
    NoneOrRelevance = "NoneOrRelevance",
    LastUpdatedDate = "LastUpdatedDate",
    Title = "Title",
    PublisherName = "PublisherName",
    InstallCount = "InstallCount",
    PublishedDate = "PublishedDate",
    AverageRating = "AverageRating",
    WeightedRating = "WeightedRating"
}
export declare enum SortOrder {
    Default = 0,
    Ascending = 1,
    Descending = 2
}
export declare enum FilterType {
    Category = "Category",
    ExtensionId = "ExtensionId",
    ExtensionName = "ExtensionName",
    ExcludeWithFlags = "ExcludeWithFlags",
    Featured = "Featured",
    SearchText = "SearchText",
    Tag = "Tag",
    Target = "Target"
}
export interface IQueryOptions {
    text?: string;
    exclude?: string[];
    pageSize?: number;
    sortBy?: SortBy;
    sortOrder?: SortOrder;
    source?: string;
    includePreRelease?: boolean;
    productVersion?: IProductVersion;
}
export declare enum StatisticType {
    Install = "install",
    Uninstall = "uninstall"
}
export interface IDeprecationInfo {
    readonly disallowInstall?: boolean;
    readonly extension?: {
        readonly id: string;
        readonly displayName: string;
        readonly autoMigrate?: {
            readonly storage: boolean;
        };
        readonly preRelease?: boolean;
    };
    readonly settings?: readonly string[];
    readonly additionalInfo?: string;
}
export interface ISearchPrefferedResults {
    readonly query?: string;
    readonly preferredResults?: string[];
}
export type MaliciousExtensionInfo = {
    readonly extensionOrPublisher: IExtensionIdentifier | string;
    readonly learnMoreLink?: string;
};
export interface IExtensionsControlManifest {
    readonly malicious: ReadonlyArray<MaliciousExtensionInfo>;
    readonly deprecated: IStringDictionary<IDeprecationInfo>;
    readonly search: ISearchPrefferedResults[];
    readonly autoUpdate?: IStringDictionary<string>;
}
export declare enum InstallOperation {
    None = 1,
    Install = 2,
    Update = 3,
    Migrate = 4
}
export interface ITranslation {
    contents: {
        [key: string]: {};
    };
}
export interface IExtensionInfo extends IExtensionIdentifier {
    version?: string;
    preRelease?: boolean;
    hasPreRelease?: boolean;
}
export interface IExtensionQueryOptions {
    targetPlatform?: TargetPlatform;
    productVersion?: IProductVersion;
    compatible?: boolean;
    queryAllVersions?: boolean;
    source?: string;
}
export interface IExtensionGalleryCapabilities {
    readonly query: {
        readonly sortBy: readonly SortBy[];
        readonly filters: readonly FilterType[];
    };
    readonly allRepositorySigned: boolean;
}
export interface InstallExtensionEvent {
    readonly identifier: IExtensionIdentifier;
    readonly source: URI | IGalleryExtension;
    readonly profileLocation: URI;
    readonly applicationScoped?: boolean;
    readonly workspaceScoped?: boolean;
}
export interface InstallExtensionResult {
    readonly identifier: IExtensionIdentifier;
    readonly operation: InstallOperation;
    readonly source?: URI | IGalleryExtension;
    readonly local?: ILocalExtension;
    readonly error?: Error;
    readonly context?: IStringDictionary<unknown>;
    readonly profileLocation: URI;
    readonly applicationScoped?: boolean;
    readonly workspaceScoped?: boolean;
}
export interface UninstallExtensionEvent {
    readonly identifier: IExtensionIdentifier;
    readonly profileLocation: URI;
    readonly applicationScoped?: boolean;
    readonly workspaceScoped?: boolean;
}
export interface DidUninstallExtensionEvent {
    readonly identifier: IExtensionIdentifier;
    readonly error?: string;
    readonly profileLocation: URI;
    readonly applicationScoped?: boolean;
    readonly workspaceScoped?: boolean;
}
export interface DidUpdateExtensionMetadata {
    readonly profileLocation: URI;
    readonly local: ILocalExtension;
}
export declare enum ExtensionGalleryErrorCode {
    Timeout = "Timeout",
    Cancelled = "Cancelled",
    ClientError = "ClientError",
    ServerError = "ServerError",
    Failed = "Failed",
    DownloadFailedWriting = "DownloadFailedWriting",
    Offline = "Offline"
}
export declare class ExtensionGalleryError extends Error {
    readonly code: ExtensionGalleryErrorCode;
    constructor(message: string, code: ExtensionGalleryErrorCode);
}
export declare enum ExtensionManagementErrorCode {
    NotFound = "NotFound",
    Unsupported = "Unsupported",
    Deprecated = "Deprecated",
    Malicious = "Malicious",
    Incompatible = "Incompatible",
    IncompatibleApi = "IncompatibleApi",
    IncompatibleTargetPlatform = "IncompatibleTargetPlatform",
    ReleaseVersionNotFound = "ReleaseVersionNotFound",
    Invalid = "Invalid",
    Download = "Download",
    DownloadSignature = "DownloadSignature",
    DownloadFailedWriting = "DownloadFailedWriting",
    UpdateMetadata = "UpdateMetadata",
    Extract = "Extract",
    Scanning = "Scanning",
    ScanningExtension = "ScanningExtension",
    ReadRemoved = "ReadRemoved",
    UnsetRemoved = "UnsetRemoved",
    Delete = "Delete",
    Rename = "Rename",
    IntializeDefaultProfile = "IntializeDefaultProfile",
    AddToProfile = "AddToProfile",
    InstalledExtensionNotFound = "InstalledExtensionNotFound",
    PostInstall = "PostInstall",
    CorruptZip = "CorruptZip",
    IncompleteZip = "IncompleteZip",
    PackageNotSigned = "PackageNotSigned",
    SignatureVerificationInternal = "SignatureVerificationInternal",
    SignatureVerificationFailed = "SignatureVerificationFailed",
    NotAllowed = "NotAllowed",
    Gallery = "Gallery",
    Cancelled = "Cancelled",
    Unknown = "Unknown",
    Internal = "Internal"
}
export declare enum ExtensionSignatureVerificationCode {
    "NotSigned" = "NotSigned",
    "Success" = "Success",
    "RequiredArgumentMissing" = "RequiredArgumentMissing",// A required argument is missing.
    "InvalidArgument" = "InvalidArgument",// An argument is invalid.
    "PackageIsUnreadable" = "PackageIsUnreadable",// The extension package is unreadable.
    "UnhandledException" = "UnhandledException",// An unhandled exception occurred.
    "SignatureManifestIsMissing" = "SignatureManifestIsMissing",// The extension is missing a signature manifest file (.signature.manifest).
    "SignatureManifestIsUnreadable" = "SignatureManifestIsUnreadable",// The signature manifest is unreadable.
    "SignatureIsMissing" = "SignatureIsMissing",// The extension is missing a signature file (.signature.p7s).
    "SignatureIsUnreadable" = "SignatureIsUnreadable",// The signature is unreadable.
    "CertificateIsUnreadable" = "CertificateIsUnreadable",// The certificate is unreadable.
    "SignatureArchiveIsUnreadable" = "SignatureArchiveIsUnreadable",
    "FileAlreadyExists" = "FileAlreadyExists",// The output file already exists.
    "SignatureArchiveIsInvalidZip" = "SignatureArchiveIsInvalidZip",
    "SignatureArchiveHasSameSignatureFile" = "SignatureArchiveHasSameSignatureFile",// The signature archive has the same signature file.
    "PackageIntegrityCheckFailed" = "PackageIntegrityCheckFailed",// The package integrity check failed.
    "SignatureIsInvalid" = "SignatureIsInvalid",// The extension has an invalid signature file (.signature.p7s).
    "SignatureManifestIsInvalid" = "SignatureManifestIsInvalid",// The extension has an invalid signature manifest file (.signature.manifest).
    "SignatureIntegrityCheckFailed" = "SignatureIntegrityCheckFailed",// The extension's signature integrity check failed.  Extension integrity is suspect.
    "EntryIsMissing" = "EntryIsMissing",// An entry referenced in the signature manifest was not found in the extension.
    "EntryIsTampered" = "EntryIsTampered",// The integrity check for an entry referenced in the signature manifest failed.
    "Untrusted" = "Untrusted",// An X.509 certificate in the extension signature is untrusted.
    "CertificateRevoked" = "CertificateRevoked",// An X.509 certificate in the extension signature has been revoked.
    "SignatureIsNotValid" = "SignatureIsNotValid",// The extension signature is invalid.
    "UnknownError" = "UnknownError",// An unknown error occurred.
    "PackageIsInvalidZip" = "PackageIsInvalidZip",// The extension package is not valid ZIP format.
    "SignatureArchiveHasTooManyEntries" = "SignatureArchiveHasTooManyEntries"
}
export declare class ExtensionManagementError extends Error {
    readonly code: ExtensionManagementErrorCode;
    constructor(message: string, code: ExtensionManagementErrorCode);
}
export interface InstallExtensionSummary {
    failed: {
        id: string;
        installOptions: InstallOptions;
    }[];
}
export type InstallOptions = {
    isBuiltin?: boolean;
    isWorkspaceScoped?: boolean;
    isMachineScoped?: boolean;
    isApplicationScoped?: boolean;
    pinned?: boolean;
    donotIncludePackAndDependencies?: boolean;
    installGivenVersion?: boolean;
    preRelease?: boolean;
    installPreReleaseVersion?: boolean;
    donotVerifySignature?: boolean;
    operation?: InstallOperation;
    profileLocation?: URI;
    productVersion?: IProductVersion;
    keepExisting?: boolean;
    downloadExtensionsLocally?: boolean;
    /**
     * Context passed through to InstallExtensionResult
     */
    context?: IStringDictionary<unknown>;
};
export type UninstallOptions = {
    readonly profileLocation?: URI;
    readonly donotIncludePack?: boolean;
    readonly donotCheckDependents?: boolean;
    readonly versionOnly?: boolean;
    readonly remove?: boolean;
};
export interface IExtensionManagementParticipant {
    postInstall(local: ILocalExtension, source: URI | IGalleryExtension, options: InstallOptions, token: CancellationToken): Promise<void>;
    postUninstall(local: ILocalExtension, options: UninstallOptions, token: CancellationToken): Promise<void>;
}
export type InstallExtensionInfo = {
    readonly extension: IGalleryExtension;
    readonly options: InstallOptions;
};
export type UninstallExtensionInfo = {
    readonly extension: ILocalExtension;
    readonly options?: UninstallOptions;
};
export declare const DISABLED_EXTENSIONS_STORAGE_PATH = "extensionsIdentifiers/disabled";
export declare const ENABLED_EXTENSIONS_STORAGE_PATH = "extensionsIdentifiers/enabled";
export type IConfigBasedExtensionTip = {
    readonly extensionId: string;
    readonly extensionName: string;
    readonly isExtensionPack: boolean;
    readonly configName: string;
    readonly important: boolean;
    readonly whenNotInstalled?: string[];
};
export type IExecutableBasedExtensionTip = {
    readonly extensionId: string;
    readonly extensionName: string;
    readonly isExtensionPack: boolean;
    readonly exeName: string;
    readonly exeFriendlyName: string;
    readonly windowsPath?: string;
    readonly whenNotInstalled?: string[];
};
export type AllowedExtensionsConfigValueType = IStringDictionary<boolean | string | string[]>;
export declare function computeSize(location: URI, fileService: IFileService): Promise<number>;
export declare const ExtensionsLocalizedLabel: import("../../../nls.js").ILocalizedString;
export declare const PreferencesLocalizedLabel: import("../../../nls.js").ILocalizedString;
export declare const AllowedExtensionsConfigKey = "extensions.allowed";
export declare const VerifyExtensionSignatureConfigKey = "extensions.verifySignature";
export declare const ExtensionRequestsTimeoutConfigKey = "extensions.requestTimeout";
export declare function shouldRequireRepositorySignatureFor(isPrivate: boolean, galleryManifest: IExtensionGalleryManifest | null): boolean;
