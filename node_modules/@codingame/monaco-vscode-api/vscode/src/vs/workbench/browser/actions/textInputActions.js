
import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';
import { Separator, toAction } from '../../../base/common/actions.js';
import { localize } from '../../../nls.js';
import { IWorkbenchLayoutService } from '../../services/layout/browser/layoutService.service.js';
import { IContextMenuService } from '../../../platform/contextview/browser/contextView.service.js';
import { Disposable } from '../../../base/common/lifecycle.js';
import { getActiveDocument, isHTMLTextAreaElement, isHTMLInputElement, addDisposableListener, getWindow, EventHelper } from '../../../base/browser/dom.js';
import { registerWorkbenchContribution2, WorkbenchPhase } from '../../common/contributions.js';
import { IClipboardService } from '../../../platform/clipboard/common/clipboardService.service.js';
import { StandardMouseEvent } from '../../../base/browser/mouseEvent.js';
import { Event as Event$1 } from '../../../base/common/event.js';
import { Lazy } from '../../../base/common/lazy.js';
import { ILogService } from '../../../platform/log/common/log.service.js';

function createTextInputActions(clipboardService, logService) {
    return [
        toAction({ id: 'undo', label: ( localize(2918, "Undo")), run: () => getActiveDocument().execCommand('undo') }),
        toAction({ id: 'redo', label: ( localize(2919, "Redo")), run: () => getActiveDocument().execCommand('redo') }),
        ( new Separator()),
        toAction({
            id: 'editor.action.clipboardCutAction', label: ( localize(2920, "Cut")), run: () => {
                logService.trace('TextInputActionsProvider#cut');
                getActiveDocument().execCommand('cut');
            }
        }),
        toAction({
            id: 'editor.action.clipboardCopyAction', label: ( localize(2921, "Copy")), run: () => {
                logService.trace('TextInputActionsProvider#copy');
                getActiveDocument().execCommand('copy');
            }
        }),
        toAction({
            id: 'editor.action.clipboardPasteAction',
            label: ( localize(2922, "Paste")),
            run: async (element) => {
                logService.trace('TextInputActionsProvider#paste');
                const clipboardText = await clipboardService.readText();
                if (isHTMLTextAreaElement(element) || isHTMLInputElement(element)) {
                    const selectionStart = element.selectionStart || 0;
                    const selectionEnd = element.selectionEnd || 0;
                    element.value = `${element.value.substring(0, selectionStart)}${clipboardText}${element.value.substring(selectionEnd, element.value.length)}`;
                    element.selectionStart = selectionStart + clipboardText.length;
                    element.selectionEnd = element.selectionStart;
                    element.dispatchEvent(( new Event('input', { bubbles: true, cancelable: true })));
                }
            }
        }),
        ( new Separator()),
        toAction({ id: 'editor.action.selectAll', label: ( localize(2923, "Select All")), run: () => getActiveDocument().execCommand('selectAll') })
    ];
}
let TextInputActionsProvider = class TextInputActionsProvider extends Disposable {
    static { this.ID = 'workbench.contrib.textInputActionsProvider'; }
    constructor(layoutService, contextMenuService, clipboardService, logService) {
        super();
        this.layoutService = layoutService;
        this.contextMenuService = contextMenuService;
        this.clipboardService = clipboardService;
        this.logService = logService;
        this.textInputActions = ( new Lazy(() => createTextInputActions(this.clipboardService, this.logService)));
        this.registerListeners();
    }
    registerListeners() {
        this._register(Event$1.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container, disposables }) => {
            disposables.add(addDisposableListener(container, 'contextmenu', e => this.onContextMenu(getWindow(container), e)));
        }, { container: this.layoutService.mainContainer, disposables: this._store }));
    }
    onContextMenu(targetWindow, e) {
        if (e.defaultPrevented) {
            return;
        }
        const target = e.target;
        if (!isHTMLTextAreaElement(target) && !isHTMLInputElement(target)) {
            return;
        }
        EventHelper.stop(e, true);
        const event = ( new StandardMouseEvent(targetWindow, e));
        this.contextMenuService.showContextMenu({
            getAnchor: () => event,
            getActions: () => this.textInputActions.value,
            getActionsContext: () => target,
        });
    }
};
TextInputActionsProvider = ( __decorate([
    ( __param(0, IWorkbenchLayoutService)),
    ( __param(1, IContextMenuService)),
    ( __param(2, IClipboardService)),
    ( __param(3, ILogService))
], TextInputActionsProvider));
registerWorkbenchContribution2(TextInputActionsProvider.ID, TextInputActionsProvider, WorkbenchPhase.BlockRestore
);

export { TextInputActionsProvider, createTextInputActions };
