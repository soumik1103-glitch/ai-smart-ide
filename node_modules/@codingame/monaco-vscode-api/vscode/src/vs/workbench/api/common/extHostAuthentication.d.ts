import type * as vscode from "vscode";
import { Emitter, Event } from "../../../base/common/event.js";
import { MainThreadAuthenticationShape, ExtHostAuthenticationShape } from "./extHost.protocol.js";
import { IExtensionDescription } from "../../../platform/extensions/common/extensions.js";
import { IExtHostRpcService } from "./extHostRpcService.js";
import { URI, UriComponents } from "../../../base/common/uri.js";
import { IAuthorizationProtectedResourceMetadata, IAuthorizationServerMetadata, IAuthorizationTokenResponse } from "../../../base/common/oauth.js";
import { IExtHostWindow } from "./extHostWindow.js";
import { IExtHostInitDataService } from "./extHostInitDataService.js";
import { ILogger } from "../../../platform/log/common/log.js";
import { ILoggerService } from "../../../platform/log/common/log.service.js";
import { ILogService } from "../../../platform/log/common/log.service.js";
import { IExtHostUrlsService } from "./extHostUrls.js";
import { IExtHostProgress } from "./extHostProgress.js";
export interface IExtHostAuthentication extends ExtHostAuthentication {
}
export declare const IExtHostAuthentication: import("../../../platform/instantiation/common/instantiation.js").ServiceIdentifier<IExtHostAuthentication>;
export declare class ExtHostAuthentication implements ExtHostAuthenticationShape {
    private readonly _initData;
    private readonly _extHostWindow;
    private readonly _extHostUrls;
    private readonly _extHostProgress;
    private readonly _extHostLoggerService;
    private readonly _logService;
    _serviceBrand: undefined;
    protected readonly _dynamicAuthProviderCtor: typeof DynamicAuthProvider;
    private _proxy;
    private _authenticationProviders;
    private _providerOperations;
    private _onDidChangeSessions;
    private _getSessionTaskSingler;
    private _onDidDynamicAuthProviderTokensChange;
    constructor(extHostRpc: IExtHostRpcService, _initData: IExtHostInitDataService, _extHostWindow: IExtHostWindow, _extHostUrls: IExtHostUrlsService, _extHostProgress: IExtHostProgress, _extHostLoggerService: ILoggerService, _logService: ILogService);
    /**
     * This sets up an event that will fire when the auth sessions change with a built-in filter for the extensionId
     * if a session change only affects a specific extension.
     * @param extensionId The extension that is interested in the event.
     * @returns An event with a built-in filter for the extensionId
     */
    getExtensionScopedSessionsEvent(extensionId: string): Event<vscode.AuthenticationSessionsChangeEvent>;
    getSession(requestingExtension: IExtensionDescription, providerId: string, scopesOrRequest: readonly string[] | vscode.AuthenticationWwwAuthenticateRequest, options: vscode.AuthenticationGetSessionOptions & ({
        createIfNone: true;
    } | {
        forceNewSession: true;
    } | {
        forceNewSession: vscode.AuthenticationForceNewSessionOptions;
    })): Promise<vscode.AuthenticationSession>;
    getSession(requestingExtension: IExtensionDescription, providerId: string, scopesOrRequest: readonly string[] | vscode.AuthenticationWwwAuthenticateRequest, options: vscode.AuthenticationGetSessionOptions & {
        forceNewSession: true;
    }): Promise<vscode.AuthenticationSession>;
    getSession(requestingExtension: IExtensionDescription, providerId: string, scopesOrRequest: readonly string[] | vscode.AuthenticationWwwAuthenticateRequest, options: vscode.AuthenticationGetSessionOptions & {
        forceNewSession: vscode.AuthenticationForceNewSessionOptions;
    }): Promise<vscode.AuthenticationSession>;
    getSession(requestingExtension: IExtensionDescription, providerId: string, scopesOrRequest: readonly string[] | vscode.AuthenticationWwwAuthenticateRequest, options: vscode.AuthenticationGetSessionOptions): Promise<vscode.AuthenticationSession | undefined>;
    getAccounts(providerId: string): Promise<readonly import("../../services/authentication/common/authentication.js").AuthenticationSessionAccount[]>;
    registerAuthenticationProvider(id: string, label: string, provider: vscode.AuthenticationProvider, options?: vscode.AuthenticationProviderOptions): vscode.Disposable;
    $createSession(providerId: string, scopes: string[], options: vscode.AuthenticationProviderSessionOptions): Promise<vscode.AuthenticationSession>;
    $removeSession(providerId: string, sessionId: string): Promise<void>;
    $getSessions(providerId: string, scopes: ReadonlyArray<string> | undefined, options: vscode.AuthenticationProviderSessionOptions): Promise<ReadonlyArray<vscode.AuthenticationSession>>;
    $getSessionsFromChallenges(providerId: string, constraint: vscode.AuthenticationConstraint, options: vscode.AuthenticationProviderSessionOptions): Promise<ReadonlyArray<vscode.AuthenticationSession>>;
    $createSessionFromChallenges(providerId: string, constraint: vscode.AuthenticationConstraint, options: vscode.AuthenticationProviderSessionOptions): Promise<vscode.AuthenticationSession>;
    $onDidChangeAuthenticationSessions(id: string, label: string, extensionIdFilter?: string[]): Promise<void>;
    $onDidUnregisterAuthenticationProvider(id: string): Promise<void>;
    $registerDynamicAuthProvider(authorizationServerComponents: UriComponents, serverMetadata: IAuthorizationServerMetadata, resourceMetadata: IAuthorizationProtectedResourceMetadata | undefined, clientId: string | undefined, clientSecret: string | undefined, initialTokens: IAuthorizationToken[] | undefined): Promise<string>;
    $onDidChangeDynamicAuthProviderTokens(authProviderId: string, clientId: string, tokens: IAuthorizationToken[]): Promise<void>;
}
export declare class DynamicAuthProvider implements vscode.AuthenticationProvider {
    protected readonly _extHostWindow: IExtHostWindow;
    protected readonly _extHostUrls: IExtHostUrlsService;
    protected readonly _initData: IExtHostInitDataService;
    private readonly _extHostProgress;
    protected readonly _proxy: MainThreadAuthenticationShape;
    readonly authorizationServer: URI;
    protected readonly _serverMetadata: IAuthorizationServerMetadata;
    protected readonly _resourceMetadata: IAuthorizationProtectedResourceMetadata | undefined;
    protected _clientId: string;
    protected _clientSecret: string | undefined;
    readonly id: string;
    readonly label: string;
    private _onDidChangeSessions;
    readonly onDidChangeSessions: Event<vscode.AuthenticationProviderAuthenticationSessionsChangeEvent>;
    private readonly _onDidChangeClientId;
    readonly onDidChangeClientId: Event<void>;
    private readonly _tokenStore;
    protected readonly _createFlows: Array<{
        label: string;
        handler: (scopes: string[], progress: vscode.Progress<{
            message: string;
        }>, token: vscode.CancellationToken) => Promise<IAuthorizationTokenResponse>;
    }>;
    protected readonly _logger: ILogger;
    private readonly _disposable;
    constructor(_extHostWindow: IExtHostWindow, _extHostUrls: IExtHostUrlsService, _initData: IExtHostInitDataService, _extHostProgress: IExtHostProgress, loggerService: ILoggerService, _proxy: MainThreadAuthenticationShape, authorizationServer: URI, _serverMetadata: IAuthorizationServerMetadata, _resourceMetadata: IAuthorizationProtectedResourceMetadata | undefined, _clientId: string, _clientSecret: string | undefined, onDidDynamicAuthProviderTokensChange: Emitter<{
        authProviderId: string;
        clientId: string;
        tokens: IAuthorizationToken[];
    }>, initialTokens: IAuthorizationToken[]);
    get clientId(): string;
    get clientSecret(): string | undefined;
    getSessions(scopes: readonly string[] | undefined, _options: vscode.AuthenticationProviderSessionOptions): Promise<vscode.AuthenticationSession[]>;
    createSession(scopes: string[], _options: vscode.AuthenticationProviderSessionOptions): Promise<vscode.AuthenticationSession>;
    removeSession(sessionId: string): Promise<void>;
    dispose(): void;
    private _createWithUrlHandler;
    protected generateRandomString(length: number): string;
    protected generateCodeChallenge(codeVerifier: string): Promise<string>;
    private waitForAuthorizationCode;
    protected exchangeCodeForToken(code: string, codeVerifier: string, redirectUri: string): Promise<IAuthorizationTokenResponse>;
    protected exchangeRefreshTokenForToken(refreshToken: string): Promise<IAuthorizationToken>;
    protected _generateNewClientId(): Promise<void>;
}
type IAuthorizationToken = IAuthorizationTokenResponse & {
    /**
     * The time when the token was created, in milliseconds since the epoch.
     */
    created_at: number;
};
export {};
