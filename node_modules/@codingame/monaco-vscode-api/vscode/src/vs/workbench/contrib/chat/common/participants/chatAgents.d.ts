import { CancellationToken } from "../../../../../base/common/cancellation.js";
import { Event } from "../../../../../base/common/event.js";
import { IMarkdownString } from "../../../../../base/common/htmlContent.js";
import { Disposable, IDisposable } from "../../../../../base/common/lifecycle.js";
import { Revived } from "../../../../../base/common/marshalling.js";
import { ThemeIcon } from "../../../../../base/common/themables.js";
import { URI } from "../../../../../base/common/uri.js";
import { Command } from "../../../../../editor/common/languages.js";
import { IConfigurationService } from "../../../../../platform/configuration/common/configuration.service.js";
import { IContextKeyService } from "../../../../../platform/contextkey/common/contextkey.service.js";
import { ExtensionIdentifier } from "../../../../../platform/extensions/common/extensions.js";
import { ILogService } from "../../../../../platform/log/common/log.service.js";
import { IProductService } from "../../../../../platform/product/common/productService.service.js";
import { IRequestService } from "../../../../../platform/request/common/request.service.js";
import { IStorageService } from "../../../../../platform/storage/common/storage.service.js";
import { IChatAgentEditedFileEvent, IChatProgressHistoryResponseContent, IChatRequestModeInstructions, IChatRequestVariableData, ISerializableChatAgentData } from "../model/chatModel.js";
import { IRawChatCommandContribution } from "./chatParticipantContribTypes.js";
import { IChatFollowup, IChatLocationData, IChatProgress, IChatResponseErrorDetails, IChatTaskDto } from "../chatService/chatService.js";
import { ChatAgentLocation, ChatModeKind } from "../constants.js";
import { IChatAgentService, type IChatAgentNameService } from "./chatAgents.service.js";
export interface IChatAgentHistoryEntry {
    request: IChatAgentRequest;
    response: ReadonlyArray<IChatProgressHistoryResponseContent | IChatTaskDto>;
    result: IChatAgentResult;
}
export interface IChatAgentAttachmentCapabilities {
    supportsFileAttachments?: boolean;
    supportsToolAttachments?: boolean;
    supportsMCPAttachments?: boolean;
    supportsImageAttachments?: boolean;
    supportsSearchResultAttachments?: boolean;
    supportsInstructionAttachments?: boolean;
    supportsSourceControlAttachments?: boolean;
    supportsProblemAttachments?: boolean;
    supportsSymbolAttachments?: boolean;
    supportsTerminalAttachments?: boolean;
}
export interface IChatAgentData {
    id: string;
    name: string;
    fullName?: string;
    description?: string;
    /** This is string, not ContextKeyExpression, because dealing with serializing/deserializing is hard and need a better pattern for this */
    when?: string;
    extensionId: ExtensionIdentifier;
    extensionVersion: string | undefined;
    extensionPublisherId: string;
    /** This is the extension publisher id, or, in the case of a dynamically registered participant (remote agent), whatever publisher name we have for it */
    publisherDisplayName?: string;
    extensionDisplayName: string;
    /** The agent invoked when no agent is specified */
    isDefault?: boolean;
    /** This agent is not contributed in package.json, but is registered dynamically */
    isDynamic?: boolean;
    /** This agent is contributed from core and not from an extension */
    isCore?: boolean;
    canAccessPreviousChatHistory?: boolean;
    metadata: IChatAgentMetadata;
    slashCommands: IChatAgentCommand[];
    locations: ChatAgentLocation[];
    /** This is only relevant for isDefault agents. Others should have all modes available. */
    modes: ChatModeKind[];
    disambiguation: {
        category: string;
        description: string;
        examples: string[];
    }[];
    capabilities?: IChatAgentAttachmentCapabilities;
}
export interface IChatWelcomeMessageContent {
    icon: ThemeIcon;
    title: string;
    message: IMarkdownString;
}
export interface IChatAgentImplementation {
    invoke(request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult>;
    setRequestTools?(requestId: string, tools: UserSelectedTools): void;
    provideFollowups?(request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]>;
    provideChatTitle?: (history: IChatAgentHistoryEntry[], token: CancellationToken) => Promise<string | undefined>;
    provideChatSummary?: (history: IChatAgentHistoryEntry[], token: CancellationToken) => Promise<string | undefined>;
}
export interface IChatParticipantDetectionResult {
    participant: string;
    command?: string;
}
export interface IChatParticipantMetadata {
    participant: string;
    command?: string;
    disambiguation: {
        category: string;
        description: string;
        examples: string[];
    }[];
}
export interface IChatParticipantDetectionProvider {
    provideParticipantDetection(request: IChatAgentRequest, history: IChatAgentHistoryEntry[], options: {
        location: ChatAgentLocation;
        participants: IChatParticipantMetadata[];
    }, token: CancellationToken): Promise<IChatParticipantDetectionResult | null | undefined>;
}
export type IChatAgent = IChatAgentData & IChatAgentImplementation;
export interface IChatAgentCommand extends IRawChatCommandContribution {
    followupPlaceholder?: string;
}
export interface IChatAgentMetadata {
    helpTextPrefix?: string | IMarkdownString;
    helpTextPostfix?: string | IMarkdownString;
    icon?: URI;
    iconDark?: URI;
    themeIcon?: ThemeIcon;
    sampleRequest?: string;
    supportIssueReporting?: boolean;
    followupPlaceholder?: string;
    isSticky?: boolean;
    additionalWelcomeMessage?: string | IMarkdownString;
}
export type UserSelectedTools = Record<string, boolean>;
export interface IChatAgentRequest {
    sessionResource: URI;
    requestId: string;
    agentId: string;
    command?: string;
    message: string;
    attempt?: number;
    enableCommandDetection?: boolean;
    isParticipantDetected?: boolean;
    variables: IChatRequestVariableData;
    location: ChatAgentLocation;
    locationData?: Revived<IChatLocationData>;
    acceptedConfirmationData?: unknown[];
    rejectedConfirmationData?: unknown[];
    userSelectedModelId?: string;
    userSelectedTools?: UserSelectedTools;
    modeInstructions?: IChatRequestModeInstructions;
    editedFileEvents?: IChatAgentEditedFileEvent[];
    isSubagent?: boolean;
}
export interface IChatQuestion {
    readonly prompt: string;
    readonly participant?: string;
    readonly command?: string;
}
export interface IChatAgentResultTimings {
    firstProgress?: number;
    totalElapsed: number;
}
export interface IChatAgentResult {
    errorDetails?: IChatResponseErrorDetails;
    timings?: IChatAgentResultTimings;
    /** Extra properties that the agent can use to identify a result */
    readonly metadata?: {
        readonly [key: string]: unknown;
    };
    readonly details?: string;
    nextQuestion?: IChatQuestion;
}
export interface IChatAgentCompletionItem {
    id: string;
    name?: string;
    fullName?: string;
    icon?: ThemeIcon;
    value: unknown;
    command?: Command;
}
export declare class ChatAgentService extends Disposable implements IChatAgentService {
    private readonly contextKeyService;
    private readonly configurationService;
    static readonly AGENT_LEADER = "@";
    _serviceBrand: undefined;
    private _agents;
    private readonly _onDidChangeAgents;
    readonly onDidChangeAgents: Event<IChatAgent | undefined>;
    private readonly _agentsContextKeys;
    private readonly _hasDefaultAgent;
    private readonly _extensionAgentRegistered;
    private readonly _defaultAgentRegistered;
    private _hasToolsAgent;
    private _chatParticipantDetectionProviders;
    constructor(contextKeyService: IContextKeyService, configurationService: IConfigurationService);
    registerAgent(id: string, data: IChatAgentData): IDisposable;
    private _updateAgentsContextKeys;
    private _updateContextKeys;
    registerAgentImplementation(id: string, agentImpl: IChatAgentImplementation): IDisposable;
    registerDynamicAgent(data: IChatAgentData, agentImpl: IChatAgentImplementation): IDisposable;
    private _agentCompletionProviders;
    registerAgentCompletionProvider(id: string, provider: (query: string, token: CancellationToken) => Promise<IChatAgentCompletionItem[]>): {
        dispose: () => void;
    };
    getAgentCompletionItems(id: string, query: string, token: CancellationToken): Promise<IChatAgentCompletionItem[]>;
    updateAgent(id: string, updateMetadata: IChatAgentMetadata): void;
    getDefaultAgent(location: ChatAgentLocation, mode?: ChatModeKind): IChatAgent | undefined;
    get hasToolsAgent(): boolean;
    getContributedDefaultAgent(location: ChatAgentLocation): IChatAgentData | undefined;
    private _preferExtensionAgent;
    getAgent(id: string, includeDisabled?: boolean): IChatAgentData | undefined;
    private _agentIsEnabled;
    getAgentByFullyQualifiedId(id: string): IChatAgentData | undefined;
    /**
     * Returns all agent datas that exist- static registered and dynamic ones.
     */
    getAgents(): IChatAgentData[];
    getActivatedAgents(): IChatAgent[];
    getAgentsByName(name: string): IChatAgentData[];
    private _preferExtensionAgents;
    agentHasDupeName(id: string): boolean;
    invokeAgent(id: string, request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult>;
    setRequestTools(id: string, requestId: string, tools: UserSelectedTools): void;
    getFollowups(id: string, request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]>;
    getChatTitle(id: string, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<string | undefined>;
    getChatSummary(id: string, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<string | undefined>;
    registerChatParticipantDetectionProvider(handle: number, provider: IChatParticipantDetectionProvider): IDisposable;
    hasChatParticipantDetectionProviders(): boolean;
    detectAgentOrCommand(request: IChatAgentRequest, history: IChatAgentHistoryEntry[], options: {
        location: ChatAgentLocation;
    }, token: CancellationToken): Promise<{
        agent: IChatAgentData;
        command?: IChatAgentCommand;
    } | undefined>;
}
export declare class MergedChatAgent implements IChatAgent {
    private readonly data;
    private readonly impl;
    constructor(data: IChatAgentData, impl: IChatAgentImplementation);
    when?: string | undefined;
    publisherDisplayName?: string | undefined;
    isDynamic?: boolean | undefined;
    get id(): string;
    get name(): string;
    get fullName(): string;
    get description(): string;
    get extensionId(): ExtensionIdentifier;
    get extensionVersion(): string | undefined;
    get extensionPublisherId(): string;
    get extensionPublisherDisplayName(): string | undefined;
    get extensionDisplayName(): string;
    get isDefault(): boolean | undefined;
    get isCore(): boolean | undefined;
    get metadata(): IChatAgentMetadata;
    get slashCommands(): IChatAgentCommand[];
    get locations(): ChatAgentLocation[];
    get modes(): ChatModeKind[];
    get disambiguation(): {
        category: string;
        description: string;
        examples: string[];
    }[];
    invoke(request: IChatAgentRequest, progress: (parts: IChatProgress[]) => void, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatAgentResult>;
    setRequestTools(requestId: string, tools: UserSelectedTools): void;
    provideFollowups(request: IChatAgentRequest, result: IChatAgentResult, history: IChatAgentHistoryEntry[], token: CancellationToken): Promise<IChatFollowup[]>;
    toJSON(): IChatAgentData;
}
export declare class ChatAgentNameService implements IChatAgentNameService {
    private readonly requestService;
    private readonly logService;
    private readonly storageService;
    private static readonly StorageKey;
    _serviceBrand: undefined;
    private readonly url;
    private registry;
    private disposed;
    constructor(productService: IProductService, requestService: IRequestService, logService: ILogService, storageService: IStorageService);
    private refresh;
    private update;
    /**
     * Returns true if the agent is allowed to use this name
     */
    getAgentNameRestriction(chatAgentData: IChatAgentData): boolean;
    private checkAgentNameRestriction;
    dispose(): void;
}
export declare function getFullyQualifiedId(chatAgentData: IChatAgentData): string;
/**
 * There was a period where serialized chat agent data used 'id' instead of 'name'.
 * Don't copy this pattern, serialized data going forward should be versioned with strict interfaces.
 */
interface IOldSerializedChatAgentData extends Omit<ISerializableChatAgentData, "name"> {
    id: string;
    extensionPublisher?: string;
}
export declare function reviveSerializedAgent(raw: ISerializableChatAgentData | IOldSerializedChatAgentData): IChatAgentData;
export {};
