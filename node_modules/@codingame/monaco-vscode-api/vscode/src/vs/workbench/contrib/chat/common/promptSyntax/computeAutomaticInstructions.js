
import { __decorate, __param } from '../../../../../../../../external/tslib/tslib.es6.js';
import { splitGlobAware, match } from '../../../../../base/common/glob.js';
import { ResourceMap, ResourceSet } from '../../../../../base/common/map.js';
import { Schemas } from '../../../../../base/common/network.js';
import { dirname, basename } from '../../../../../base/common/resources.js';
import { localize } from '../../../../../nls.js';
import { IConfigurationService } from '../../../../../platform/configuration/common/configuration.service.js';
import { IFileService } from '../../../../../platform/files/common/files.service.js';
import { ILabelService } from '../../../../../platform/label/common/label.service.js';
import { ILogService } from '../../../../../platform/log/common/log.service.js';
import { ITelemetryService } from '../../../../../platform/telemetry/common/telemetry.service.js';
import { IWorkspaceContextService } from '../../../../../platform/workspace/common/workspace.service.js';
import { toPromptFileVariableEntry, PromptFileVariableKind, isPromptFileVariableEntry, IChatRequestVariableEntry, ChatRequestVariableSet, toToolVariableEntry, toPromptTextVariableEntry } from '../attachments/chatVariableEntries.js';
import { VSCodeToolReference } from '../tools/languageModelToolsService.js';
import { ILanguageModelToolsService } from '../tools/languageModelToolsService.service.js';
import { PromptsConfig } from './config/config.js';
import { isPromptOrInstructionsFile } from './config/promptFileLocations.js';
import { PromptsType } from './promptTypes.js';
import { IPromptsService } from './service/promptsService.service.js';
import { OffsetRange } from '../../../../../editor/common/core/ranges/offsetRange.js';
import { ChatConfiguration } from '../constants.js';

function newInstructionsCollectionEvent() {
    return { applyingInstructionsCount: 0, referencedInstructionsCount: 0, agentInstructionsCount: 0, listedInstructionsCount: 0, totalInstructionsCount: 0 };
}
let ComputeAutomaticInstructions = class ComputeAutomaticInstructions {
    constructor(_enabledTools, _promptsService, _logService, _labelService, _configurationService, _workspaceService, _fileService, _telemetryService, _languageModelToolsService) {
        this._enabledTools = _enabledTools;
        this._promptsService = _promptsService;
        this._logService = _logService;
        this._labelService = _labelService;
        this._configurationService = _configurationService;
        this._workspaceService = _workspaceService;
        this._fileService = _fileService;
        this._telemetryService = _telemetryService;
        this._languageModelToolsService = _languageModelToolsService;
        this._parseResults = ( new ResourceMap());
    }
    async _parseInstructionsFile(uri, token) {
        if (( this._parseResults.has(uri))) {
            return this._parseResults.get(uri);
        }
        try {
            const result = await this._promptsService.parseNew(uri, token);
            this._parseResults.set(uri, result);
            return result;
        }
        catch (error) {
            this._logService.error(`[InstructionsContextComputer] Failed to parse instruction file: ${uri}`, error);
            return undefined;
        }
    }
    async collect(variables, token) {
        const instructionFiles = await this._promptsService.listPromptFiles(PromptsType.instructions, token);
        this._logService.trace(`[InstructionsContextComputer] ${instructionFiles.length} instruction files available.`);
        const telemetryEvent = newInstructionsCollectionEvent();
        const context = this._getContext(variables);
        await this.addApplyingInstructions(instructionFiles, context, variables, telemetryEvent, token);
        await this._addReferencedInstructions(variables, telemetryEvent, token);
        await this._addAgentInstructions(variables, telemetryEvent, token);
        const instructionsListVariable = await this._getInstructionsWithPatternsList(instructionFiles, variables, token);
        if (instructionsListVariable) {
            variables.add(instructionsListVariable);
            telemetryEvent.listedInstructionsCount++;
        }
        this.sendTelemetry(telemetryEvent);
    }
    sendTelemetry(telemetryEvent) {
        telemetryEvent.totalInstructionsCount = telemetryEvent.agentInstructionsCount + telemetryEvent.referencedInstructionsCount + telemetryEvent.applyingInstructionsCount + telemetryEvent.listedInstructionsCount;
        this._telemetryService.publicLog2('instructionsCollected', telemetryEvent);
    }
    async addApplyingInstructions(instructionFiles, context, variables, telemetryEvent, token) {
        for (const { uri } of instructionFiles) {
            const parsedFile = await this._parseInstructionsFile(uri, token);
            if (!parsedFile) {
                this._logService.trace(`[InstructionsContextComputer] Unable to read: ${uri}`);
                continue;
            }
            const applyTo = parsedFile.header?.applyTo;
            if (!applyTo) {
                this._logService.trace(`[InstructionsContextComputer] No 'applyTo' found: ${uri}`);
                continue;
            }
            if (( context.instructions.has(uri))) {
                this._logService.trace(`[InstructionsContextComputer] Skipping already processed instruction file: ${uri}`);
                continue;
            }
            const match = this._matches(context.files, applyTo);
            if (match) {
                this._logService.trace(`[InstructionsContextComputer] Match for ${uri} with ${match.pattern}${match.file ? ` for file ${match.file}` : ''}`);
                const reason = !match.file ?
                    ( localize(5977, 'Automatically attached as pattern is **')) :
                    ( localize(
                    5978,
                    'Automatically attached as pattern {0} matches {1}',
                    applyTo,
                    this._labelService.getUriLabel(match.file, { relative: true })
                ));
                variables.add(toPromptFileVariableEntry(uri, PromptFileVariableKind.Instruction, reason, true));
                telemetryEvent.applyingInstructionsCount++;
            }
            else {
                this._logService.trace(`[InstructionsContextComputer] No match for ${uri} with ${applyTo}`);
            }
        }
    }
    _getContext(attachedContext) {
        const files = ( new ResourceSet());
        const instructions = ( new ResourceSet());
        for (const variable of attachedContext.asArray()) {
            if (isPromptFileVariableEntry(variable)) {
                instructions.add(variable.value);
            }
            else {
                const uri = IChatRequestVariableEntry.toUri(variable);
                if (uri) {
                    files.add(uri);
                }
            }
        }
        return { files, instructions };
    }
    async _addAgentInstructions(variables, telemetryEvent, token) {
        const useCopilotInstructionsFiles = this._configurationService.getValue(PromptsConfig.USE_COPILOT_INSTRUCTION_FILES);
        const useAgentMd = this._configurationService.getValue(PromptsConfig.USE_AGENT_MD);
        if (!useCopilotInstructionsFiles && !useAgentMd) {
            this._logService.trace(`[InstructionsContextComputer] No agent instructions files added (settings disabled).`);
            return;
        }
        const entries = ( new ChatRequestVariableSet());
        if (useCopilotInstructionsFiles) {
            const files = await this._promptsService.listCopilotInstructionsMDs(token);
            for (const file of files) {
                entries.add(toPromptFileVariableEntry(file, PromptFileVariableKind.Instruction, ( localize(
                    5979,
                    'Automatically attached as setting {0} is enabled',
                    PromptsConfig.USE_COPILOT_INSTRUCTION_FILES
                )), true));
                telemetryEvent.agentInstructionsCount++;
                this._logService.trace(`[InstructionsContextComputer] copilot-instruction.md files added: ${( file.toString())}`);
            }
            await this._addReferencedInstructions(entries, telemetryEvent, token);
        }
        if (useAgentMd) {
            const files = await this._promptsService.listAgentMDs(token, false);
            for (const file of files) {
                entries.add(toPromptFileVariableEntry(file, PromptFileVariableKind.Instruction, ( localize(
                    5980,
                    'Automatically attached as setting {0} is enabled',
                    PromptsConfig.USE_AGENT_MD
                )), true));
                telemetryEvent.agentInstructionsCount++;
                this._logService.trace(`[InstructionsContextComputer] AGENTS.md files added: ${( file.toString())}`);
            }
        }
        for (const entry of entries.asArray()) {
            variables.add(entry);
        }
    }
    _matches(files, applyToPattern) {
        const patterns = splitGlobAware(applyToPattern, ',');
        const patterMatches = (pattern) => {
            pattern = pattern.trim();
            if (pattern.length === 0) {
                return undefined;
            }
            if (pattern === '**' || pattern === '**/*' || pattern === '*') {
                return { pattern };
            }
            if (!pattern.startsWith('/') && !pattern.startsWith('**/')) {
                pattern = '**/' + pattern;
            }
            for (const file of files) {
                if (match(pattern, file.path, { ignoreCase: true })) {
                    return { pattern, file };
                }
            }
            return undefined;
        };
        for (const pattern of patterns) {
            const matchResult = patterMatches(pattern);
            if (matchResult) {
                return matchResult;
            }
        }
        return undefined;
    }
    _getTool(referenceName) {
        if (!this._enabledTools) {
            return undefined;
        }
        const tool = this._languageModelToolsService.getToolByName(referenceName);
        if (tool && this._enabledTools.get(tool)) {
            return { tool, variable: `#tool:${this._languageModelToolsService.getFullReferenceName(tool)}` };
        }
        return undefined;
    }
    async _getInstructionsWithPatternsList(instructionFiles, _existingVariables, token) {
        const readTool = this._getTool('readFile');
        const runSubagentTool = this._getTool(VSCodeToolReference.runSubagent);
        const entries = [];
        if (readTool) {
            const searchNestedAgentMd = this._configurationService.getValue(PromptsConfig.USE_NESTED_AGENT_MD);
            const agentsMdPromise = searchNestedAgentMd ? this._promptsService.findAgentMDsInWorkspace(token) : Promise.resolve([]);
            entries.push('<instructions>');
            entries.push('Here is a list of instruction files that contain rules for modifying or creating new code.');
            entries.push('These files are important for ensuring that the code is modified or created correctly.');
            entries.push('Please make sure to follow the rules specified in these files when working with the codebase.');
            entries.push(`If the file is not already available as attachment, use the ${readTool.variable} tool to acquire it.`);
            entries.push('Make sure to acquire the instructions before making any changes to the code.');
            let hasContent = false;
            for (const { uri } of instructionFiles) {
                const parsedFile = await this._parseInstructionsFile(uri, token);
                if (parsedFile) {
                    entries.push('<instruction>');
                    if (parsedFile.header) {
                        const { description, applyTo } = parsedFile.header;
                        if (description) {
                            entries.push(`<description>${description}</description>`);
                        }
                        entries.push(`<file>${getFilePath(uri)}</file>`);
                        if (applyTo) {
                            entries.push(`<applyTo>${applyTo}</applyTo>`);
                        }
                    }
                    else {
                        entries.push(`<file>${getFilePath(uri)}</file>`);
                    }
                    entries.push('</instruction>');
                    hasContent = true;
                }
            }
            const agentsMdFiles = await agentsMdPromise;
            for (const uri of agentsMdFiles) {
                if (uri) {
                    const folderName = this._labelService.getUriLabel(dirname(uri), { relative: true });
                    const description = folderName.trim().length === 0 ? ( localize(5981, 'Instructions for the workspace')) : ( localize(5982, 'Instructions for folder \'{0}\'', folderName));
                    entries.push('<instruction>');
                    entries.push(`<description>${description}</description>`);
                    entries.push(`<file>${getFilePath(uri)}</file>`);
                    entries.push('</instruction>');
                    hasContent = true;
                }
            }
            if (!hasContent) {
                entries.length = 0;
            }
            else {
                entries.push('</instructions>', '', '');
            }
            const agentSkills = await this._promptsService.findAgentSkills(token);
            if (agentSkills && agentSkills.length > 0) {
                entries.push('<skills>');
                entries.push('Here is a list of skills that contain domain specific knowledge on a variety of topics.');
                entries.push('Each skill comes with a description of the topic and a file path that contains the detailed instructions.');
                entries.push(`When a user asks you to perform a task that falls within the domain of a skill, use the ${readTool.variable} tool to acquire the full instructions from the file URI.`);
                for (const skill of agentSkills) {
                    entries.push('<skill>');
                    entries.push(`<name>${skill.name}</name>`);
                    if (skill.description) {
                        entries.push(`<description>${skill.description}</description>`);
                    }
                    entries.push(`<file>${getFilePath(skill.uri)}</file>`);
                    entries.push('</skill>');
                }
                entries.push('</skills>', '', '');
            }
        }
        if (runSubagentTool) {
            const subagentToolCustomAgents = this._configurationService.getValue(ChatConfiguration.SubagentToolCustomAgents);
            if (subagentToolCustomAgents) {
                const agents = await this._promptsService.getCustomAgents(token);
                if (agents.length > 0) {
                    entries.push('<agents>');
                    entries.push('Here is a list of agents that can be used when running a subagent.');
                    entries.push('Each agent has optionally a description with the agent\'s purpose and expertise. When asked to run a subagent, choose the most appropriate agent from this list.');
                    entries.push(`Use the ${runSubagentTool.variable} tool with the agent name to run the subagent.`);
                    for (const agent of agents) {
                        if (agent.infer === false) {
                            continue;
                        }
                        entries.push('<agent>');
                        entries.push(`<name>${agent.name}</name>`);
                        if (agent.description) {
                            entries.push(`<description>${agent.description}</description>`);
                        }
                        if (agent.argumentHint) {
                            entries.push(`<argumentHint>${agent.argumentHint}</argumentHint>`);
                        }
                        entries.push('</agent>');
                    }
                    entries.push('</agents>', '', '');
                }
            }
        }
        if (entries.length === 0) {
            return undefined;
        }
        const content = entries.join('\n');
        const toolReferences = [];
        const collectToolReference = (tool) => {
            if (tool) {
                let offset = content.indexOf(tool.variable);
                while (offset >= 0) {
                    toolReferences.push(toToolVariableEntry(tool.tool, ( new OffsetRange(offset, offset + tool.variable.length))));
                    offset = content.indexOf(tool.variable, offset + 1);
                }
            }
        };
        collectToolReference(readTool);
        collectToolReference(runSubagentTool);
        return toPromptTextVariableEntry(content, true, toolReferences);
    }
    async _addReferencedInstructions(attachedContext, telemetryEvent, token) {
        const seen = ( new ResourceSet());
        const todo = [];
        for (const variable of attachedContext.asArray()) {
            if (isPromptFileVariableEntry(variable)) {
                if (!( seen.has(variable.value))) {
                    todo.push(variable.value);
                    seen.add(variable.value);
                }
            }
        }
        let next = todo.pop();
        while (next) {
            const result = await this._parseInstructionsFile(next, token);
            if (result && result.body) {
                const refsToCheck = [];
                for (const ref of result.body.fileReferences) {
                    const url = result.body.resolveFilePath(ref.content);
                    if (url && !( seen.has(url)) && (isPromptOrInstructionsFile(url) || this._workspaceService.getWorkspaceFolder(url) !== undefined)) {
                        refsToCheck.push({ resource: url });
                        seen.add(url);
                    }
                }
                if (refsToCheck.length > 0) {
                    const stats = await this._fileService.resolveAll(refsToCheck);
                    for (let i = 0; i < stats.length; i++) {
                        const stat = stats[i];
                        const uri = refsToCheck[i].resource;
                        if (stat.success && stat.stat?.isFile) {
                            if (isPromptOrInstructionsFile(uri)) {
                                todo.push(uri);
                            }
                            const reason = ( localize(5983, 'Referenced by {0}', basename(next)));
                            attachedContext.add(toPromptFileVariableEntry(uri, PromptFileVariableKind.InstructionReference, reason, true));
                            telemetryEvent.referencedInstructionsCount++;
                            this._logService.trace(`[InstructionsContextComputer] ${( uri.toString())} added, referenced by ${( next.toString())}`);
                        }
                    }
                }
            }
            next = todo.pop();
        }
    }
};
ComputeAutomaticInstructions = ( __decorate([
    ( __param(1, IPromptsService)),
    ( __param(2, ILogService)),
    ( __param(3, ILabelService)),
    ( __param(4, IConfigurationService)),
    ( __param(5, IWorkspaceContextService)),
    ( __param(6, IFileService)),
    ( __param(7, ITelemetryService)),
    ( __param(8, ILanguageModelToolsService))
], ComputeAutomaticInstructions));
function getFilePath(uri) {
    if (uri.scheme === Schemas.file || uri.scheme === Schemas.vscodeRemote) {
        return uri.fsPath;
    }
    return ( uri.toString());
}

export { ComputeAutomaticInstructions, newInstructionsCollectionEvent };
