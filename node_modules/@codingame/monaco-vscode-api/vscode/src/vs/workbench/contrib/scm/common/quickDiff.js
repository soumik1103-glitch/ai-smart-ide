
import { localize } from '../../../../nls.js';
import { Color } from '../../../../base/common/color.js';
import { registerColor, lighten, darken, transparent, opaque } from '../../../../platform/theme/common/colorUtils.js';
import '../../../../platform/theme/common/colors/baseColors.js';
import '../../../../platform/theme/common/colors/chartsColors.js';
import { editorErrorForeground, editorForeground, editorBackground } from '../../../../platform/theme/common/colors/editorColors.js';
import '../../../../platform/theme/common/colors/inputColors.js';
import { listInactiveSelectionBackground } from '../../../../platform/theme/common/colors/listColors.js';
import '../../../../platform/theme/common/colors/menuColors.js';
import '../../../../platform/theme/common/colors/minimapColors.js';
import '../../../../platform/theme/common/colors/miscColors.js';
import '../../../../platform/theme/common/colors/quickpickColors.js';
import '../../../../platform/theme/common/colors/searchColors.js';

const editorGutterModifiedBackground = registerColor('editorGutter.modifiedBackground', {
    dark: '#1B81A8', light: '#2090D3', hcDark: '#1B81A8', hcLight: '#2090D3'
}, ( localize(10637, "Editor gutter background color for lines that are modified.")));
registerColor('editorGutter.modifiedSecondaryBackground', { dark: ( darken(editorGutterModifiedBackground, 0.5)), light: ( lighten(editorGutterModifiedBackground, 0.7)), hcDark: '#1B81A8', hcLight: '#2090D3' }, ( localize(
    10638,
    "Editor gutter secondary background color for lines that are modified."
)));
const editorGutterAddedBackground = registerColor('editorGutter.addedBackground', {
    dark: '#487E02', light: '#48985D', hcDark: '#487E02', hcLight: '#48985D'
}, ( localize(10639, "Editor gutter background color for lines that are added.")));
registerColor('editorGutter.addedSecondaryBackground', { dark: ( darken(editorGutterAddedBackground, 0.5)), light: ( lighten(editorGutterAddedBackground, 0.7)), hcDark: '#487E02', hcLight: '#48985D' }, ( localize(
    10640,
    "Editor gutter secondary background color for lines that are added."
)));
const editorGutterDeletedBackground = registerColor('editorGutter.deletedBackground', editorErrorForeground, ( localize(10641, "Editor gutter background color for lines that are deleted.")));
registerColor('editorGutter.deletedSecondaryBackground', { dark: ( darken(editorGutterDeletedBackground, 0.4)), light: ( lighten(editorGutterDeletedBackground, 0.3)), hcDark: '#F48771', hcLight: '#B5200D' }, ( localize(
    10642,
    "Editor gutter secondary background color for lines that are deleted."
)));
const minimapGutterModifiedBackground = registerColor('minimapGutter.modifiedBackground', editorGutterModifiedBackground, ( localize(10643, "Minimap gutter background color for lines that are modified.")));
const minimapGutterAddedBackground = registerColor('minimapGutter.addedBackground', editorGutterAddedBackground, ( localize(10644, "Minimap gutter background color for lines that are added.")));
const minimapGutterDeletedBackground = registerColor('minimapGutter.deletedBackground', editorGutterDeletedBackground, ( localize(10645, "Minimap gutter background color for lines that are deleted.")));
const overviewRulerModifiedForeground = registerColor('editorOverviewRuler.modifiedForeground', ( transparent(editorGutterModifiedBackground, 0.6)), ( localize(10646, 'Overview ruler marker color for modified content.')));
const overviewRulerAddedForeground = registerColor('editorOverviewRuler.addedForeground', ( transparent(editorGutterAddedBackground, 0.6)), ( localize(10647, 'Overview ruler marker color for added content.')));
const overviewRulerDeletedForeground = registerColor('editorOverviewRuler.deletedForeground', ( transparent(editorGutterDeletedBackground, 0.6)), ( localize(10648, 'Overview ruler marker color for deleted content.')));
registerColor('editorGutter.itemGlyphForeground', { dark: editorForeground, light: editorForeground, hcDark: Color.black, hcLight: Color.white }, ( localize(10649, 'Editor gutter decoration color for gutter item glyphs.')));
registerColor('editorGutter.itemBackground', { dark: opaque(listInactiveSelectionBackground, editorBackground), light: ( darken(opaque(listInactiveSelectionBackground, editorBackground), .05)), hcDark: Color.white, hcLight: Color.black }, ( localize(
    10650,
    'Editor gutter decoration color for gutter item background. This color should be opaque.'
)));
var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["Modify"] = 0] = "Modify";
    ChangeType[ChangeType["Add"] = 1] = "Add";
    ChangeType[ChangeType["Delete"] = 2] = "Delete";
})(ChangeType || (ChangeType = {}));
function getChangeType(change) {
    if (change.originalEndLineNumber === 0) {
        return ChangeType.Add;
    }
    else if (change.modifiedEndLineNumber === 0) {
        return ChangeType.Delete;
    }
    else {
        return ChangeType.Modify;
    }
}
function getChangeTypeColor(theme, changeType) {
    switch (changeType) {
        case ChangeType.Modify: return theme.getColor(editorGutterModifiedBackground);
        case ChangeType.Add: return theme.getColor(editorGutterAddedBackground);
        case ChangeType.Delete: return theme.getColor(editorGutterDeletedBackground);
    }
}
function compareChanges(a, b) {
    let result = a.modifiedStartLineNumber - b.modifiedStartLineNumber;
    if (result !== 0) {
        return result;
    }
    result = a.modifiedEndLineNumber - b.modifiedEndLineNumber;
    if (result !== 0) {
        return result;
    }
    result = a.originalStartLineNumber - b.originalStartLineNumber;
    if (result !== 0) {
        return result;
    }
    return a.originalEndLineNumber - b.originalEndLineNumber;
}
function getChangeHeight(change) {
    const modified = change.modifiedEndLineNumber - change.modifiedStartLineNumber + 1;
    const original = change.originalEndLineNumber - change.originalStartLineNumber + 1;
    if (change.originalEndLineNumber === 0) {
        return modified;
    }
    else if (change.modifiedEndLineNumber === 0) {
        return original;
    }
    else {
        return modified + original;
    }
}
function getModifiedEndLineNumber(change) {
    if (change.modifiedEndLineNumber === 0) {
        return change.modifiedStartLineNumber === 0 ? 1 : change.modifiedStartLineNumber;
    }
    else {
        return change.modifiedEndLineNumber;
    }
}
function lineIntersectsChange(lineNumber, change) {
    if (lineNumber === 1 && change.modifiedStartLineNumber === 0 && change.modifiedEndLineNumber === 0) {
        return true;
    }
    return lineNumber >= change.modifiedStartLineNumber && lineNumber <= (change.modifiedEndLineNumber || change.modifiedStartLineNumber);
}

export { ChangeType, compareChanges, getChangeHeight, getChangeType, getChangeTypeColor, getModifiedEndLineNumber, lineIntersectsChange, minimapGutterAddedBackground, minimapGutterDeletedBackground, minimapGutterModifiedBackground, overviewRulerAddedForeground, overviewRulerDeletedForeground, overviewRulerModifiedForeground };
