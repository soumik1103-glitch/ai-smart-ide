import { Disposable } from "../../../../../base/common/lifecycle.js";
import { URI } from "../../../../../base/common/uri.js";
import { IRange } from "../../../../../editor/common/core/range.js";
import { IActionViewItemService } from "../../../../../platform/actions/browser/actionViewItemService.service.js";
import { Action2, ICommandPaletteOptions, MenuId } from "../../../../../platform/actions/common/actions.js";
import { IDialogService } from "../../../../../platform/dialogs/common/dialogs.service.js";
import { ServicesAccessor } from "../../../../../platform/instantiation/common/instantiation.js";
import { IWorkbenchContribution } from "../../../../common/contributions.js";
import { IChatEntitlementService } from "../../../../services/chat/common/chatEntitlementService.service.js";
import { IChatAgentResult } from "../../common/participants/chatAgents.js";
import { IChatModel } from "../../common/model/chatModel.js";
import { IChatMode } from "../../common/chatModes.js";
import { IChatRequestViewModel, IChatResponseViewModel } from "../../common/model/chatViewModel.js";
import { ChatModeKind } from "../../common/constants.js";
import { ILanguageModelChatSelector } from "../../common/languageModels.js";
export declare const CHAT_CATEGORY: import("../../../../../nls.js").ILocalizedString;
export declare const ACTION_ID_NEW_CHAT = "workbench.action.chat.newChat";
export declare const ACTION_ID_NEW_EDIT_SESSION = "workbench.action.chat.newEditSession";
export declare const ACTION_ID_OPEN_CHAT = "workbench.action.openChat";
export declare const CHAT_OPEN_ACTION_ID = "workbench.action.chat.open";
export declare const CHAT_SETUP_ACTION_ID = "workbench.action.chat.triggerSetup";
export declare const CHAT_SETUP_SUPPORT_ANONYMOUS_ACTION_ID = "workbench.action.chat.triggerSetupSupportAnonymousAction";
export interface IChatViewOpenOptions {
    /**
     * The query for chat.
     */
    query: string;
    /**
     * Whether the query is partial and will await more input from the user.
     */
    isPartialQuery?: boolean;
    /**
     * A list of tools IDs with `canBeReferencedInPrompt` that will be resolved and attached if they exist.
     */
    toolIds?: string[];
    /**
     * Any previous chat requests and responses that should be shown in the chat view.
     */
    previousRequests?: IChatViewOpenRequestEntry[];
    /**
     * Whether a screenshot of the focused window should be taken and attached
     */
    attachScreenshot?: boolean;
    /**
     * A list of file URIs to attach to the chat as context.
     */
    attachFiles?: (URI | {
        uri: URI;
        range: IRange;
    })[];
    /**
     * A list of source control history item changes to attach to the chat as context.
     */
    attachHistoryItemChanges?: {
        uri: URI;
        historyItemId: string;
    }[];
    /**
     * A list of source control history item change ranges to attach to the chat as context.
     */
    attachHistoryItemChangeRanges?: {
        start: {
            uri: URI;
            historyItemId: string;
        };
        end: {
            uri: URI;
            historyItemId: string;
        };
    }[];
    /**
     * The mode ID or name to open the chat in.
     */
    mode?: ChatModeKind | string;
    /**
     * The language model selector to use for the chat.
     * An Error will be thrown if there's no match. If there are multiple
     * matches, the first match will be used.
     *
     * Examples:
     *
     * ```
     * {
     *   id: 'claude-sonnet-4',
     *   vendor: 'copilot'
     * }
     * ```
     *
     * Use `claude-sonnet-4` from any vendor:
     *
     * ```
     * {
     *   id: 'claude-sonnet-4',
     * }
     * ```
     */
    modelSelector?: ILanguageModelChatSelector;
    /**
     * Wait to resolve the command until the chat response reaches a terminal state (complete, error, or pending user confirmation, etc.).
     */
    blockOnResponse?: boolean;
}
export interface IChatViewOpenRequestEntry {
    request: string;
    response: string;
}
export declare const CHAT_CONFIG_MENU_ID: MenuId;
declare abstract class OpenChatGlobalAction extends Action2 {
    private readonly mode?;
    constructor(overrides: Pick<ICommandPaletteOptions, "keybinding" | "title" | "id" | "menu">, mode?: IChatMode | undefined);
    run(accessor: ServicesAccessor, opts?: string | IChatViewOpenOptions): Promise<IChatAgentResult & {
        type?: "confirmation";
    } | undefined>;
    private handleSwitchToMode;
}
export declare function getOpenChatActionIdForMode(mode: IChatMode): string;
export declare abstract class ModeOpenChatGlobalAction extends OpenChatGlobalAction {
    constructor(mode: IChatMode, keybinding?: ICommandPaletteOptions["keybinding"]);
}
export declare function registerChatActions(): void;
export declare function stringifyItem(item: IChatRequestViewModel | IChatResponseViewModel, includeName?: boolean): string;
export declare class CopilotTitleBarMenuRendering extends Disposable implements IWorkbenchContribution {
    static readonly ID = "workbench.contrib.copilotTitleBarMenuRendering";
    constructor(actionViewItemService: IActionViewItemService, chatEntitlementService: IChatEntitlementService);
}
/**
 * Returns whether we can continue clearing/switching chat sessions, false to cancel.
 */
export declare function handleCurrentEditingSession(model: IChatModel, phrase: string | undefined, dialogService: IDialogService): Promise<boolean>;
/**
 * Returns whether we can switch the agent, based on whether the user had to agree to clear the session, false to cancel.
 */
export declare function handleModeSwitch(accessor: ServicesAccessor, fromMode: ChatModeKind, toMode: ChatModeKind, requestCount: number, model: IChatModel | undefined): Promise<false | {
    needToClearSession: boolean;
}>;
export interface IClearEditingSessionConfirmationOptions {
    titleOverride?: string;
    messageOverride?: string;
    isArchiveAction?: boolean;
}
export {};
