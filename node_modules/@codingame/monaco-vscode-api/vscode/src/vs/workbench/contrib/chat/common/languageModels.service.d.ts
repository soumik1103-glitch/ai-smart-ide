import { CancellationToken } from "../../../../base/common/cancellation.js";
import { Event } from "../../../../base/common/event.js";
import { IDisposable } from "../../../../base/common/lifecycle.js";
import { ExtensionIdentifier } from "../../../../platform/extensions/common/extensions.js";
import { IUserFriendlyLanguageModel, ILanguageModelChatMetadata, ILanguageModelChatSelector, ILanguageModelChatProvider, IChatMessage, ILanguageModelChatResponse } from "./languageModels.js";
export declare const ILanguageModelsService: import("../../../../platform/instantiation/common/instantiation.js").ServiceIdentifier<ILanguageModelsService>;
export interface ILanguageModelsService {
    readonly _serviceBrand: undefined;
    readonly onDidChangeLanguageModels: Event<string>;
    updateModelPickerPreference(modelIdentifier: string, showInModelPicker: boolean): void;
    getLanguageModelIds(): string[];
    getVendors(): IUserFriendlyLanguageModel[];
    lookupLanguageModel(modelId: string): ILanguageModelChatMetadata | undefined;
    /**
    * Given a selector, returns a list of model identifiers
    * @param selector The selector to lookup for language models. If the selector is empty, all language models are returned.
    * @param allowPromptingUser If true the user may be prompted for things like API keys for us to select the model.
    */
    selectLanguageModels(selector: ILanguageModelChatSelector, allowPromptingUser?: boolean): Promise<string[]>;
    registerLanguageModelProvider(vendor: string, provider: ILanguageModelChatProvider): IDisposable;
    sendChatRequest(modelId: string, from: ExtensionIdentifier, messages: IChatMessage[], options: {
        [name: string]: any;
    }, token: CancellationToken): Promise<ILanguageModelChatResponse>;
    computeTokenLength(modelId: string, message: string | IChatMessage, token: CancellationToken): Promise<number>;
}
