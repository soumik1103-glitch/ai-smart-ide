
import { localize } from '../../../../nls.js';
import { Color } from '../../../../base/common/color.js';
import { ContentWidgetPositionPreference } from '../../../../editor/browser/editorBrowser.js';
import { OverviewRulerLane } from '../../../../editor/common/model.js';
import { ModelDecorationOptions } from '../../../../editor/common/model/textModel.js';
import { registerColor, darken, opaque } from '../../../../platform/theme/common/colorUtils.js';
import '../../../../platform/theme/common/colors/baseColors.js';
import '../../../../platform/theme/common/colors/chartsColors.js';
import { editorBackground, editorForeground } from '../../../../platform/theme/common/colors/editorColors.js';
import '../../../../platform/theme/common/colors/inputColors.js';
import { listInactiveSelectionBackground } from '../../../../platform/theme/common/colors/listColors.js';
import '../../../../platform/theme/common/colors/menuColors.js';
import '../../../../platform/theme/common/colors/minimapColors.js';
import '../../../../platform/theme/common/colors/miscColors.js';
import '../../../../platform/theme/common/colors/quickpickColors.js';
import '../../../../platform/theme/common/colors/searchColors.js';
import { themeColorFromId } from '../../../../platform/theme/common/themeService.js';
import { CommentThreadState } from '../../../../editor/common/languages.js';
import { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';
import { Emitter } from '../../../../base/common/event.js';

const overviewRulerCommentingRangeForeground = registerColor('editorGutter.commentRangeForeground', { dark: opaque(listInactiveSelectionBackground, editorBackground), light: ( darken(opaque(listInactiveSelectionBackground, editorBackground), .05)), hcDark: Color.white, hcLight: Color.black }, ( localize(
    6291,
    'Editor gutter decoration color for commenting ranges. This color should be opaque.'
)));
const overviewRulerCommentForeground = registerColor('editorOverviewRuler.commentForeground', overviewRulerCommentingRangeForeground, ( localize(
    6292,
    'Editor overview ruler decoration color for resolved comments. This color should be opaque.'
)));
const overviewRulerCommentUnresolvedForeground = registerColor('editorOverviewRuler.commentUnresolvedForeground', overviewRulerCommentForeground, ( localize(
    6293,
    'Editor overview ruler decoration color for unresolved comments. This color should be opaque.'
)));
const overviewRulerCommentDraftForeground = registerColor('editorOverviewRuler.commentDraftForeground', overviewRulerCommentUnresolvedForeground, ( localize(
    6294,
    'Editor overview ruler decoration color for comment threads with draft comments. This color should be opaque.'
)));
const editorGutterCommentGlyphForeground = registerColor('editorGutter.commentGlyphForeground', { dark: editorForeground, light: editorForeground, hcDark: Color.black, hcLight: Color.white }, ( localize(6295, 'Editor gutter decoration color for commenting glyphs.')));
registerColor('editorGutter.commentUnresolvedGlyphForeground', editorGutterCommentGlyphForeground, ( localize(
    6296,
    'Editor gutter decoration color for commenting glyphs for unresolved comment threads.'
)));
registerColor('editorGutter.commentDraftGlyphForeground', editorGutterCommentGlyphForeground, ( localize(
    6297,
    'Editor gutter decoration color for commenting glyphs for comment threads with draft comments.'
)));
class CommentGlyphWidget extends Disposable {
    static { this.description = 'comment-glyph-widget'; }
    constructor(editor, lineNumber) {
        super();
        this._threadHasDraft = false;
        this._onDidChangeLineNumber = this._register(( new Emitter()));
        this.onDidChangeLineNumber = this._onDidChangeLineNumber.event;
        this._commentsOptions = this.createDecorationOptions();
        this._editor = editor;
        this._commentsDecorations = this._editor.createDecorationsCollection();
        this._register(this._commentsDecorations.onDidChange(e => {
            const range = (this._commentsDecorations.length > 0 ? this._commentsDecorations.getRange(0) : null);
            if (range && range.endLineNumber !== this._lineNumber) {
                this._lineNumber = range.endLineNumber;
                this._onDidChangeLineNumber.fire(this._lineNumber);
            }
        }));
        this._register(toDisposable(() => this._commentsDecorations.clear()));
        this.setLineNumber(lineNumber);
    }
    createDecorationOptions() {
        let className;
        if (this._threadHasDraft) {
            className = 'comment-range-glyph comment-thread-draft';
        }
        else {
            const unresolved = this._threadState === CommentThreadState.Unresolved;
            className = `comment-range-glyph comment-thread${unresolved ? '-unresolved' : ''}`;
        }
        const decorationOptions = {
            description: CommentGlyphWidget.description,
            isWholeLine: true,
            overviewRuler: {
                color: themeColorFromId(this._threadHasDraft ? overviewRulerCommentDraftForeground :
                    (this._threadState === CommentThreadState.Unresolved ? overviewRulerCommentUnresolvedForeground : overviewRulerCommentForeground)),
                position: OverviewRulerLane.Center
            },
            collapseOnReplaceEdit: true,
            linesDecorationsClassName: className
        };
        return ModelDecorationOptions.createDynamic(decorationOptions);
    }
    setThreadState(state, hasDraft = false) {
        if (this._threadState !== state || this._threadHasDraft !== hasDraft) {
            this._threadState = state;
            this._threadHasDraft = hasDraft;
            this._commentsOptions = this.createDecorationOptions();
            this._updateDecorations();
        }
    }
    _updateDecorations() {
        const commentsDecorations = [{
                range: {
                    startLineNumber: this._lineNumber, startColumn: 1,
                    endLineNumber: this._lineNumber, endColumn: 1
                },
                options: this._commentsOptions
            }];
        this._commentsDecorations.set(commentsDecorations);
    }
    setLineNumber(lineNumber) {
        this._lineNumber = lineNumber;
        this._updateDecorations();
    }
    getPosition() {
        const range = (this._commentsDecorations.length > 0 ? this._commentsDecorations.getRange(0) : null);
        return {
            position: {
                lineNumber: range ? range.endLineNumber : this._lineNumber,
                column: 1
            },
            preference: [ContentWidgetPositionPreference.EXACT]
        };
    }
}

export { CommentGlyphWidget, overviewRulerCommentingRangeForeground };
