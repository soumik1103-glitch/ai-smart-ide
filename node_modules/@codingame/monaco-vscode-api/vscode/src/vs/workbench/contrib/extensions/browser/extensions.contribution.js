
import { registerCss } from '../../../../../../../css.js';
import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { CancellationToken } from '../../../../base/common/cancellation.js';
import { onUnexpectedError } from '../../../../base/common/errors.js';
import { Event } from '../../../../base/common/event.js';
import { KeyMod as KeyMod$1, KeyCode } from '../../../../base/common/keyCodes.js';
import { mnemonicButtonLabel } from '../../../../base/common/labels.js';
import { isDisposable, Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';
import { Schemas } from '../../../../base/common/network.js';
import { isNative, isWeb } from '../../../../base/common/platform.js';
import { PolicyCategory } from '../../../../base/common/policy.js';
import { URI } from '../../../../base/common/uri.js';
import { CopyAction, CutAction, PasteAction } from '../../../../editor/contrib/clipboard/browser/clipboard.js';
import { localize, localize2 } from '../../../../nls.js';
import { Categories } from '../../../../platform/action/common/actionCommonCategories.js';
import { MenuRegistry, MenuId, registerAction2, Action2 } from '../../../../platform/actions/common/actions.js';
import { IClipboardService } from '../../../../platform/clipboard/common/clipboardService.service.js';
import { CommandsRegistry } from '../../../../platform/commands/common/commands.js';
import { ICommandService } from '../../../../platform/commands/common/commands.service.js';
import { Extensions as Extensions$2, ConfigurationScope } from '../../../../platform/configuration/common/configurationRegistry.js';
import { RawContextKey, ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.service.js';
import { IFileDialogService, IDialogService } from '../../../../platform/dialogs/common/dialogs.service.js';
import { ExtensionGalleryServiceUrlConfigKey, ExtensionGalleryManifestStatus, getExtensionGalleryManifestResourceUri, ExtensionGalleryResourceType } from '../../../../platform/extensionManagement/common/extensionGalleryManifest.js';
import { IExtensionGalleryManifestService } from '../../../../platform/extensionManagement/common/extensionGalleryManifest.service.js';
import { ExtensionRequestsTimeoutConfigKey, VerifyExtensionSignatureConfigKey, EXTENSION_INSTALL_SOURCE_CONTEXT, ExtensionInstallSource, ExtensionsLocalizedLabel, PreferencesLocalizedLabel, FilterType } from '../../../../platform/extensionManagement/common/extensionManagement.js';
import { IExtensionGalleryService, IExtensionManagementService } from '../../../../platform/extensionManagement/common/extensionManagement.service.js';
import { areSameExtensions, getIdAndVersion } from '../../../../platform/extensionManagement/common/extensionManagementUtil.js';
import { ExtensionStorageService } from '../../../../platform/extensionManagement/common/extensionStorage.js';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { EXTENSION_CATEGORIES, ExtensionType } from '../../../../platform/extensions/common/extensions.js';
import { SyncDescriptor } from '../../../../platform/instantiation/common/descriptors.js';
import '../../../../platform/instantiation/common/extensions.js';
import { Extensions as Extensions$3 } from '../../../../platform/jsonschemas/common/jsonContributionRegistry.js';
import '../../../../platform/notification/common/notification.js';
import { INotificationService } from '../../../../platform/notification/common/notification.service.js';
import product from '../../../../platform/product/common/product.js';
import { IProductService } from '../../../../platform/product/common/productService.service.js';
import { ProgressLocation } from '../../../../platform/progress/common/progress.js';
import { Extensions } from '../../../../platform/quickinput/common/quickAccess.js';
import { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.service.js';
import { Registry } from '../../../../platform/registry/common/platform.js';
import { StorageScope, StorageTarget } from '../../../../platform/storage/common/storage.js';
import { IStorageService } from '../../../../platform/storage/common/storage.service.js';
import { IUriIdentityService } from '../../../../platform/uriIdentity/common/uriIdentity.service.js';
import { IUserDataProfilesService } from '../../../../platform/userDataProfile/common/userDataProfile.service.js';
import { EditorPaneDescriptor } from '../../../browser/editor.js';
import { Extensions as Extensions$5 } from '../../../common/configuration.js';
import { WorkbenchStateContext, ResourceContextKey } from '../../../common/contextkeys.js';
import { Extensions as Extensions$4, registerWorkbenchContribution2, WorkbenchPhase } from '../../../common/contributions.js';
import { EditorExtensions } from '../../../common/editor.js';
import { Extensions as Extensions$1, ViewContainerLocation } from '../../../common/views.js';
import { DEFAULT_ACCOUNT_SIGN_IN_COMMAND } from '../../../services/accounts/common/defaultAccount.js';
import { IEditorService } from '../../../services/editor/common/editorService.service.js';
import { EnablementState } from '../../../services/extensionManagement/common/extensionManagement.js';
import { IWorkbenchExtensionManagementService, IExtensionManagementServerService, IWorkbenchExtensionEnablementService } from '../../../services/extensionManagement/common/extensionManagement.service.js';
import { IExtensionIgnoredRecommendationsService } from '../../../services/extensionRecommendations/common/extensionRecommendations.service.js';
import { IWorkspaceExtensionsConfigService } from '../../../services/extensionRecommendations/common/workspaceExtensionsConfig.service.js';
import { IHostService } from '../../../services/host/browser/host.service.js';
import { LifecyclePhase } from '../../../services/lifecycle/common/lifecycle.js';
import { IPreferencesService } from '../../../services/preferences/common/preferences.service.js';
import { CONTEXT_SYNC_ENABLEMENT } from '../../../services/userDataSync/common/userDataSync.js';
import { IViewsService } from '../../../services/views/common/viewsService.service.js';
import { WORKSPACE_TRUST_EXTENSION_SUPPORT } from '../../../services/workspaces/common/workspaceTrust.js';
import { ILanguageModelToolsService } from '../../chat/common/tools/languageModelToolsService.service.js';
import { CONTEXT_KEYBINDINGS_EDITOR } from '../../preferences/common/preferences.js';
import '../../../services/extensionManagement/common/extensionFeatures.js';
import { VIEWLET_ID, AutoRestartConfigurationKey, CONTEXT_HAS_GALLERY, CONTEXT_EXTENSIONS_GALLERY_STATUS, AutoUpdateConfigurationKey, OUTDATED_EXTENSIONS_VIEW_ID, HasOutdatedExtensionsContext, INSTALL_EXTENSION_FROM_VSIX_COMMAND_ID, SELECT_INSTALL_VSIX_EXTENSION_COMMAND_ID, ExtensionRuntimeActionType, extensionsSearchActionsMenu, extensionsFilterSubMenu, LIST_WORKSPACE_UNSUPPORTED_EXTENSIONS_COMMAND_ID, DefaultViewsContext, WORKSPACE_RECOMMENDATIONS_VIEW_ID, THEME_ACTIONS_GROUP, INSTALL_ACTIONS_GROUP, UPDATE_ACTIONS_GROUP, TOGGLE_IGNORE_EXTENSION_ACTION_ID, EXTENSIONS_CATEGORY } from '../common/extensions.js';
import { IExtensionsWorkbenchService } from '../common/extensions.service.js';
import { ExtensionsConfigurationSchemaId, ExtensionsConfigurationSchema } from '../common/extensionsFileTemplate.js';
import { ExtensionsInput } from '../common/extensionsInput.js';
import { KeymapExtensions } from '../common/extensionsUtils.js';
import { SearchExtensionsTool, SearchExtensionsToolData } from '../common/searchExtensionsTool.js';
import { ShowRuntimeExtensionsAction } from './abstractRuntimeExtensionsEditor.js';
import { ExtensionEditor } from './extensionEditor.js';
import { ExtensionEnablementWorkspaceTrustTransitionParticipant } from './extensionEnablementWorkspaceTrustTransitionParticipant.js';
import './extensionRecommendationNotificationService.js';
import './extensionRecommendationsService.js';
import { ConfigureWorkspaceFolderRecommendedExtensionsAction, InstallSpecificVersionOfExtensionAction, SetColorThemeAction, SetFileIconThemeAction, SetProductIconThemeAction, ToggleAutoUpdateForExtensionAction, ToggleAutoUpdatesForPublisherAction, TogglePreReleaseExtensionAction, ClearLanguageAction, InstallAction, InstallAnotherVersionAction, ConfigureWorkspaceRecommendedExtensionsAction } from './extensionsActions.js';
import { ExtensionActivationProgress } from './extensionsActivationProgress.js';
import { ExtensionsCompletionItemsProvider } from './extensionsCompletionItemsProvider.js';
import { ExtensionDependencyChecker } from './extensionsDependencyChecker.js';
import { extensionsViewIcon, installWorkspaceRecommendedIcon, filterIcon, clearSearchResultsIcon, refreshIcon, configureRecommendedIcon } from './extensionsIcons.js';
import { ManageExtensionsQuickAccessProvider, InstallExtensionQuickAccessProvider } from './extensionsQuickAccess.js';
import { ExtensionsViewPaneContainer, SearchHasTextContext, StatusUpdater, MaliciousExtensionChecker, ExtensionsViewletViewsContribution, ExtensionMarketplaceStatusUpdater } from './extensionsViewlet.js';
import './extensionsWorkbenchService.js';
import * as extensionManagement from './media/extensionManagement.css';
import { UnsupportedExtensionsMigrationContrib } from './unsupportedExtensionsMigrationContribution.js';
import Severity$1 from '../../../../base/common/severity.js';

registerCss(extensionManagement);
( Registry.as(Extensions.Quickaccess)).registerQuickAccessProvider({
    ctor: ManageExtensionsQuickAccessProvider,
    prefix: ManageExtensionsQuickAccessProvider.PREFIX,
    placeholder: ( localize(7359, "Press Enter to manage extensions.")),
    helpEntries: [{ description: ( localize(7360, "Manage Extensions")) }]
});
( Registry.as(EditorExtensions.EditorPane)).registerEditorPane(EditorPaneDescriptor.create(ExtensionEditor, ExtensionEditor.ID, ( localize(7361, "Extension"))), [
    ( new SyncDescriptor(ExtensionsInput))
]);
const VIEW_CONTAINER = ( Registry.as(Extensions$1.ViewContainersRegistry)).registerViewContainer({
    id: VIEWLET_ID,
    title: ( localize2(7362, "Extensions")),
    openCommandActionDescriptor: {
        id: VIEWLET_ID,
        mnemonicTitle: ( localize(7363, "E&&xtensions")),
        keybindings: { primary: KeyMod$1.CtrlCmd | KeyMod$1.Shift | KeyCode.KeyX },
        order: 4,
    },
    ctorDescriptor: ( new SyncDescriptor(ExtensionsViewPaneContainer)),
    icon: extensionsViewIcon,
    order: 4,
    rejectAddedViews: true,
    alwaysUseContainerInfo: true,
}, ViewContainerLocation.Sidebar);
( Registry.as(Extensions$2.Configuration))
    .registerConfiguration({
    id: 'extensions',
    order: 30,
    title: ( localize(7364, "Extensions")),
    type: 'object',
    properties: {
        'extensions.autoUpdate': {
            enum: [true, 'onlyEnabledExtensions', false,],
            enumItemLabels: [
                ( localize(7365, "All Extensions")),
                ( localize(7366, "Only Enabled Extensions")),
                ( localize(7367, "None")),
            ],
            enumDescriptions: [
                ( localize(7368, 'Download and install updates automatically for all extensions.')),
                ( localize(
                7369,
                'Download and install updates automatically only for enabled extensions.'
            )),
                ( localize(7370, 'Extensions are not automatically updated.')),
            ],
            description: ( localize(
                7371,
                "Controls the automatic update behavior of extensions. The updates are fetched from a Microsoft online service."
            )),
            default: true,
            scope: ConfigurationScope.APPLICATION,
            tags: ['usesOnlineServices']
        },
        'extensions.autoCheckUpdates': {
            type: 'boolean',
            description: ( localize(
                7372,
                "When enabled, automatically checks extensions for updates. If an extension has an update, it is marked as outdated in the Extensions view. The updates are fetched from a Microsoft online service."
            )),
            default: true,
            scope: ConfigurationScope.APPLICATION,
            tags: ['usesOnlineServices']
        },
        'extensions.ignoreRecommendations': {
            type: 'boolean',
            description: ( localize(
                7373,
                "When enabled, the notifications for extension recommendations will not be shown."
            )),
            default: false
        },
        'extensions.showRecommendationsOnlyOnDemand': {
            type: 'boolean',
            deprecationMessage: ( localize(
                7374,
                "This setting is deprecated. Use extensions.ignoreRecommendations setting to control recommendation notifications. Use Extensions view's visibility actions to hide Recommended view by default."
            )),
            default: false,
            tags: ['usesOnlineServices']
        },
        'extensions.closeExtensionDetailsOnViewChange': {
            type: 'boolean',
            description: ( localize(
                7375,
                "When enabled, editors with extension details will be automatically closed upon navigating away from the Extensions View."
            )),
            default: false
        },
        'extensions.confirmedUriHandlerExtensionIds': {
            type: 'array',
            items: {
                type: 'string'
            },
            description: ( localize(
                7376,
                "When an extension is listed here, a confirmation prompt will not be shown when that extension handles a URI."
            )),
            default: [],
            scope: ConfigurationScope.APPLICATION
        },
        'extensions.webWorker': {
            type: ['boolean', 'string'],
            enum: [true, false, 'auto'],
            enumDescriptions: [
                ( localize(7377, "The Web Worker Extension Host will always be launched.")),
                ( localize(7378, "The Web Worker Extension Host will never be launched.")),
                ( localize(
                7379,
                "The Web Worker Extension Host will be launched when a web extension needs it."
            )),
            ],
            description: ( localize(7380, "Enable web worker extension host.")),
            default: 'auto'
        },
        'extensions.supportVirtualWorkspaces': {
            type: 'object',
            markdownDescription: ( localize(7381, "Override the virtual workspaces support of an extension.")),
            patternProperties: {
                '([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$': {
                    type: 'boolean',
                    default: false
                }
            },
            additionalProperties: false,
            default: {},
            defaultSnippets: [{
                    'body': {
                        'pub.name': false
                    }
                }]
        },
        'extensions.experimental.affinity': {
            type: 'object',
            markdownDescription: ( localize(
                7382,
                "Configure an extension to execute in a different extension host process."
            )),
            patternProperties: {
                '([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$': {
                    type: 'integer',
                    default: 1
                }
            },
            additionalProperties: false,
            default: {},
            defaultSnippets: [{
                    'body': {
                        'pub.name': 1
                    }
                }]
        },
        [WORKSPACE_TRUST_EXTENSION_SUPPORT]: {
            type: 'object',
            scope: ConfigurationScope.APPLICATION,
            markdownDescription: ( localize(
                7383,
                "Override the untrusted workspace support of an extension. Extensions using `true` will always be enabled. Extensions using `limited` will always be enabled, and the extension will hide functionality that requires trust. Extensions using `false` will only be enabled only when the workspace is trusted."
            )),
            patternProperties: {
                '([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$': {
                    type: 'object',
                    properties: {
                        'supported': {
                            type: ['boolean', 'string'],
                            enum: [true, false, 'limited'],
                            enumDescriptions: [
                                ( localize(7384, "Extension will always be enabled.")),
                                ( localize(7385, "Extension will only be enabled only when the workspace is trusted.")),
                                ( localize(
                                7386,
                                "Extension will always be enabled, and the extension will hide functionality requiring trust."
                            )),
                            ],
                            description: ( localize(7387, "Defines the untrusted workspace support setting for the extension.")),
                        },
                        'version': {
                            type: 'string',
                            description: ( localize(
                                7388,
                                "Defines the version of the extension for which the override should be applied. If not specified, the override will be applied independent of the extension version."
                            )),
                        }
                    }
                }
            }
        },
        'extensions.experimental.deferredStartupFinishedActivation': {
            type: 'boolean',
            description: ( localize(
                7389,
                "When enabled, extensions which declare the `onStartupFinished` activation event will be activated after a timeout."
            )),
            default: false
        },
        'extensions.experimental.issueQuickAccess': {
            type: 'boolean',
            description: ( localize(
                7390,
                "When enabled, extensions can be searched for via Quick Access and report issues from there."
            )),
            default: true
        },
        [VerifyExtensionSignatureConfigKey]: {
            type: 'boolean',
            description: ( localize(
                7391,
                "When enabled, extensions are verified to be signed before getting installed."
            )),
            default: true,
            scope: ConfigurationScope.APPLICATION,
            included: isNative
        },
        [AutoRestartConfigurationKey]: {
            type: 'boolean',
            description: ( localize(
                7392,
                "If activated, extensions will automatically restart following an update if the window is not in focus. There can be a data loss if you have open Notebooks or Custom Editors."
            )),
            default: false,
            included: product.quality !== 'stable'
        },
        [ExtensionGalleryServiceUrlConfigKey]: {
            type: 'string',
            description: ( localize(7393, "Configure the Marketplace service URL to connect to")),
            default: '',
            scope: ConfigurationScope.APPLICATION,
            tags: ['usesOnlineServices'],
            included: false,
            policy: {
                name: 'ExtensionGalleryServiceUrl',
                category: PolicyCategory.Extensions,
                minimumVersion: '1.99',
                localization: {
                    description: {
                        key: 'extensions.gallery.serviceUrl',
                        value: ( localize(7393, "Configure the Marketplace service URL to connect to")),
                    }
                }
            },
        },
        'extensions.supportNodeGlobalNavigator': {
            type: 'boolean',
            description: ( localize(
                7394,
                "When enabled, Node.js navigator object is exposed on the global scope."
            )),
            default: false,
        },
        [ExtensionRequestsTimeoutConfigKey]: {
            type: 'number',
            description: ( localize(
                7395,
                "Controls the timeout in milliseconds for HTTP requests made when fetching extensions from the Marketplace"
            )),
            default: 60_000,
            scope: ConfigurationScope.APPLICATION,
            tags: ['advanced', 'usesOnlineServices']
        },
    }
});
const jsonRegistry = ( Registry.as(Extensions$3.JSONContribution));
jsonRegistry.registerSchema(ExtensionsConfigurationSchemaId, ExtensionsConfigurationSchema);
CommandsRegistry.registerCommand('_extensions.manage', (accessor, extensionId, tab, preserveFocus, feature) => {
    const extensionService = accessor.get(IExtensionsWorkbenchService);
    const extension = extensionService.local.find(e => areSameExtensions(e.identifier, { id: extensionId }));
    if (extension) {
        extensionService.open(extension, { tab, preserveFocus, feature });
    }
    else {
        throw ( new Error(( localize(7396, "Extension '{0}' not found.", extensionId))));
    }
});
CommandsRegistry.registerCommand('extension.open', async (accessor, extensionId, tab, preserveFocus, feature, sideByside) => {
    const extensionService = accessor.get(IExtensionsWorkbenchService);
    const commandService = accessor.get(ICommandService);
    const [extension] = await extensionService.getExtensions([{ id: extensionId }], CancellationToken.None);
    if (extension) {
        return extensionService.open(extension, { tab, preserveFocus, feature, sideByside });
    }
    return commandService.executeCommand('_extensions.manage', extensionId, tab, preserveFocus, feature);
});
CommandsRegistry.registerCommand({
    id: 'workbench.extensions.installExtension',
    metadata: {
        description: ( localize(7397, "Install the given extension")),
        args: [
            {
                name: 'extensionIdOrVSIXUri',
                description: ( localize(7398, "Extension id or VSIX resource uri")),
                constraint: (value) => typeof value === 'string' || value instanceof URI,
            },
            {
                name: 'options',
                description: '(optional) Options for installing the extension. Object with the following properties: ' +
                    '`installOnlyNewlyAddedFromExtensionPackVSIX`: When enabled, VS Code installs only newly added extensions from the extension pack VSIX. This option is considered only when installing VSIX. ',
                isOptional: true,
                schema: {
                    'type': 'object',
                    'properties': {
                        'installOnlyNewlyAddedFromExtensionPackVSIX': {
                            'type': 'boolean',
                            'description': ( localize(
                                7399,
                                "When enabled, VS Code installs only newly added extensions from the extension pack VSIX. This option is considered only while installing a VSIX."
                            )),
                            default: false
                        },
                        'installPreReleaseVersion': {
                            'type': 'boolean',
                            'description': ( localize(
                                7400,
                                "When enabled, VS Code installs the pre-release version of the extension if available."
                            )),
                            default: false
                        },
                        'donotSync': {
                            'type': 'boolean',
                            'description': ( localize(
                                7401,
                                "When enabled, VS Code do not sync this extension when Settings Sync is on."
                            )),
                            default: false
                        },
                        'justification': {
                            'type': ['string', 'object'],
                            'description': ( localize(
                                7402,
                                "Justification for installing the extension. This is a string or an object that can be used to pass any information to the installation handlers. i.e. `{reason: 'This extension wants to open a URI', action: 'Open URI'}` will show a message box with the reason and action upon install."
                            )),
                        },
                        'enable': {
                            'type': 'boolean',
                            'description': ( localize(
                                7403,
                                "When enabled, the extension will be enabled if it is installed but disabled. If the extension is already enabled, this has no effect."
                            )),
                            default: false
                        },
                        'context': {
                            'type': 'object',
                            'description': ( localize(
                                7404,
                                "Context for the installation. This is a JSON object that can be used to pass any information to the installation handlers. i.e. `{skipWalkthrough: true}` will skip opening the walkthrough upon install."
                            )),
                        }
                    }
                }
            }
        ]
    },
    handler: async (accessor, arg, options) => {
        const extensionsWorkbenchService = accessor.get(IExtensionsWorkbenchService);
        const extensionManagementService = accessor.get(IWorkbenchExtensionManagementService);
        const extensionGalleryService = accessor.get(IExtensionGalleryService);
        try {
            if (typeof arg === 'string') {
                const [id, version] = getIdAndVersion(arg);
                const extension = extensionsWorkbenchService.local.find(e => areSameExtensions(e.identifier, { id, uuid: version }));
                if (extension?.enablementState === EnablementState.DisabledByExtensionKind) {
                    const [gallery] = await extensionGalleryService.getExtensions([{ id, preRelease: options?.installPreReleaseVersion }], CancellationToken.None);
                    if (!gallery) {
                        throw ( new Error(( localize(7396, "Extension '{0}' not found.", arg))));
                    }
                    await extensionManagementService.installFromGallery(gallery, {
                        isMachineScoped: options?.donotSync ? true : undefined,
                        installPreReleaseVersion: options?.installPreReleaseVersion,
                        installGivenVersion: !!version,
                        context: { ...options?.context, [EXTENSION_INSTALL_SOURCE_CONTEXT]: ExtensionInstallSource.COMMAND },
                    });
                }
                else {
                    await extensionsWorkbenchService.install(id, {
                        version,
                        installPreReleaseVersion: options?.installPreReleaseVersion,
                        context: { ...options?.context, [EXTENSION_INSTALL_SOURCE_CONTEXT]: ExtensionInstallSource.COMMAND },
                        justification: options?.justification,
                        enable: options?.enable,
                        isMachineScoped: options?.donotSync ? true : undefined,
                    }, ProgressLocation.Notification);
                }
            }
            else {
                const vsix = URI.revive(arg);
                await extensionsWorkbenchService.install(vsix, { installGivenVersion: true });
            }
        }
        catch (e) {
            onUnexpectedError(e);
            throw e;
        }
    }
});
CommandsRegistry.registerCommand({
    id: 'workbench.extensions.uninstallExtension',
    metadata: {
        description: ( localize(7405, "Uninstall the given extension")),
        args: [
            {
                name: ( localize(7406, "Id of the extension to uninstall")),
                schema: {
                    'type': 'string'
                }
            }
        ]
    },
    handler: async (accessor, id) => {
        if (!id) {
            throw ( new Error(( localize(7407, "Extension id required."))));
        }
        const extensionManagementService = accessor.get(IExtensionManagementService);
        const installed = await extensionManagementService.getInstalled();
        const [extensionToUninstall] = installed.filter(e => areSameExtensions(e.identifier, { id }));
        if (!extensionToUninstall) {
            throw ( new Error(( localize(
                7408,
                "Extension '{0}' is not installed. Make sure you use the full extension ID, including the publisher, e.g.: ms-dotnettools.csharp.",
                id
            ))));
        }
        if (extensionToUninstall.isBuiltin) {
            throw ( new Error(( localize(
                7409,
                "Extension '{0}' is a Built-in extension and cannot be uninstalled",
                id
            ))));
        }
        try {
            await extensionManagementService.uninstall(extensionToUninstall);
        }
        catch (e) {
            onUnexpectedError(e);
            throw e;
        }
    }
});
CommandsRegistry.registerCommand({
    id: 'workbench.extensions.search',
    metadata: {
        description: ( localize(7410, "Search for a specific extension")),
        args: [
            {
                name: ( localize(7411, "Query to use in search")),
                schema: { 'type': 'string' }
            }
        ]
    },
    handler: async (accessor, query = '') => {
        return accessor.get(IExtensionsWorkbenchService).openSearch(query);
    }
});
function overrideActionForActiveExtensionEditorWebview(command, f) {
    command?.addImplementation(105, 'extensions-editor', (accessor) => {
        const editorService = accessor.get(IEditorService);
        const editor = editorService.activeEditorPane;
        if (editor instanceof ExtensionEditor) {
            if (editor.activeWebview?.isFocused) {
                f(editor.activeWebview);
                return true;
            }
        }
        return false;
    });
}
overrideActionForActiveExtensionEditorWebview(CopyAction, webview => webview.copy());
overrideActionForActiveExtensionEditorWebview(CutAction, webview => webview.cut());
overrideActionForActiveExtensionEditorWebview(PasteAction, webview => webview.paste());
const CONTEXT_HAS_LOCAL_SERVER = ( new RawContextKey('hasLocalServer', false));
const CONTEXT_HAS_REMOTE_SERVER = ( new RawContextKey('hasRemoteServer', false));
const CONTEXT_HAS_WEB_SERVER = ( new RawContextKey('hasWebServer', false));
const CONTEXT_GALLERY_SORT_CAPABILITIES = ( new RawContextKey('gallerySortCapabilities', ''));
const CONTEXT_GALLERY_FILTER_CAPABILITIES = ( new RawContextKey('galleryFilterCapabilities', ''));
const CONTEXT_GALLERY_ALL_PUBLIC_REPOSITORY_SIGNED = ( new RawContextKey('galleryAllPublicRepositorySigned', false));
const CONTEXT_GALLERY_ALL_PRIVATE_REPOSITORY_SIGNED = ( new RawContextKey('galleryAllPrivateRepositorySigned', false));
const CONTEXT_GALLERY_HAS_EXTENSION_LINK = ( new RawContextKey('galleryHasExtensionLink', false));
async function runAction(action) {
    try {
        await action.run();
    }
    finally {
        if (isDisposable(action)) {
            action.dispose();
        }
    }
}
let ExtensionsContributions = class ExtensionsContributions extends Disposable {
    constructor(extensionManagementService, extensionManagementServerService, extensionGalleryManifestService, contextKeyService, viewsService, extensionsWorkbenchService, extensionEnablementService, instantiationService, dialogService, commandService, productService) {
        super();
        this.extensionManagementService = extensionManagementService;
        this.extensionManagementServerService = extensionManagementServerService;
        this.extensionGalleryManifestService = extensionGalleryManifestService;
        this.contextKeyService = contextKeyService;
        this.viewsService = viewsService;
        this.extensionsWorkbenchService = extensionsWorkbenchService;
        this.extensionEnablementService = extensionEnablementService;
        this.instantiationService = instantiationService;
        this.dialogService = dialogService;
        this.commandService = commandService;
        this.productService = productService;
        const hasLocalServerContext = CONTEXT_HAS_LOCAL_SERVER.bindTo(contextKeyService);
        if (this.extensionManagementServerService.localExtensionManagementServer) {
            hasLocalServerContext.set(true);
        }
        const hasRemoteServerContext = CONTEXT_HAS_REMOTE_SERVER.bindTo(contextKeyService);
        if (this.extensionManagementServerService.remoteExtensionManagementServer) {
            hasRemoteServerContext.set(true);
        }
        const hasWebServerContext = CONTEXT_HAS_WEB_SERVER.bindTo(contextKeyService);
        if (this.extensionManagementServerService.webExtensionManagementServer) {
            hasWebServerContext.set(true);
        }
        this.updateExtensionGalleryStatusContexts();
        this._register(extensionGalleryManifestService.onDidChangeExtensionGalleryManifestStatus(() => this.updateExtensionGalleryStatusContexts()));
        extensionGalleryManifestService.getExtensionGalleryManifest()
            .then(extensionGalleryManifest => {
            this.updateGalleryCapabilitiesContexts(extensionGalleryManifest);
            this._register(extensionGalleryManifestService.onDidChangeExtensionGalleryManifest(extensionGalleryManifest => this.updateGalleryCapabilitiesContexts(extensionGalleryManifest)));
        });
        this.registerGlobalActions();
        this.registerContextMenuActions();
        this.registerQuickAccessProvider();
    }
    async updateExtensionGalleryStatusContexts() {
        CONTEXT_HAS_GALLERY.bindTo(this.contextKeyService).set(this.extensionGalleryManifestService.extensionGalleryManifestStatus === ExtensionGalleryManifestStatus.Available);
        CONTEXT_EXTENSIONS_GALLERY_STATUS.bindTo(this.contextKeyService).set(this.extensionGalleryManifestService.extensionGalleryManifestStatus);
    }
    async updateGalleryCapabilitiesContexts(extensionGalleryManifest) {
        CONTEXT_GALLERY_SORT_CAPABILITIES.bindTo(this.contextKeyService).set(`_${extensionGalleryManifest?.capabilities.extensionQuery.sorting?.map(s => s.name)?.join('_')}_UpdateDate_`);
        CONTEXT_GALLERY_FILTER_CAPABILITIES.bindTo(this.contextKeyService).set(`_${extensionGalleryManifest?.capabilities.extensionQuery.filtering?.map(s => s.name)?.join('_')}_`);
        CONTEXT_GALLERY_ALL_PUBLIC_REPOSITORY_SIGNED.bindTo(this.contextKeyService).set(!!extensionGalleryManifest?.capabilities?.signing?.allPublicRepositorySigned);
        CONTEXT_GALLERY_ALL_PRIVATE_REPOSITORY_SIGNED.bindTo(this.contextKeyService).set(!!extensionGalleryManifest?.capabilities?.signing?.allPrivateRepositorySigned);
        CONTEXT_GALLERY_HAS_EXTENSION_LINK.bindTo(this.contextKeyService).set(!!(extensionGalleryManifest && getExtensionGalleryManifestResourceUri(extensionGalleryManifest, ExtensionGalleryResourceType.ExtensionDetailsViewUri)));
    }
    registerQuickAccessProvider() {
        if (this.extensionManagementServerService.localExtensionManagementServer
            || this.extensionManagementServerService.remoteExtensionManagementServer
            || this.extensionManagementServerService.webExtensionManagementServer) {
            ( Registry.as(Extensions.Quickaccess)).registerQuickAccessProvider({
                ctor: InstallExtensionQuickAccessProvider,
                prefix: InstallExtensionQuickAccessProvider.PREFIX,
                placeholder: ( localize(7412, "Type the name of an extension to install or search.")),
                helpEntries: [{ description: ( localize(7413, "Install or Search Extensions")) }]
            });
        }
    }
    registerGlobalActions() {
        this._register(MenuRegistry.appendMenuItem(MenuId.MenubarPreferencesMenu, {
            command: {
                id: VIEWLET_ID,
                title: ( localize(7414, "&&Extensions"))
            },
            group: '2_configuration',
            order: 3
        }));
        this._register(MenuRegistry.appendMenuItem(MenuId.GlobalActivity, {
            command: {
                id: VIEWLET_ID,
                title: ( localize(7415, "Extensions"))
            },
            group: '2_configuration',
            order: 3
        }));
        this.registerExtensionAction({
            id: 'workbench.extensions.action.focusExtensionsView',
            title: ( localize2(7416, 'Focus on Extensions View')),
            category: ExtensionsLocalizedLabel,
            f1: true,
            run: async (accessor) => {
                await accessor.get(IExtensionsWorkbenchService).openSearch('');
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.installExtensions',
            title: ( localize2(7417, 'Install Extensions')),
            category: ExtensionsLocalizedLabel,
            menu: {
                id: MenuId.CommandPalette,
                when: ( ContextKeyExpr.and(CONTEXT_HAS_GALLERY, ( ContextKeyExpr.or(
                    CONTEXT_HAS_LOCAL_SERVER,
                    CONTEXT_HAS_REMOTE_SERVER,
                    CONTEXT_HAS_WEB_SERVER
                ))))
            },
            run: async (accessor) => {
                accessor.get(IViewsService).openViewContainer(VIEWLET_ID, true);
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.showRecommendedKeymapExtensions',
            title: ( localize2(7418, 'Keymaps')),
            category: PreferencesLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: CONTEXT_HAS_GALLERY
                }, {
                    id: MenuId.EditorTitle,
                    when: ( ContextKeyExpr.and(CONTEXT_KEYBINDINGS_EDITOR, CONTEXT_HAS_GALLERY)),
                    group: '2_keyboard_discover_actions'
                }],
            menuTitles: {
                [MenuId.EditorTitle.id]: ( localize(7419, "Migrate Keyboard Shortcuts from..."))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@recommended:keymaps ')
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.showLanguageExtensions',
            title: ( localize2(7420, 'Language Extensions')),
            category: PreferencesLocalizedLabel,
            menu: {
                id: MenuId.CommandPalette,
                when: CONTEXT_HAS_GALLERY
            },
            run: () => this.extensionsWorkbenchService.openSearch('@recommended:languages ')
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.checkForUpdates',
            title: ( localize2(7421, 'Check for Extension Updates')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: ( ContextKeyExpr.and(CONTEXT_HAS_GALLERY, ( ContextKeyExpr.or(
                        CONTEXT_HAS_LOCAL_SERVER,
                        CONTEXT_HAS_REMOTE_SERVER,
                        CONTEXT_HAS_WEB_SERVER
                    ))))
                }, {
                    id: MenuId.ViewContainerTitle,
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('viewContainer', VIEWLET_ID)), CONTEXT_HAS_GALLERY)),
                    group: '1_updates',
                    order: 1
                }],
            run: async () => {
                await this.extensionsWorkbenchService.checkForUpdates();
                const outdated = this.extensionsWorkbenchService.outdated;
                if (outdated.length) {
                    return this.extensionsWorkbenchService.openSearch('@outdated ');
                }
                else {
                    return this.dialogService.info(( localize(7422, "All extensions are up to date.")));
                }
            }
        });
        const enableAutoUpdateWhenCondition = ( ContextKeyExpr.equals(`config.${AutoUpdateConfigurationKey}`, false));
        this.registerExtensionAction({
            id: 'workbench.extensions.action.enableAutoUpdate',
            title: ( localize2(7423, 'Enable Auto Update for All Extensions')),
            category: ExtensionsLocalizedLabel,
            precondition: enableAutoUpdateWhenCondition,
            menu: [{
                    id: MenuId.ViewContainerTitle,
                    order: 5,
                    group: '1_updates',
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('viewContainer', VIEWLET_ID)), enableAutoUpdateWhenCondition))
                }, {
                    id: MenuId.CommandPalette,
                }],
            run: (accessor) => accessor.get(IExtensionsWorkbenchService).updateAutoUpdateForAllExtensions(true)
        });
        const disableAutoUpdateWhenCondition = ( ContextKeyExpr.notEquals(`config.${AutoUpdateConfigurationKey}`, false));
        this.registerExtensionAction({
            id: 'workbench.extensions.action.disableAutoUpdate',
            title: ( localize2(7424, 'Disable Auto Update for All Extensions')),
            precondition: disableAutoUpdateWhenCondition,
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.ViewContainerTitle,
                    order: 5,
                    group: '1_updates',
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('viewContainer', VIEWLET_ID)), disableAutoUpdateWhenCondition))
                }, {
                    id: MenuId.CommandPalette,
                }],
            run: (accessor) => accessor.get(IExtensionsWorkbenchService).updateAutoUpdateForAllExtensions(false)
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.updateAllExtensions',
            title: ( localize2(7425, 'Update All Extensions')),
            category: ExtensionsLocalizedLabel,
            precondition: HasOutdatedExtensionsContext,
            menu: [
                {
                    id: MenuId.CommandPalette,
                    when: ( ContextKeyExpr.and(CONTEXT_HAS_GALLERY, ( ContextKeyExpr.or(
                        CONTEXT_HAS_LOCAL_SERVER,
                        CONTEXT_HAS_REMOTE_SERVER,
                        CONTEXT_HAS_WEB_SERVER
                    ))))
                }, {
                    id: MenuId.ViewContainerTitle,
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('viewContainer', VIEWLET_ID)), ( ContextKeyExpr.or(( ( ContextKeyExpr.has(`config.${AutoUpdateConfigurationKey}`)).negate()), ( ContextKeyExpr.equals(`config.${AutoUpdateConfigurationKey}`, 'onlyEnabledExtensions')))))),
                    group: '1_updates',
                    order: 2
                }, {
                    id: MenuId.ViewTitle,
                    when: ( ContextKeyExpr.equals('view', OUTDATED_EXTENSIONS_VIEW_ID)),
                    group: 'navigation',
                    order: 1
                }
            ],
            icon: installWorkspaceRecommendedIcon,
            run: async () => {
                await this.extensionsWorkbenchService.updateAll();
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.enableAll',
            title: ( localize2(7426, 'Enable All Extensions')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: ( ContextKeyExpr.or(
                        CONTEXT_HAS_LOCAL_SERVER,
                        CONTEXT_HAS_REMOTE_SERVER,
                        CONTEXT_HAS_WEB_SERVER
                    ))
                }, {
                    id: MenuId.ViewContainerTitle,
                    when: ( ContextKeyExpr.equals('viewContainer', VIEWLET_ID)),
                    group: '2_enablement',
                    order: 1
                }],
            run: async () => {
                const extensionsToEnable = this.extensionsWorkbenchService.local.filter(e => !!e.local && this.extensionEnablementService.canChangeEnablement(e.local) && !this.extensionEnablementService.isEnabled(e.local));
                if (extensionsToEnable.length) {
                    await this.extensionsWorkbenchService.setEnablement(extensionsToEnable, EnablementState.EnabledGlobally);
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.enableAllWorkspace',
            title: ( localize2(7427, 'Enable All Extensions for this Workspace')),
            category: ExtensionsLocalizedLabel,
            menu: {
                id: MenuId.CommandPalette,
                when: ( ContextKeyExpr.and(( WorkbenchStateContext.notEqualsTo('empty')), ( ContextKeyExpr.or(
                    CONTEXT_HAS_LOCAL_SERVER,
                    CONTEXT_HAS_REMOTE_SERVER,
                    CONTEXT_HAS_WEB_SERVER
                ))))
            },
            run: async () => {
                const extensionsToEnable = this.extensionsWorkbenchService.local.filter(e => !!e.local && this.extensionEnablementService.canChangeEnablement(e.local) && !this.extensionEnablementService.isEnabled(e.local));
                if (extensionsToEnable.length) {
                    await this.extensionsWorkbenchService.setEnablement(extensionsToEnable, EnablementState.EnabledWorkspace);
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.disableAll',
            title: ( localize2(7428, 'Disable All Installed Extensions')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: ( ContextKeyExpr.or(
                        CONTEXT_HAS_LOCAL_SERVER,
                        CONTEXT_HAS_REMOTE_SERVER,
                        CONTEXT_HAS_WEB_SERVER
                    ))
                }, {
                    id: MenuId.ViewContainerTitle,
                    when: ( ContextKeyExpr.equals('viewContainer', VIEWLET_ID)),
                    group: '2_enablement',
                    order: 2
                }],
            run: async () => {
                const extensionsToDisable = this.extensionsWorkbenchService.local.filter(e => !e.isBuiltin && !!e.local && this.extensionEnablementService.isEnabled(e.local) && this.extensionEnablementService.canChangeEnablement(e.local));
                if (extensionsToDisable.length) {
                    await this.extensionsWorkbenchService.setEnablement(extensionsToDisable, EnablementState.DisabledGlobally);
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.disableAllWorkspace',
            title: ( localize2(7429, 'Disable All Installed Extensions for this Workspace')),
            category: ExtensionsLocalizedLabel,
            menu: {
                id: MenuId.CommandPalette,
                when: ( ContextKeyExpr.and(( WorkbenchStateContext.notEqualsTo('empty')), ( ContextKeyExpr.or(
                    CONTEXT_HAS_LOCAL_SERVER,
                    CONTEXT_HAS_REMOTE_SERVER,
                    CONTEXT_HAS_WEB_SERVER
                ))))
            },
            run: async () => {
                const extensionsToDisable = this.extensionsWorkbenchService.local.filter(e => !e.isBuiltin && !!e.local && this.extensionEnablementService.isEnabled(e.local) && this.extensionEnablementService.canChangeEnablement(e.local));
                if (extensionsToDisable.length) {
                    await this.extensionsWorkbenchService.setEnablement(extensionsToDisable, EnablementState.DisabledWorkspace);
                }
            }
        });
        this.registerExtensionAction({
            id: SELECT_INSTALL_VSIX_EXTENSION_COMMAND_ID,
            title: ( localize2(7430, 'Install from VSIX...')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: ( ContextKeyExpr.or(CONTEXT_HAS_LOCAL_SERVER, CONTEXT_HAS_REMOTE_SERVER))
                }, {
                    id: MenuId.ViewContainerTitle,
                    when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('viewContainer', VIEWLET_ID)), ( ContextKeyExpr.or(CONTEXT_HAS_LOCAL_SERVER, CONTEXT_HAS_REMOTE_SERVER)))),
                    group: '3_install',
                    order: 1
                }],
            run: async (accessor) => {
                const fileDialogService = accessor.get(IFileDialogService);
                const commandService = accessor.get(ICommandService);
                const vsixPaths = await fileDialogService.showOpenDialog({
                    title: ( localize(7431, "Install from VSIX")),
                    filters: [{ name: 'VSIX Extensions', extensions: ['vsix'] }],
                    canSelectFiles: true,
                    canSelectMany: true,
                    openLabel: mnemonicButtonLabel(( localize(7432, "&&Install")))
                });
                if (vsixPaths) {
                    await commandService.executeCommand(INSTALL_EXTENSION_FROM_VSIX_COMMAND_ID, vsixPaths);
                }
            }
        });
        this.registerExtensionAction({
            id: INSTALL_EXTENSION_FROM_VSIX_COMMAND_ID,
            title: ( localize(7433, "Install Extension VSIX")),
            menu: [{
                    id: MenuId.ExplorerContext,
                    group: 'extensions',
                    when: ( ContextKeyExpr.and(( ResourceContextKey.Extension.isEqualTo('.vsix')), ( ContextKeyExpr.or(CONTEXT_HAS_LOCAL_SERVER, CONTEXT_HAS_REMOTE_SERVER)))),
                }],
            run: async (accessor, resources) => {
                const extensionsWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const hostService = accessor.get(IHostService);
                const notificationService = accessor.get(INotificationService);
                const vsixs = Array.isArray(resources) ? resources : [resources];
                const result = await Promise.allSettled(( vsixs.map(
                    async (vsix) => await extensionsWorkbenchService.install(vsix, { installGivenVersion: true })
                )));
                let error, requireReload = false, requireRestart = false;
                for (const r of result) {
                    if (r.status === 'rejected') {
                        error = ( new Error(r.reason));
                        break;
                    }
                    requireReload = requireReload || r.value.runtimeState?.action === ExtensionRuntimeActionType.ReloadWindow;
                    requireRestart = requireRestart || r.value.runtimeState?.action === ExtensionRuntimeActionType.RestartExtensions;
                }
                if (error) {
                    throw error;
                }
                if (requireReload) {
                    notificationService.prompt(Severity$1.Info, vsixs.length > 1 ? ( localize(
                        7434,
                        "Completed installing extensions. Please reload Visual Studio Code to enable them."
                    ))
                        : ( localize(
                        7435,
                        "Completed installing extension. Please reload Visual Studio Code to enable it."
                    )), [{
                            label: ( localize(7436, "Reload Now")),
                            run: () => hostService.reload()
                        }]);
                }
                else if (requireRestart) {
                    notificationService.prompt(Severity$1.Info, vsixs.length > 1 ? ( localize(
                        7437,
                        "Completed installing extensions. Please restart extensions to enable them."
                    ))
                        : ( localize(
                        7438,
                        "Completed installing extension. Please restart extensions to enable it."
                    )), [{
                            label: ( localize(7439, "Restart Extensions")),
                            run: () => extensionsWorkbenchService.updateRunningExtensions()
                        }]);
                }
                else {
                    notificationService.prompt(Severity$1.Info, vsixs.length > 1 ? ( localize(7440, "Completed installing extensions.")) : ( localize(7441, "Completed installing extension.")), []);
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.installExtensionFromLocation',
            title: ( localize2(7442, 'Install Extension from Location...')),
            category: Categories.Developer,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: ( ContextKeyExpr.or(CONTEXT_HAS_WEB_SERVER, CONTEXT_HAS_LOCAL_SERVER))
                }],
            run: async (accessor) => {
                const extensionManagementService = accessor.get(IWorkbenchExtensionManagementService);
                if (isWeb) {
                    return (new Promise((c, e) => {
                        const quickInputService = accessor.get(IQuickInputService);
                        const disposables = ( new DisposableStore());
                        const quickPick = disposables.add(quickInputService.createQuickPick());
                        quickPick.title = ( localize(7443, "Install Extension from Location"));
                        quickPick.customButton = true;
                        quickPick.customLabel = ( localize(7444, "Install"));
                        quickPick.placeholder = ( localize(7445, "Location of the web extension"));
                        quickPick.ignoreFocusOut = true;
                        disposables.add(Event.any(quickPick.onDidAccept, quickPick.onDidCustom)(async () => {
                            quickPick.hide();
                            if (quickPick.value) {
                                try {
                                    await extensionManagementService.installFromLocation(( URI.parse(quickPick.value)));
                                }
                                catch (error) {
                                    e(error);
                                    return;
                                }
                            }
                            c();
                        }));
                        disposables.add(quickPick.onDidHide(() => disposables.dispose()));
                        quickPick.show();
                    }));
                }
                else {
                    const fileDialogService = accessor.get(IFileDialogService);
                    const extensionLocation = await fileDialogService.showOpenDialog({
                        canSelectFolders: true,
                        canSelectFiles: false,
                        canSelectMany: false,
                        title: ( localize(7443, "Install Extension from Location")),
                    });
                    if (extensionLocation?.[0]) {
                        await extensionManagementService.installFromLocation(extensionLocation[0]);
                    }
                }
            }
        });
        MenuRegistry.appendMenuItem(extensionsSearchActionsMenu, {
            submenu: extensionsFilterSubMenu,
            title: ( localize(7446, "Filter Extensions...")),
            group: 'navigation',
            order: 2,
            icon: filterIcon,
        });
        const showFeaturedExtensionsId = 'extensions.filter.featured';
        const featuresExtensionsWhenContext = ( ContextKeyExpr.and(CONTEXT_HAS_GALLERY, ( ContextKeyExpr.regex(CONTEXT_GALLERY_FILTER_CAPABILITIES.key, ( new RegExp(`_${FilterType.Featured}_`))))));
        this.registerExtensionAction({
            id: showFeaturedExtensionsId,
            title: ( localize2(7447, 'Show Featured Extensions')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: featuresExtensionsWhenContext
                }, {
                    id: extensionsFilterSubMenu,
                    when: featuresExtensionsWhenContext,
                    group: '1_predefined',
                    order: 1,
                }],
            menuTitles: {
                [extensionsFilterSubMenu.id]: ( localize(7448, "Featured"))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@featured ')
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.showPopularExtensions',
            title: ( localize2(7449, 'Show Popular Extensions')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: CONTEXT_HAS_GALLERY
                }, {
                    id: extensionsFilterSubMenu,
                    when: CONTEXT_HAS_GALLERY,
                    group: '1_predefined',
                    order: 2,
                }],
            menuTitles: {
                [extensionsFilterSubMenu.id]: ( localize(7450, "Most Popular"))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@popular ')
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.showRecommendedExtensions',
            title: ( localize2(7451, 'Show Recommended Extensions')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: CONTEXT_HAS_GALLERY
                }, {
                    id: extensionsFilterSubMenu,
                    when: CONTEXT_HAS_GALLERY,
                    group: '1_predefined',
                    order: 2,
                }],
            menuTitles: {
                [extensionsFilterSubMenu.id]: ( localize(7452, "Recommended"))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@recommended ')
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.recentlyPublishedExtensions',
            title: ( localize2(7453, 'Show Recently Published Extensions')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: CONTEXT_HAS_GALLERY
                }, {
                    id: extensionsFilterSubMenu,
                    when: CONTEXT_HAS_GALLERY,
                    group: '1_predefined',
                    order: 2,
                }],
            menuTitles: {
                [extensionsFilterSubMenu.id]: ( localize(7454, "Recently Published"))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@recentlyPublished ')
        });
        const extensionsCategoryFilterSubMenu = ( new MenuId('extensionsCategoryFilterSubMenu'));
        MenuRegistry.appendMenuItem(extensionsFilterSubMenu, {
            submenu: extensionsCategoryFilterSubMenu,
            title: ( localize(7455, "Category")),
            when: ( ContextKeyExpr.and(CONTEXT_HAS_GALLERY, ( ContextKeyExpr.regex(CONTEXT_GALLERY_FILTER_CAPABILITIES.key, ( new RegExp(`_${FilterType.Category}_`)))))),
            group: '2_categories',
            order: 1,
        });
        EXTENSION_CATEGORIES.forEach((category, index) => {
            this.registerExtensionAction({
                id: `extensions.actions.searchByCategory.${category}`,
                title: category,
                menu: [{
                        id: extensionsCategoryFilterSubMenu,
                        when: CONTEXT_HAS_GALLERY,
                        order: index,
                    }],
                run: () => this.extensionsWorkbenchService.openSearch(`@category:"${category.toLowerCase()}"`)
            });
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.installedExtensions',
            title: ( localize2(7456, 'Show Installed Extensions')),
            category: ExtensionsLocalizedLabel,
            f1: true,
            menu: [{
                    id: extensionsFilterSubMenu,
                    group: '3_installed',
                    order: 1,
                }],
            menuTitles: {
                [extensionsFilterSubMenu.id]: ( localize(7457, "Installed"))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@installed ')
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.listBuiltInExtensions',
            title: ( localize2(7458, 'Show Built-in Extensions')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: ( ContextKeyExpr.or(
                        CONTEXT_HAS_LOCAL_SERVER,
                        CONTEXT_HAS_REMOTE_SERVER,
                        CONTEXT_HAS_WEB_SERVER
                    ))
                }, {
                    id: extensionsFilterSubMenu,
                    group: '3_installed',
                    order: 3,
                }],
            menuTitles: {
                [extensionsFilterSubMenu.id]: ( localize(7459, "Built-in"))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@builtin ')
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.extensionUpdates',
            title: ( localize2(7460, 'Show Extension Updates')),
            category: ExtensionsLocalizedLabel,
            precondition: CONTEXT_HAS_GALLERY,
            f1: true,
            menu: [{
                    id: extensionsFilterSubMenu,
                    group: '3_installed',
                    when: CONTEXT_HAS_GALLERY,
                    order: 2,
                }],
            menuTitles: {
                [extensionsFilterSubMenu.id]: ( localize(7461, "Updates"))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@updates')
        });
        this.registerExtensionAction({
            id: LIST_WORKSPACE_UNSUPPORTED_EXTENSIONS_COMMAND_ID,
            title: ( localize2(7462, 'Show Extensions Unsupported By Workspace')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: ( ContextKeyExpr.or(CONTEXT_HAS_LOCAL_SERVER, CONTEXT_HAS_REMOTE_SERVER)),
                }, {
                    id: extensionsFilterSubMenu,
                    group: '3_installed',
                    order: 6,
                    when: ( ContextKeyExpr.or(CONTEXT_HAS_LOCAL_SERVER, CONTEXT_HAS_REMOTE_SERVER)),
                }],
            menuTitles: {
                [extensionsFilterSubMenu.id]: ( localize(7463, "Workspace Unsupported"))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@workspaceUnsupported')
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.showEnabledExtensions',
            title: ( localize2(7464, 'Show Enabled Extensions')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: ( ContextKeyExpr.or(
                        CONTEXT_HAS_LOCAL_SERVER,
                        CONTEXT_HAS_REMOTE_SERVER,
                        CONTEXT_HAS_WEB_SERVER
                    ))
                }, {
                    id: extensionsFilterSubMenu,
                    group: '3_installed',
                    order: 4,
                }],
            menuTitles: {
                [extensionsFilterSubMenu.id]: ( localize(7465, "Enabled"))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@enabled ')
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.showDisabledExtensions',
            title: ( localize2(7466, 'Show Disabled Extensions')),
            category: ExtensionsLocalizedLabel,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: ( ContextKeyExpr.or(
                        CONTEXT_HAS_LOCAL_SERVER,
                        CONTEXT_HAS_REMOTE_SERVER,
                        CONTEXT_HAS_WEB_SERVER
                    ))
                }, {
                    id: extensionsFilterSubMenu,
                    group: '3_installed',
                    order: 5,
                }],
            menuTitles: {
                [extensionsFilterSubMenu.id]: ( localize(7467, "Disabled"))
            },
            run: () => this.extensionsWorkbenchService.openSearch('@disabled ')
        });
        const extensionsSortSubMenu = ( new MenuId('extensionsSortSubMenu'));
        MenuRegistry.appendMenuItem(extensionsFilterSubMenu, {
            submenu: extensionsSortSubMenu,
            title: ( localize(7468, "Sort By")),
            when: ( ContextKeyExpr.and(( ContextKeyExpr.or(CONTEXT_HAS_GALLERY, DefaultViewsContext)))),
            group: '4_sort',
            order: 1,
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.clearExtensionsSearchResults',
            title: ( localize2(7469, 'Clear Extensions Search Results')),
            category: ExtensionsLocalizedLabel,
            icon: clearSearchResultsIcon,
            f1: true,
            precondition: SearchHasTextContext,
            menu: {
                id: extensionsSearchActionsMenu,
                group: 'navigation',
                order: 1,
            },
            run: async (accessor) => {
                const viewPaneContainer = accessor.get(IViewsService).getActiveViewPaneContainerWithId(VIEWLET_ID);
                if (viewPaneContainer) {
                    const extensionsViewPaneContainer = viewPaneContainer;
                    extensionsViewPaneContainer.search('');
                    extensionsViewPaneContainer.focus();
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.refreshExtension',
            title: ( localize2(7470, 'Refresh')),
            category: ExtensionsLocalizedLabel,
            icon: refreshIcon,
            f1: true,
            menu: {
                id: MenuId.ViewContainerTitle,
                when: ( ContextKeyExpr.equals('viewContainer', VIEWLET_ID)),
                group: 'navigation',
                order: 2
            },
            run: async (accessor) => {
                const viewPaneContainer = accessor.get(IViewsService).getActiveViewPaneContainerWithId(VIEWLET_ID);
                if (viewPaneContainer) {
                    await viewPaneContainer.refresh();
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.installWorkspaceRecommendedExtensions',
            title: ( localize(7471, "Install Workspace Recommended Extensions")),
            icon: installWorkspaceRecommendedIcon,
            menu: {
                id: MenuId.ViewTitle,
                when: ( ContextKeyExpr.equals('view', WORKSPACE_RECOMMENDATIONS_VIEW_ID)),
                group: 'navigation',
                order: 1
            },
            run: async (accessor) => {
                const view = accessor.get(IViewsService).getActiveViewWithId(WORKSPACE_RECOMMENDATIONS_VIEW_ID);
                return view.installWorkspaceRecommendations();
            }
        });
        this.registerExtensionAction({
            id: ConfigureWorkspaceFolderRecommendedExtensionsAction.ID,
            title: ConfigureWorkspaceFolderRecommendedExtensionsAction.LABEL,
            icon: configureRecommendedIcon,
            menu: [{
                    id: MenuId.CommandPalette,
                    when: ( WorkbenchStateContext.notEqualsTo('empty')),
                }, {
                    id: MenuId.ViewTitle,
                    when: ( ContextKeyExpr.equals('view', WORKSPACE_RECOMMENDATIONS_VIEW_ID)),
                    group: 'navigation',
                    order: 2
                }],
            run: () => runAction(this.instantiationService.createInstance(ConfigureWorkspaceFolderRecommendedExtensionsAction, ConfigureWorkspaceFolderRecommendedExtensionsAction.ID, ConfigureWorkspaceFolderRecommendedExtensionsAction.LABEL))
        });
        this.registerExtensionAction({
            id: InstallSpecificVersionOfExtensionAction.ID,
            title: { value: InstallSpecificVersionOfExtensionAction.LABEL, original: 'Install Specific Version of Extension...' },
            category: ExtensionsLocalizedLabel,
            menu: {
                id: MenuId.CommandPalette,
                when: ( ContextKeyExpr.and(CONTEXT_HAS_GALLERY, ( ContextKeyExpr.or(
                    CONTEXT_HAS_LOCAL_SERVER,
                    CONTEXT_HAS_REMOTE_SERVER,
                    CONTEXT_HAS_WEB_SERVER
                ))))
            },
            run: () => runAction(this.instantiationService.createInstance(InstallSpecificVersionOfExtensionAction, InstallSpecificVersionOfExtensionAction.ID, InstallSpecificVersionOfExtensionAction.LABEL))
        });
    }
    registerContextMenuActions() {
        this.registerExtensionAction({
            id: SetColorThemeAction.ID,
            title: SetColorThemeAction.TITLE,
            menu: {
                id: MenuId.ExtensionContext,
                group: THEME_ACTIONS_GROUP,
                order: 0,
                when: ( ContextKeyExpr.and(ContextKeyExpr.not('inExtensionEditor'), ( ContextKeyExpr.equals('extensionStatus', 'installed')), ( ContextKeyExpr.has('extensionHasColorThemes'))))
            },
            run: async (accessor, extensionId) => {
                const extensionWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const instantiationService = accessor.get(IInstantiationService);
                const extension = extensionWorkbenchService.local.find(e => areSameExtensions(e.identifier, { id: extensionId }));
                if (extension) {
                    const action = instantiationService.createInstance(SetColorThemeAction);
                    action.extension = extension;
                    return action.run();
                }
            }
        });
        this.registerExtensionAction({
            id: SetFileIconThemeAction.ID,
            title: SetFileIconThemeAction.TITLE,
            menu: {
                id: MenuId.ExtensionContext,
                group: THEME_ACTIONS_GROUP,
                order: 0,
                when: ( ContextKeyExpr.and(ContextKeyExpr.not('inExtensionEditor'), ( ContextKeyExpr.equals('extensionStatus', 'installed')), ( ContextKeyExpr.has('extensionHasFileIconThemes'))))
            },
            run: async (accessor, extensionId) => {
                const extensionWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const instantiationService = accessor.get(IInstantiationService);
                const extension = extensionWorkbenchService.local.find(e => areSameExtensions(e.identifier, { id: extensionId }));
                if (extension) {
                    const action = instantiationService.createInstance(SetFileIconThemeAction);
                    action.extension = extension;
                    return action.run();
                }
            }
        });
        this.registerExtensionAction({
            id: SetProductIconThemeAction.ID,
            title: SetProductIconThemeAction.TITLE,
            menu: {
                id: MenuId.ExtensionContext,
                group: THEME_ACTIONS_GROUP,
                order: 0,
                when: ( ContextKeyExpr.and(ContextKeyExpr.not('inExtensionEditor'), ( ContextKeyExpr.equals('extensionStatus', 'installed')), ( ContextKeyExpr.has('extensionHasProductIconThemes'))))
            },
            run: async (accessor, extensionId) => {
                const extensionWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const instantiationService = accessor.get(IInstantiationService);
                const extension = extensionWorkbenchService.local.find(e => areSameExtensions(e.identifier, { id: extensionId }));
                if (extension) {
                    const action = instantiationService.createInstance(SetProductIconThemeAction);
                    action.extension = extension;
                    return action.run();
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.showPreReleaseVersion',
            title: ( localize2(7472, 'Show Pre-Release Version')),
            menu: {
                id: MenuId.ExtensionContext,
                group: INSTALL_ACTIONS_GROUP,
                order: 0,
                when: ( ContextKeyExpr.and(( ContextKeyExpr.has('inExtensionEditor')), ( ContextKeyExpr.has('galleryExtensionHasPreReleaseVersion')), ( ContextKeyExpr.has('isPreReleaseExtensionAllowed')), ContextKeyExpr.not('showPreReleaseVersion'), ContextKeyExpr.not('isBuiltinExtension')))
            },
            run: async (accessor, extensionId) => {
                const extensionWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const extension = (await extensionWorkbenchService.getExtensions([{ id: extensionId }], CancellationToken.None))[0];
                extensionWorkbenchService.open(extension, { showPreReleaseVersion: true });
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.showReleasedVersion',
            title: ( localize2(7473, 'Show Release Version')),
            menu: {
                id: MenuId.ExtensionContext,
                group: INSTALL_ACTIONS_GROUP,
                order: 1,
                when: ( ContextKeyExpr.and(( ContextKeyExpr.has('inExtensionEditor')), ( ContextKeyExpr.has('galleryExtensionHasPreReleaseVersion')), ( ContextKeyExpr.has('extensionHasReleaseVersion')), ( ContextKeyExpr.has('showPreReleaseVersion')), ContextKeyExpr.not('isBuiltinExtension')))
            },
            run: async (accessor, extensionId) => {
                const extensionWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const extension = (await extensionWorkbenchService.getExtensions([{ id: extensionId }], CancellationToken.None))[0];
                extensionWorkbenchService.open(extension, { showPreReleaseVersion: false });
            }
        });
        this.registerExtensionAction({
            id: ToggleAutoUpdateForExtensionAction.ID,
            title: ToggleAutoUpdateForExtensionAction.LABEL,
            category: ExtensionsLocalizedLabel,
            precondition: ( ContextKeyExpr.and(( ContextKeyExpr.or(( ContextKeyExpr.notEquals(`config.${AutoUpdateConfigurationKey}`, 'onlyEnabledExtensions')), ( ContextKeyExpr.equals('isExtensionEnabled', true)))), ContextKeyExpr.not('extensionDisallowInstall'), ( ContextKeyExpr.has('isExtensionAllowed')))),
            menu: {
                id: MenuId.ExtensionContext,
                group: UPDATE_ACTIONS_GROUP,
                order: 1,
                when: ( ContextKeyExpr.and(ContextKeyExpr.not('inExtensionEditor'), ( ContextKeyExpr.equals('extensionStatus', 'installed')), ContextKeyExpr.not('isBuiltinExtension')))
            },
            run: async (accessor, id) => {
                const instantiationService = accessor.get(IInstantiationService);
                const extensionWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const extension = extensionWorkbenchService.local.find(e => areSameExtensions(e.identifier, { id }));
                if (extension) {
                    const action = instantiationService.createInstance(ToggleAutoUpdateForExtensionAction);
                    action.extension = extension;
                    return action.run();
                }
            }
        });
        this.registerExtensionAction({
            id: ToggleAutoUpdatesForPublisherAction.ID,
            title: { value: ToggleAutoUpdatesForPublisherAction.LABEL, original: 'Auto Update (Publisher)' },
            category: ExtensionsLocalizedLabel,
            precondition: ( ContextKeyExpr.equals(`config.${AutoUpdateConfigurationKey}`, false)),
            menu: {
                id: MenuId.ExtensionContext,
                group: UPDATE_ACTIONS_GROUP,
                order: 2,
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('extensionStatus', 'installed')), ContextKeyExpr.not('isBuiltinExtension')))
            },
            run: async (accessor, id) => {
                const instantiationService = accessor.get(IInstantiationService);
                const extensionWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const extension = extensionWorkbenchService.local.find(e => areSameExtensions(e.identifier, { id }));
                if (extension) {
                    const action = instantiationService.createInstance(ToggleAutoUpdatesForPublisherAction);
                    action.extension = extension;
                    return action.run();
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.switchToPreRlease',
            title: ( localize(7474, "Switch to Pre-Release Version")),
            category: ExtensionsLocalizedLabel,
            menu: {
                id: MenuId.ExtensionContext,
                group: INSTALL_ACTIONS_GROUP,
                order: 2,
                when: ( ContextKeyExpr.and(CONTEXT_HAS_GALLERY, ( ContextKeyExpr.has('galleryExtensionHasPreReleaseVersion')), ( ContextKeyExpr.has('isPreReleaseExtensionAllowed')), ContextKeyExpr.not('installedExtensionIsOptedToPreRelease'), ContextKeyExpr.not('inExtensionEditor'), ( ContextKeyExpr.equals('extensionStatus', 'installed')), ContextKeyExpr.not('isBuiltinExtension')))
            },
            run: async (accessor, id) => {
                const instantiationService = accessor.get(IInstantiationService);
                const extensionWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const extension = extensionWorkbenchService.local.find(e => areSameExtensions(e.identifier, { id }));
                if (extension) {
                    const action = instantiationService.createInstance(TogglePreReleaseExtensionAction);
                    action.extension = extension;
                    return action.run();
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.switchToRelease',
            title: ( localize(7475, "Switch to Release Version")),
            category: ExtensionsLocalizedLabel,
            menu: {
                id: MenuId.ExtensionContext,
                group: INSTALL_ACTIONS_GROUP,
                order: 2,
                when: ( ContextKeyExpr.and(CONTEXT_HAS_GALLERY, ( ContextKeyExpr.has('galleryExtensionHasPreReleaseVersion')), ( ContextKeyExpr.has('isExtensionAllowed')), ( ContextKeyExpr.has('installedExtensionIsOptedToPreRelease')), ContextKeyExpr.not('inExtensionEditor'), ( ContextKeyExpr.equals('extensionStatus', 'installed')), ContextKeyExpr.not('isBuiltinExtension')))
            },
            run: async (accessor, id) => {
                const instantiationService = accessor.get(IInstantiationService);
                const extensionWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const extension = extensionWorkbenchService.local.find(e => areSameExtensions(e.identifier, { id }));
                if (extension) {
                    const action = instantiationService.createInstance(TogglePreReleaseExtensionAction);
                    action.extension = extension;
                    return action.run();
                }
            }
        });
        this.registerExtensionAction({
            id: ClearLanguageAction.ID,
            title: ClearLanguageAction.TITLE,
            menu: {
                id: MenuId.ExtensionContext,
                group: INSTALL_ACTIONS_GROUP,
                order: 0,
                when: ( ContextKeyExpr.and(ContextKeyExpr.not('inExtensionEditor'), ( ContextKeyExpr.has('canSetLanguage')), ( ContextKeyExpr.has('isActiveLanguagePackExtension'))))
            },
            run: async (accessor, extensionId) => {
                const instantiationService = accessor.get(IInstantiationService);
                const extensionsWorkbenchService = accessor.get(IExtensionsWorkbenchService);
                const extension = (await extensionsWorkbenchService.getExtensions([{ id: extensionId }], CancellationToken.None))[0];
                const action = instantiationService.createInstance(ClearLanguageAction);
                action.extension = extension;
                return action.run();
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.installUnsigned',
            title: ( localize(7476, "Install")),
            menu: {
                id: MenuId.ExtensionContext,
                group: '0_install',
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('extensionStatus', 'uninstalled')), ( ContextKeyExpr.has('isGalleryExtension')), ContextKeyExpr.not('extensionDisallowInstall'), ( ContextKeyExpr.has('extensionIsUnsigned')), ( ContextKeyExpr.or(( ContextKeyExpr.and(
                    CONTEXT_GALLERY_ALL_PUBLIC_REPOSITORY_SIGNED,
                    ContextKeyExpr.not('extensionIsPrivate')
                )), ( ContextKeyExpr.and(CONTEXT_GALLERY_ALL_PRIVATE_REPOSITORY_SIGNED, ( ContextKeyExpr.has('extensionIsPrivate')))))))),
                order: 1
            },
            run: async (accessor, extensionId) => {
                const instantiationService = accessor.get(IInstantiationService);
                const extension = this.extensionsWorkbenchService.local.filter(e => areSameExtensions(e.identifier, { id: extensionId }))[0]
                    || (await this.extensionsWorkbenchService.getExtensions([{ id: extensionId }], CancellationToken.None))[0];
                if (extension) {
                    const action = instantiationService.createInstance(InstallAction, { installPreReleaseVersion: this.extensionManagementService.preferPreReleases });
                    action.extension = extension;
                    return action.run();
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.installAndDonotSync',
            title: ( localize(7477, "Install (Do not Sync)")),
            menu: {
                id: MenuId.ExtensionContext,
                group: '0_install',
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('extensionStatus', 'uninstalled')), ( ContextKeyExpr.has('isGalleryExtension')), ( ContextKeyExpr.has('isExtensionAllowed')), ContextKeyExpr.not('extensionDisallowInstall'), CONTEXT_SYNC_ENABLEMENT)),
                order: 1
            },
            run: async (accessor, extensionId) => {
                const instantiationService = accessor.get(IInstantiationService);
                const extension = this.extensionsWorkbenchService.local.filter(e => areSameExtensions(e.identifier, { id: extensionId }))[0]
                    || (await this.extensionsWorkbenchService.getExtensions([{ id: extensionId }], CancellationToken.None))[0];
                if (extension) {
                    const action = instantiationService.createInstance(InstallAction, {
                        installPreReleaseVersion: this.extensionManagementService.preferPreReleases,
                        isMachineScoped: true,
                    });
                    action.extension = extension;
                    return action.run();
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.installPrereleaseAndDonotSync',
            title: ( localize(7478, "Install Pre-Release (Do not Sync)")),
            menu: {
                id: MenuId.ExtensionContext,
                group: '0_install',
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('extensionStatus', 'uninstalled')), ( ContextKeyExpr.has('isGalleryExtension')), ( ContextKeyExpr.has('extensionHasPreReleaseVersion')), ( ContextKeyExpr.has('isPreReleaseExtensionAllowed')), ContextKeyExpr.not('extensionDisallowInstall'), CONTEXT_SYNC_ENABLEMENT)),
                order: 2
            },
            run: async (accessor, extensionId) => {
                const instantiationService = accessor.get(IInstantiationService);
                const extension = this.extensionsWorkbenchService.local.filter(e => areSameExtensions(e.identifier, { id: extensionId }))[0]
                    || (await this.extensionsWorkbenchService.getExtensions([{ id: extensionId }], CancellationToken.None))[0];
                if (extension) {
                    const action = instantiationService.createInstance(InstallAction, {
                        isMachineScoped: true,
                        preRelease: true
                    });
                    action.extension = extension;
                    return action.run();
                }
            }
        });
        this.registerExtensionAction({
            id: InstallAnotherVersionAction.ID,
            title: InstallAnotherVersionAction.LABEL,
            menu: {
                id: MenuId.ExtensionContext,
                group: '0_install',
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('extensionStatus', 'uninstalled')), ( ContextKeyExpr.has('isGalleryExtension')), ( ContextKeyExpr.has('isExtensionAllowed')), ContextKeyExpr.not('extensionDisallowInstall'))),
                order: 3
            },
            run: async (accessor, extensionId) => {
                const instantiationService = accessor.get(IInstantiationService);
                const extension = this.extensionsWorkbenchService.local.filter(e => areSameExtensions(e.identifier, { id: extensionId }))[0]
                    || (await this.extensionsWorkbenchService.getExtensions([{ id: extensionId }], CancellationToken.None))[0];
                if (extension) {
                    return instantiationService.createInstance(InstallAnotherVersionAction, extension, false).run();
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.copyExtension',
            title: ( localize2(7479, 'Copy')),
            menu: {
                id: MenuId.ExtensionContext,
                group: '1_copy'
            },
            run: async (accessor, extensionId) => {
                const clipboardService = accessor.get(IClipboardService);
                const extension = this.extensionsWorkbenchService.local.filter(e => areSameExtensions(e.identifier, { id: extensionId }))[0]
                    || (await this.extensionsWorkbenchService.getExtensions([{ id: extensionId }], CancellationToken.None))[0];
                if (extension) {
                    const name = ( localize(7480, 'Name: {0}', extension.displayName));
                    const id = ( localize(7481, 'Id: {0}', extensionId));
                    const description = ( localize(7482, 'Description: {0}', extension.description));
                    const verision = ( localize(7483, 'Version: {0}', extension.version));
                    const publisher = ( localize(7484, 'Publisher: {0}', extension.publisherDisplayName));
                    const link = extension.url ? ( localize(7485, 'VS Marketplace Link: {0}', `${extension.url}`)) : null;
                    const clipboardStr = `${name}\n${id}\n${description}\n${verision}\n${publisher}${link ? '\n' + link : ''}`;
                    await clipboardService.writeText(clipboardStr);
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.copyExtensionId',
            title: ( localize2(7486, 'Copy Extension ID')),
            menu: {
                id: MenuId.ExtensionContext,
                group: '1_copy'
            },
            run: async (accessor, id) => accessor.get(IClipboardService).writeText(id)
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.copyLink',
            title: ( localize2(7487, 'Copy Link')),
            menu: {
                id: MenuId.ExtensionContext,
                group: '1_copy',
                when: ( ContextKeyExpr.and(( ContextKeyExpr.has('isGalleryExtension')), CONTEXT_GALLERY_HAS_EXTENSION_LINK)),
            },
            run: async (accessor, _, extension) => {
                const clipboardService = accessor.get(IClipboardService);
                if (extension.galleryLink) {
                    await clipboardService.writeText(extension.galleryLink);
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.configure',
            title: ( localize2(7488, 'Settings')),
            menu: {
                id: MenuId.ExtensionContext,
                group: '2_configure',
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('extensionStatus', 'installed')), ( ContextKeyExpr.has('extensionHasConfiguration')))),
                order: 1
            },
            run: async (accessor, id) => accessor.get(IPreferencesService).openSettings({ jsonEditor: false, query: `@ext:${id}` })
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.download',
            title: ( localize(7489, "Download VSIX")),
            menu: {
                id: MenuId.ExtensionContext,
                when: ( ContextKeyExpr.and(ContextKeyExpr.not('extensionDisallowInstall'), ( ContextKeyExpr.has('isGalleryExtension')))),
                order: this.productService.quality === 'stable' ? 0 : 1
            },
            run: async (accessor, extensionId) => {
                accessor.get(IExtensionsWorkbenchService).downloadVSIX(extensionId, 'release');
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.downloadPreRelease',
            title: ( localize(7490, "Download Pre-Release VSIX")),
            menu: {
                id: MenuId.ExtensionContext,
                when: ( ContextKeyExpr.and(ContextKeyExpr.not('extensionDisallowInstall'), ( ContextKeyExpr.has('isGalleryExtension')), ( ContextKeyExpr.has('extensionHasPreReleaseVersion')))),
                order: this.productService.quality === 'stable' ? 1 : 0
            },
            run: async (accessor, extensionId) => {
                accessor.get(IExtensionsWorkbenchService).downloadVSIX(extensionId, 'prerelease');
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.downloadSpecificVersion',
            title: ( localize(7491, "Download Specific Version VSIX...")),
            menu: {
                id: MenuId.ExtensionContext,
                when: ( ContextKeyExpr.and(ContextKeyExpr.not('extensionDisallowInstall'), ( ContextKeyExpr.has('isGalleryExtension')))),
                order: 2
            },
            run: async (accessor, extensionId) => {
                accessor.get(IExtensionsWorkbenchService).downloadVSIX(extensionId, 'any');
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.manageAccountPreferences',
            title: ( localize2(7492, "Account Preferences")),
            menu: {
                id: MenuId.ExtensionContext,
                group: '2_configure',
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('extensionStatus', 'installed')), ( ContextKeyExpr.has('extensionHasAccountPreferences')))),
                order: 2,
            },
            run: (accessor, id) => accessor.get(ICommandService).executeCommand('_manageAccountPreferencesForExtension', id)
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.configureKeybindings',
            title: ( localize2(7493, 'Keyboard Shortcuts')),
            menu: {
                id: MenuId.ExtensionContext,
                group: '2_configure',
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('extensionStatus', 'installed')), ( ContextKeyExpr.has('extensionHasKeybindings')))),
                order: 2
            },
            run: async (accessor, id) => accessor.get(IPreferencesService).openGlobalKeybindingSettings(false, { query: `@ext:${id}` })
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.toggleApplyToAllProfiles',
            title: ( localize2(7494, "Apply Extension to all Profiles")),
            toggled: ( ContextKeyExpr.has('isApplicationScopedExtension')),
            menu: {
                id: MenuId.ExtensionContext,
                group: '2_configure',
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('extensionStatus', 'installed')), ( ( ContextKeyExpr.has('isDefaultApplicationScopedExtension')).negate()), ( ( ContextKeyExpr.has('isBuiltinExtension')).negate()), ( ContextKeyExpr.equals('isWorkspaceScopedExtension', false)))),
                order: 3
            },
            run: async (accessor, _, extensionArg) => {
                const uriIdentityService = accessor.get(IUriIdentityService);
                const extension = extensionArg.location ? this.extensionsWorkbenchService.installed.find(e => uriIdentityService.extUri.isEqual(e.local?.location, extensionArg.location)) : undefined;
                if (extension) {
                    return this.extensionsWorkbenchService.toggleApplyExtensionToAllProfiles(extension);
                }
            }
        });
        this.registerExtensionAction({
            id: TOGGLE_IGNORE_EXTENSION_ACTION_ID,
            title: ( localize2(7495, "Sync This Extension")),
            menu: {
                id: MenuId.ExtensionContext,
                group: '2_configure',
                when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('extensionStatus', 'installed')), CONTEXT_SYNC_ENABLEMENT, ( ContextKeyExpr.equals('isWorkspaceScopedExtension', false)))),
                order: 4
            },
            run: async (accessor, id) => {
                const extension = this.extensionsWorkbenchService.local.find(e => areSameExtensions({ id }, e.identifier));
                if (extension) {
                    return this.extensionsWorkbenchService.toggleExtensionIgnoredToSync(extension);
                }
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.ignoreRecommendation',
            title: ( localize2(7496, "Ignore Recommendation")),
            menu: {
                id: MenuId.ExtensionContext,
                group: '3_recommendations',
                when: ( ContextKeyExpr.has('isExtensionRecommended')),
                order: 1
            },
            run: async (accessor, id) => accessor.get(IExtensionIgnoredRecommendationsService).toggleGlobalIgnoredRecommendation(id, true)
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.undoIgnoredRecommendation',
            title: ( localize2(7497, "Undo Ignored Recommendation")),
            menu: {
                id: MenuId.ExtensionContext,
                group: '3_recommendations',
                when: ( ContextKeyExpr.has('isUserIgnoredRecommendation')),
                order: 1
            },
            run: async (accessor, id) => accessor.get(IExtensionIgnoredRecommendationsService).toggleGlobalIgnoredRecommendation(id, false)
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.addExtensionToWorkspaceRecommendations',
            title: ( localize2(7498, "Add to Workspace Recommendations")),
            menu: {
                id: MenuId.ExtensionContext,
                group: '3_recommendations',
                when: ( ContextKeyExpr.and(( WorkbenchStateContext.notEqualsTo('empty')), ( ( ContextKeyExpr.has('isBuiltinExtension')).negate()), ( ( ContextKeyExpr.has('isExtensionWorkspaceRecommended')).negate()), ( ( ContextKeyExpr.has('isUserIgnoredRecommendation')).negate()), ( ContextKeyExpr.notEquals('extensionSource', 'resource')))),
                order: 2
            },
            run: (accessor, id) => accessor.get(IWorkspaceExtensionsConfigService).toggleRecommendation(id)
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.removeExtensionFromWorkspaceRecommendations',
            title: ( localize2(7499, "Remove from Workspace Recommendations")),
            menu: {
                id: MenuId.ExtensionContext,
                group: '3_recommendations',
                when: ( ContextKeyExpr.and(( WorkbenchStateContext.notEqualsTo('empty')), ( ( ContextKeyExpr.has('isBuiltinExtension')).negate()), ( ContextKeyExpr.has('isExtensionWorkspaceRecommended')))),
                order: 2
            },
            run: (accessor, id) => accessor.get(IWorkspaceExtensionsConfigService).toggleRecommendation(id)
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.addToWorkspaceRecommendations',
            title: ( localize2(7500, "Add Extension to Workspace Recommendations")),
            category: EXTENSIONS_CATEGORY,
            menu: {
                id: MenuId.CommandPalette,
                when: ( ContextKeyExpr.and(( WorkbenchStateContext.isEqualTo('workspace')), ( ContextKeyExpr.equals('resourceScheme', Schemas.extension)))),
            },
            async run(accessor) {
                const editorService = accessor.get(IEditorService);
                const workspaceExtensionsConfigService = accessor.get(IWorkspaceExtensionsConfigService);
                if (!(editorService.activeEditor instanceof ExtensionsInput)) {
                    return;
                }
                const extensionId = editorService.activeEditor.extension.identifier.id.toLowerCase();
                const recommendations = await workspaceExtensionsConfigService.getRecommendations();
                if (recommendations.includes(extensionId)) {
                    return;
                }
                await workspaceExtensionsConfigService.toggleRecommendation(extensionId);
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.addToWorkspaceFolderRecommendations',
            title: ( localize2(7501, "Add Extension to Workspace Folder Recommendations")),
            category: EXTENSIONS_CATEGORY,
            menu: {
                id: MenuId.CommandPalette,
                when: ( ContextKeyExpr.and(( WorkbenchStateContext.isEqualTo('folder')), ( ContextKeyExpr.equals('resourceScheme', Schemas.extension)))),
            },
            run: () => this.commandService.executeCommand('workbench.extensions.action.addToWorkspaceRecommendations')
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.addToWorkspaceIgnoredRecommendations',
            title: ( localize2(7502, "Add Extension to Workspace Ignored Recommendations")),
            category: EXTENSIONS_CATEGORY,
            menu: {
                id: MenuId.CommandPalette,
                when: ( ContextKeyExpr.and(( WorkbenchStateContext.isEqualTo('workspace')), ( ContextKeyExpr.equals('resourceScheme', Schemas.extension)))),
            },
            async run(accessor) {
                const editorService = accessor.get(IEditorService);
                const workspaceExtensionsConfigService = accessor.get(IWorkspaceExtensionsConfigService);
                if (!(editorService.activeEditor instanceof ExtensionsInput)) {
                    return;
                }
                const extensionId = editorService.activeEditor.extension.identifier.id.toLowerCase();
                const unwantedRecommendations = await workspaceExtensionsConfigService.getUnwantedRecommendations();
                if (unwantedRecommendations.includes(extensionId)) {
                    return;
                }
                await workspaceExtensionsConfigService.toggleUnwantedRecommendation(extensionId);
            }
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.addToWorkspaceFolderIgnoredRecommendations',
            title: ( localize2(7503, "Add Extension to Workspace Folder Ignored Recommendations")),
            category: EXTENSIONS_CATEGORY,
            menu: {
                id: MenuId.CommandPalette,
                when: ( ContextKeyExpr.and(( WorkbenchStateContext.isEqualTo('folder')), ( ContextKeyExpr.equals('resourceScheme', Schemas.extension)))),
            },
            run: () => this.commandService.executeCommand('workbench.extensions.action.addToWorkspaceIgnoredRecommendations')
        });
        this.registerExtensionAction({
            id: ConfigureWorkspaceRecommendedExtensionsAction.ID,
            title: { value: ConfigureWorkspaceRecommendedExtensionsAction.LABEL, original: 'Configure Recommended Extensions (Workspace)' },
            category: EXTENSIONS_CATEGORY,
            menu: {
                id: MenuId.CommandPalette,
                when: ( WorkbenchStateContext.isEqualTo('workspace')),
            },
            run: () => runAction(this.instantiationService.createInstance(ConfigureWorkspaceRecommendedExtensionsAction, ConfigureWorkspaceRecommendedExtensionsAction.ID, ConfigureWorkspaceRecommendedExtensionsAction.LABEL))
        });
        this.registerExtensionAction({
            id: 'workbench.extensions.action.manageTrustedPublishers',
            title: ( localize2(7504, "Manage Trusted Extension Publishers")),
            category: EXTENSIONS_CATEGORY,
            f1: true,
            run: async (accessor) => {
                const quickInputService = accessor.get(IQuickInputService);
                const extensionManagementService = accessor.get(IWorkbenchExtensionManagementService);
                const trustedPublishers = extensionManagementService.getTrustedPublishers();
                const trustedPublisherItems = ( trustedPublishers.map(publisher => ({
                    id: publisher.publisher,
                    label: publisher.publisherDisplayName,
                    description: publisher.publisher,
                    picked: true,
                }))).sort((a, b) => a.label.localeCompare(b.label));
                const result = await quickInputService.pick(trustedPublisherItems, {
                    canPickMany: true,
                    title: ( localize(7505, "Manage Trusted Extension Publishers")),
                    placeHolder: ( localize(7506, "Choose which publishers to trust")),
                });
                if (result) {
                    const untrustedPublishers = [];
                    for (const { publisher } of trustedPublishers) {
                        if (!( result.some(r => r.id === publisher))) {
                            untrustedPublishers.push(publisher);
                        }
                    }
                    trustedPublishers.filter(publisher => !( result.some(r => r.id === publisher.publisher)));
                    extensionManagementService.untrustPublishers(...untrustedPublishers);
                }
            }
        });
    }
    registerExtensionAction(extensionActionOptions) {
        const menus = extensionActionOptions.menu ? Array.isArray(extensionActionOptions.menu) ? extensionActionOptions.menu : [extensionActionOptions.menu] : [];
        let menusWithOutTitles = [];
        const menusWithTitles = [];
        if (extensionActionOptions.menuTitles) {
            for (let index = 0; index < menus.length; index++) {
                const menu = menus[index];
                const menuTitle = extensionActionOptions.menuTitles[menu.id.id];
                if (menuTitle) {
                    menusWithTitles.push({ id: menu.id, item: { ...menu, command: { id: extensionActionOptions.id, title: menuTitle } } });
                }
                else {
                    menusWithOutTitles.push(menu);
                }
            }
        }
        else {
            menusWithOutTitles = menus;
        }
        const disposables = ( new DisposableStore());
        disposables.add(registerAction2(class extends Action2 {
            constructor() {
                super({
                    ...extensionActionOptions,
                    menu: menusWithOutTitles
                });
            }
            run(accessor, ...args) {
                return extensionActionOptions.run(accessor, ...args);
            }
        }));
        if (menusWithTitles.length) {
            disposables.add(MenuRegistry.appendMenuItems(menusWithTitles));
        }
        return disposables;
    }
};
ExtensionsContributions = ( __decorate([
    ( __param(0, IExtensionManagementService)),
    ( __param(1, IExtensionManagementServerService)),
    ( __param(2, IExtensionGalleryManifestService)),
    ( __param(3, IContextKeyService)),
    ( __param(4, IViewsService)),
    ( __param(5, IExtensionsWorkbenchService)),
    ( __param(6, IWorkbenchExtensionEnablementService)),
    ( __param(7, IInstantiationService)),
    ( __param(8, IDialogService)),
    ( __param(9, ICommandService)),
    ( __param(10, IProductService))
], ExtensionsContributions));
let ExtensionStorageCleaner = class ExtensionStorageCleaner {
    constructor(extensionManagementService, storageService) {
        ExtensionStorageService.removeOutdatedExtensionVersions(extensionManagementService, storageService);
    }
};
ExtensionStorageCleaner = ( __decorate([
    ( __param(0, IExtensionManagementService)),
    ( __param(1, IStorageService))
], ExtensionStorageCleaner));
let TrustedPublishersInitializer = class TrustedPublishersInitializer {
    constructor(extensionManagementService, userDataProfilesService, productService, storageService) {
        const trustedPublishersInitStatusKey = 'trusted-publishers-init-migration';
        if (!storageService.get(trustedPublishersInitStatusKey, StorageScope.APPLICATION)) {
            for (const profile of userDataProfilesService.profiles) {
                extensionManagementService.getInstalled(ExtensionType.User, profile.extensionsResource)
                    .then(async (extensions) => {
                    const trustedPublishers = ( new Map());
                    for (const extension of extensions) {
                        if (!extension.publisherDisplayName) {
                            continue;
                        }
                        const publisher = extension.manifest.publisher.toLowerCase();
                        if (productService.trustedExtensionPublishers?.includes(publisher)
                            || (extension.publisherDisplayName && productService.trustedExtensionPublishers?.includes(extension.publisherDisplayName.toLowerCase()))) {
                            continue;
                        }
                        trustedPublishers.set(publisher, { publisher, publisherDisplayName: extension.publisherDisplayName });
                    }
                    if (trustedPublishers.size) {
                        extensionManagementService.trustPublishers(...( trustedPublishers.values()));
                    }
                    storageService.store(trustedPublishersInitStatusKey, 'true', StorageScope.APPLICATION, StorageTarget.MACHINE);
                });
            }
        }
    }
};
TrustedPublishersInitializer = ( __decorate([
    ( __param(0, IWorkbenchExtensionManagementService)),
    ( __param(1, IUserDataProfilesService)),
    ( __param(2, IProductService)),
    ( __param(3, IStorageService))
], TrustedPublishersInitializer));
let ExtensionToolsContribution = class ExtensionToolsContribution extends Disposable {
    static { this.ID = 'extensions.chat.toolsContribution'; }
    constructor(toolsService, instantiationService) {
        super();
        const searchExtensionsTool = instantiationService.createInstance(SearchExtensionsTool);
        this._register(toolsService.registerTool(SearchExtensionsToolData, searchExtensionsTool));
        this._register(toolsService.vscodeToolSet.addTool(SearchExtensionsToolData));
    }
};
ExtensionToolsContribution = ( __decorate([
    ( __param(0, ILanguageModelToolsService)),
    ( __param(1, IInstantiationService))
], ExtensionToolsContribution));
const workbenchRegistry = ( Registry.as(Extensions$4.Workbench));
workbenchRegistry.registerWorkbenchContribution(ExtensionsContributions, LifecyclePhase.Restored);
workbenchRegistry.registerWorkbenchContribution(StatusUpdater, LifecyclePhase.Eventually);
workbenchRegistry.registerWorkbenchContribution(MaliciousExtensionChecker, LifecyclePhase.Eventually);
workbenchRegistry.registerWorkbenchContribution(KeymapExtensions, LifecyclePhase.Restored);
workbenchRegistry.registerWorkbenchContribution(ExtensionsViewletViewsContribution, LifecyclePhase.Restored);
workbenchRegistry.registerWorkbenchContribution(ExtensionActivationProgress, LifecyclePhase.Eventually);
workbenchRegistry.registerWorkbenchContribution(ExtensionDependencyChecker, LifecyclePhase.Eventually);
workbenchRegistry.registerWorkbenchContribution(ExtensionEnablementWorkspaceTrustTransitionParticipant, LifecyclePhase.Restored);
workbenchRegistry.registerWorkbenchContribution(ExtensionsCompletionItemsProvider, LifecyclePhase.Restored);
workbenchRegistry.registerWorkbenchContribution(UnsupportedExtensionsMigrationContrib, LifecyclePhase.Eventually);
workbenchRegistry.registerWorkbenchContribution(TrustedPublishersInitializer, LifecyclePhase.Eventually);
workbenchRegistry.registerWorkbenchContribution(ExtensionMarketplaceStatusUpdater, LifecyclePhase.Eventually);
if (isWeb) {
    workbenchRegistry.registerWorkbenchContribution(ExtensionStorageCleaner, LifecyclePhase.Eventually);
}
registerWorkbenchContribution2(ExtensionToolsContribution.ID, ExtensionToolsContribution, WorkbenchPhase.AfterRestored);
registerAction2(ShowRuntimeExtensionsAction);
registerAction2(class ExtensionsGallerySignInAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.extensions.actions.gallery.signIn',
            title: ( localize2(7507, 'Sign in to access Extensions Marketplace')),
            menu: {
                id: MenuId.AccountsContext,
                when: ( CONTEXT_EXTENSIONS_GALLERY_STATUS.isEqualTo(ExtensionGalleryManifestStatus.RequiresSignIn))
            },
        });
    }
    run(accessor) {
        return accessor.get(ICommandService).executeCommand(DEFAULT_ACCOUNT_SIGN_IN_COMMAND);
    }
});
( Registry.as(Extensions$5.ConfigurationMigration))
    .registerConfigurationMigrations([{
        key: AutoUpdateConfigurationKey,
        migrateFn: (value, accessor) => {
            if (value === 'onlySelectedExtensions') {
                return { value: false };
            }
            return [];
        }
    }]);

export { CONTEXT_HAS_LOCAL_SERVER, CONTEXT_HAS_REMOTE_SERVER, CONTEXT_HAS_WEB_SERVER, VIEW_CONTAINER };
