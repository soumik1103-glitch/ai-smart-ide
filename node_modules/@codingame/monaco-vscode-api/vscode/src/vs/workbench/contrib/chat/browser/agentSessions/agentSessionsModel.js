
import { __decorate, __param } from '../../../../../../../../external/tslib/tslib.es6.js';
import { ThrottledDelayer } from '../../../../../base/common/async.js';
import { Codicon } from '../../../../../base/common/codicons.js';
import { Emitter } from '../../../../../base/common/event.js';
import { Disposable } from '../../../../../base/common/lifecycle.js';
import { ResourceMap } from '../../../../../base/common/map.js';
import { MarshalledId } from '../../../../../base/common/marshallingIds.js';
import { ThemeIcon } from '../../../../../base/common/themables.js';
import { URI } from '../../../../../base/common/uri.js';
import { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';
import { ILogService } from '../../../../../platform/log/common/log.service.js';
import { StorageScope, StorageTarget } from '../../../../../platform/storage/common/storage.js';
import { IStorageService } from '../../../../../platform/storage/common/storage.service.js';
import { ILifecycleService } from '../../../../services/lifecycle/common/lifecycle.service.js';
import { ChatSessionStatus, isSessionInProgressStatus } from '../../common/chatSessionsService.js';
import { IChatSessionsService } from '../../common/chatSessionsService.service.js';
import { AgentSessionProviders, getAgentSessionProviderName, getAgentSessionProviderIcon } from './agentSessions.js';

var AgentSessionsModel_1, AgentSessionsCache_1;
function hasValidDiff(changes) {
    if (!changes) {
        return false;
    }
    if (changes instanceof Array) {
        return changes.length > 0;
    }
    return changes.files > 0 || changes.insertions > 0 || changes.deletions > 0;
}
function getAgentChangesSummary(changes) {
    if (!changes) {
        return;
    }
    if (!(changes instanceof Array)) {
        return changes;
    }
    let insertions = 0;
    let deletions = 0;
    for (const change of changes) {
        insertions += change.insertions;
        deletions += change.deletions;
    }
    return { files: changes.length, insertions, deletions };
}
function isLocalAgentSessionItem(session) {
    return session.providerType === AgentSessionProviders.Local;
}
function isAgentSession(obj) {
    const session = obj;
    return URI.isUri(session?.resource) && typeof session.setArchived === 'function' && typeof session.setRead === 'function';
}
function isAgentSessionsModel(obj) {
    const sessionsModel = obj;
    return Array.isArray(sessionsModel?.sessions) && typeof sessionsModel?.getSession === 'function';
}
var AgentSessionSection;
(function (AgentSessionSection) {
    AgentSessionSection["InProgress"] = "inProgress";
    AgentSessionSection["Today"] = "today";
    AgentSessionSection["Yesterday"] = "yesterday";
    AgentSessionSection["Week"] = "week";
    AgentSessionSection["Older"] = "older";
    AgentSessionSection["Archived"] = "archived";
})(AgentSessionSection || (AgentSessionSection = {}));
function isAgentSessionSection(obj) {
    const candidate = obj;
    return typeof candidate.section === 'string' && Array.isArray(candidate.sessions);
}
function isMarshalledAgentSessionContext(thing) {
    if (typeof thing === 'object' && thing !== null) {
        const candidate = thing;
        return candidate.$mid === MarshalledId.AgentSessionContext && typeof candidate.session === 'object' && candidate.session !== null;
    }
    return false;
}
let AgentSessionsModel = class AgentSessionsModel extends Disposable {
    static { AgentSessionsModel_1 = this; }
    get sessions() { return Array.from(( this._sessions.values())); }
    constructor(chatSessionsService, lifecycleService, instantiationService, storageService, logService) {
        super();
        this.chatSessionsService = chatSessionsService;
        this.lifecycleService = lifecycleService;
        this.instantiationService = instantiationService;
        this.storageService = storageService;
        this.logService = logService;
        this._onWillResolve = this._register(( new Emitter()));
        this.onWillResolve = this._onWillResolve.event;
        this._onDidResolve = this._register(( new Emitter()));
        this.onDidResolve = this._onDidResolve.event;
        this._onDidChangeSessions = this._register(( new Emitter()));
        this.onDidChangeSessions = this._onDidChangeSessions.event;
        this.resolver = this._register(( new ThrottledDelayer(100)));
        this.providersToResolve = ( new Set());
        this.mapSessionToState = ( new ResourceMap());
        this._sessions = ( new ResourceMap());
        this.cache = this.instantiationService.createInstance(AgentSessionsCache);
        for (const data of this.cache.loadCachedSessions()) {
            const session = this.toAgentSession(data);
            this._sessions.set(session.resource, session);
        }
        this.sessionStates = this.cache.loadSessionStates();
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.chatSessionsService.onDidChangeItemsProviders(({ chatSessionType: provider }) => this.resolve(provider)));
        this._register(this.chatSessionsService.onDidChangeAvailability(() => this.resolve(undefined)));
        this._register(this.chatSessionsService.onDidChangeSessionItems(provider => this.resolve(provider)));
        this._register(this.storageService.onWillSaveState(() => {
            this.cache.saveCachedSessions(Array.from(( this._sessions.values())));
            this.cache.saveSessionStates(this.sessionStates);
        }));
    }
    getSession(resource) {
        return this._sessions.get(resource);
    }
    async resolve(provider) {
        if (Array.isArray(provider)) {
            for (const p of provider) {
                this.providersToResolve.add(p);
            }
        }
        else {
            this.providersToResolve.add(provider);
        }
        return this.resolver.trigger(async (token) => {
            if (token.isCancellationRequested || this.lifecycleService.willShutdown) {
                return;
            }
            try {
                this._onWillResolve.fire();
                return await this.doResolve(token);
            }
            finally {
                this._onDidResolve.fire();
            }
        });
    }
    async doResolve(token) {
        const providersToResolve = Array.from(this.providersToResolve);
        this.providersToResolve.clear();
        this.logService.trace(`[agent sessions] Resolving agent sessions for providers: ${( providersToResolve.map(p => p ?? 'all')).join(', ')}`);
        const mapSessionContributionToType = ( new Map());
        for (const contribution of this.chatSessionsService.getAllChatSessionContributions()) {
            mapSessionContributionToType.set(contribution.type, contribution);
        }
        const resolvedProviders = ( new Set());
        const sessions = ( new ResourceMap());
        for (const provider of this.chatSessionsService.getAllChatSessionItemProviders()) {
            if (!providersToResolve.includes(undefined) && !providersToResolve.includes(provider.chatSessionType)) {
                continue;
            }
            let providerSessions;
            try {
                providerSessions = await provider.provideChatSessionItems(token);
                this.logService.trace(`[agent sessions] Resolved ${providerSessions.length} agent sessions for provider ${provider.chatSessionType}`);
            }
            catch (error) {
                this.logService.error(`Failed to resolve sessions for provider ${provider.chatSessionType}`, error);
                continue;
            }
            resolvedProviders.add(provider.chatSessionType);
            if (token.isCancellationRequested) {
                return;
            }
            for (const session of providerSessions) {
                let icon;
                let providerLabel;
                switch ((provider.chatSessionType)) {
                    case AgentSessionProviders.Local:
                        providerLabel = getAgentSessionProviderName(AgentSessionProviders.Local);
                        icon = getAgentSessionProviderIcon(AgentSessionProviders.Local);
                        break;
                    case AgentSessionProviders.Background:
                        providerLabel = getAgentSessionProviderName(AgentSessionProviders.Background);
                        icon = getAgentSessionProviderIcon(AgentSessionProviders.Background);
                        break;
                    case AgentSessionProviders.Cloud:
                        providerLabel = getAgentSessionProviderName(AgentSessionProviders.Cloud);
                        icon = getAgentSessionProviderIcon(AgentSessionProviders.Cloud);
                        break;
                    default: {
                        providerLabel = mapSessionContributionToType.get(provider.chatSessionType)?.name ?? provider.chatSessionType;
                        icon = session.iconPath ?? Codicon.terminal;
                    }
                }
                const status = session.status ?? ChatSessionStatus.Completed;
                const state = this.mapSessionToState.get(session.resource);
                let inProgressTime = state?.inProgressTime;
                let finishedOrFailedTime = state?.finishedOrFailedTime;
                if (!state) {
                    this.mapSessionToState.set(session.resource, {
                        status,
                        inProgressTime: isSessionInProgressStatus(status) ? Date.now() : undefined,
                    });
                }
                else if (status !== state.status) {
                    inProgressTime = isSessionInProgressStatus(status) ? Date.now() : state.inProgressTime;
                    finishedOrFailedTime = !isSessionInProgressStatus(status) ? Date.now() : state.finishedOrFailedTime;
                    this.mapSessionToState.set(session.resource, {
                        status,
                        inProgressTime,
                        finishedOrFailedTime
                    });
                }
                const changes = session.changes;
                const normalizedChanges = changes && !(changes instanceof Array)
                    ? { files: changes.files, insertions: changes.insertions, deletions: changes.deletions }
                    : changes;
                let startTime = session.timing.startTime;
                let endTime = session.timing.endTime;
                if (!startTime || !endTime) {
                    const existing = this._sessions.get(session.resource);
                    if (!startTime && existing?.timing.startTime) {
                        startTime = existing.timing.startTime;
                    }
                    if (!endTime && existing?.timing.endTime) {
                        endTime = existing.timing.endTime;
                    }
                }
                sessions.set(session.resource, this.toAgentSession({
                    providerType: provider.chatSessionType,
                    providerLabel,
                    resource: session.resource,
                    label: session.label,
                    description: session.description,
                    icon,
                    badge: session.badge,
                    tooltip: session.tooltip,
                    status,
                    archived: session.archived,
                    timing: { startTime, endTime, inProgressTime, finishedOrFailedTime },
                    changes: normalizedChanges,
                }));
            }
        }
        for (const [, session] of this._sessions) {
            if (!( resolvedProviders.has(session.providerType))) {
                sessions.set(session.resource, session);
            }
        }
        this._sessions = sessions;
        this.logService.trace(`[agent sessions] Total resolved agent sessions:`, Array.from(( this._sessions.values())));
        for (const [resource] of this.mapSessionToState) {
            if (!( sessions.has(resource))) {
                this.mapSessionToState.delete(resource);
            }
        }
        for (const [resource] of this.sessionStates) {
            if (!( sessions.has(resource))) {
                this.sessionStates.delete(resource);
            }
        }
        this._onDidChangeSessions.fire();
    }
    toAgentSession(data) {
        return {
            ...data,
            isArchived: () => this.isArchived(data),
            setArchived: (archived) => this.setArchived(data, archived),
            isRead: () => this.isRead(data),
            setRead: (read) => this.setRead(data, read),
        };
    }
    static { this.READ_STATE_INITIAL_DATE = Date.UTC(2025, 11 , 8); }
    isArchived(session) {
        return this.sessionStates.get(session.resource)?.archived ?? Boolean(session.archived);
    }
    setArchived(session, archived) {
        if (archived === this.isArchived(session)) {
            return;
        }
        const state = this.sessionStates.get(session.resource) ?? { archived: false, read: 0 };
        this.sessionStates.set(session.resource, { ...state, archived });
        this._onDidChangeSessions.fire();
    }
    isRead(session) {
        const readDate = this.sessionStates.get(session.resource)?.read;
        return (readDate ?? AgentSessionsModel_1.READ_STATE_INITIAL_DATE) >= (session.timing.endTime ?? session.timing.startTime);
    }
    setRead(session, read) {
        if (read === this.isRead(session)) {
            return;
        }
        const state = this.sessionStates.get(session.resource) ?? { archived: false, read: 0 };
        this.sessionStates.set(session.resource, { ...state, read: read ? Date.now() : 0 });
        this._onDidChangeSessions.fire();
    }
};
AgentSessionsModel = AgentSessionsModel_1 = ( __decorate([
    ( __param(0, IChatSessionsService)),
    ( __param(1, ILifecycleService)),
    ( __param(2, IInstantiationService)),
    ( __param(3, IStorageService)),
    ( __param(4, ILogService))
], AgentSessionsModel));
let AgentSessionsCache = class AgentSessionsCache {
    static { AgentSessionsCache_1 = this; }
    static { this.SESSIONS_STORAGE_KEY = 'agentSessions.model.cache'; }
    static { this.STATE_STORAGE_KEY = 'agentSessions.state.cache'; }
    constructor(storageService) {
        this.storageService = storageService;
    }
    saveCachedSessions(sessions) {
        const serialized = ( sessions.map(session => ({
            providerType: session.providerType,
            providerLabel: session.providerLabel,
            resource: ( session.resource.toString()),
            icon: session.icon.id,
            label: session.label,
            description: session.description,
            badge: session.badge,
            tooltip: session.tooltip,
            status: session.status,
            archived: session.archived,
            timing: {
                startTime: session.timing.startTime,
                endTime: session.timing.endTime,
            },
            changes: session.changes,
        })));
        this.storageService.store(AgentSessionsCache_1.SESSIONS_STORAGE_KEY, JSON.stringify(serialized), StorageScope.WORKSPACE, StorageTarget.MACHINE);
    }
    loadCachedSessions() {
        const sessionsCache = this.storageService.get(AgentSessionsCache_1.SESSIONS_STORAGE_KEY, StorageScope.WORKSPACE);
        if (!sessionsCache) {
            return [];
        }
        try {
            const cached = JSON.parse(sessionsCache);
            return ( cached.map(session => ({
                providerType: session.providerType,
                providerLabel: session.providerLabel,
                resource: typeof session.resource === 'string' ? ( URI.parse(session.resource)) : URI.revive(session.resource),
                icon: ThemeIcon.fromId(session.icon),
                label: session.label,
                description: session.description,
                badge: session.badge,
                tooltip: session.tooltip,
                status: session.status,
                archived: session.archived,
                timing: {
                    startTime: session.timing.startTime,
                    endTime: session.timing.endTime,
                },
                changes: Array.isArray(session.changes) ? ( session.changes.map((change) => ({
                    modifiedUri: URI.revive(change.modifiedUri),
                    originalUri: change.originalUri ? URI.revive(change.originalUri) : undefined,
                    insertions: change.insertions,
                    deletions: change.deletions,
                }))) : session.changes,
            })));
        }
        catch {
            return [];
        }
    }
    saveSessionStates(states) {
        const serialized = ( Array.from(states.entries()).map(([resource, state]) => ({
            resource: ( resource.toString()),
            archived: state.archived,
            read: state.read
        })));
        this.storageService.store(AgentSessionsCache_1.STATE_STORAGE_KEY, JSON.stringify(serialized), StorageScope.WORKSPACE, StorageTarget.MACHINE);
    }
    loadSessionStates() {
        const states = ( new ResourceMap());
        const statesCache = this.storageService.get(AgentSessionsCache_1.STATE_STORAGE_KEY, StorageScope.WORKSPACE);
        if (!statesCache) {
            return states;
        }
        try {
            const cached = JSON.parse(statesCache);
            for (const entry of cached) {
                states.set(typeof entry.resource === 'string' ? ( URI.parse(entry.resource)) : URI.revive(entry.resource), {
                    archived: entry.archived,
                    read: entry.read
                });
            }
        }
        catch {
        }
        return states;
    }
};
AgentSessionsCache = AgentSessionsCache_1 = ( __decorate([
    ( __param(0, IStorageService))
], AgentSessionsCache));

export { AgentSessionSection, ChatSessionStatus as AgentSessionStatus, AgentSessionsModel, getAgentChangesSummary, hasValidDiff, isAgentSession, isAgentSessionSection, isAgentSessionsModel, isLocalAgentSessionItem, isMarshalledAgentSessionContext, isSessionInProgressStatus };
