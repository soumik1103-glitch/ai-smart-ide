
import { findLastIdx } from '../../../../../base/common/arraysFind.js';
import { MarkdownString } from '../../../../../base/common/htmlContent.js';
import { basename } from '../../../../../base/common/resources.js';
import { URI } from '../../../../../base/common/uri.js';
import { isLocation } from '../../../../../editor/common/languages.js';
import { appendMarkdownString, canMergeMarkdownStrings } from '../model/chatModel.js';

const contentRefUrl = 'http://_vscodecontentref_';
function annotateSpecialMarkdownContent(response) {
    let refIdPool = 0;
    const result = [];
    for (const item of response) {
        const previousItemIndex = findLastIdx(result, p => p.kind !== 'textEditGroup' && p.kind !== 'undoStop');
        const previousItem = result[previousItemIndex];
        if (item.kind === 'inlineReference') {
            let label = item.name;
            if (!label) {
                if (URI.isUri(item.inlineReference)) {
                    label = basename(item.inlineReference);
                }
                else if (isLocation(item.inlineReference)) {
                    label = basename(item.inlineReference.uri);
                }
                else {
                    label = item.inlineReference.name;
                }
            }
            const refId = refIdPool++;
            const printUri = ( URI.parse(contentRefUrl)).with({ path: String(refId) });
            const markdownText = `[${label}](${( printUri.toString())})`;
            const annotationMetadata = { [refId]: item };
            if (previousItem?.kind === 'markdownContent') {
                const merged = appendMarkdownString(previousItem.content, ( new MarkdownString(markdownText)));
                result[previousItemIndex] = { ...previousItem, content: merged, inlineReferences: { ...annotationMetadata, ...(previousItem.inlineReferences || {}) } };
            }
            else {
                result.push({ content: ( new MarkdownString(markdownText)), inlineReferences: annotationMetadata, kind: 'markdownContent' });
            }
        }
        else if (item.kind === 'markdownContent' && previousItem?.kind === 'markdownContent' && canMergeMarkdownStrings(previousItem.content, item.content)) {
            const merged = appendMarkdownString(previousItem.content, item.content);
            result[previousItemIndex] = { ...previousItem, content: merged };
        }
        else if (item.kind === 'markdownVuln') {
            const vulnText = encodeURIComponent(JSON.stringify(item.vulnerabilities));
            const markdownText = `<vscode_annotation details='${vulnText}'>${item.content.value}</vscode_annotation>`;
            if (previousItem?.kind === 'markdownContent') {
                const merged = appendMarkdownString(previousItem.content, ( new MarkdownString(markdownText)));
                result[previousItemIndex] = { ...previousItem, content: merged };
            }
            else {
                result.push({ content: ( new MarkdownString(markdownText)), kind: 'markdownContent' });
            }
        }
        else if (item.kind === 'codeblockUri') {
            if (previousItem?.kind === 'markdownContent') {
                const isEditText = item.isEdit ? ` isEdit` : '';
                const markdownText = `<vscode_codeblock_uri${isEditText}>${( item.uri.toString())}</vscode_codeblock_uri>`;
                const merged = appendMarkdownString(previousItem.content, ( new MarkdownString(markdownText)));
                result.splice(previousItemIndex, 1);
                result.push({ ...previousItem, content: merged });
            }
        }
        else {
            result.push(item);
        }
    }
    return result;
}
function annotateVulnerabilitiesInText(response) {
    const result = [];
    for (const item of response) {
        const previousItem = result[result.length - 1];
        if (item.kind === 'markdownContent') {
            if (previousItem?.kind === 'markdownContent') {
                result[result.length - 1] = { content: ( new MarkdownString(
                    previousItem.content.value + item.content.value,
                    { isTrusted: previousItem.content.isTrusted }
                )), kind: 'markdownContent' };
            }
            else {
                result.push(item);
            }
        }
        else if (item.kind === 'markdownVuln') {
            const vulnText = encodeURIComponent(JSON.stringify(item.vulnerabilities));
            const markdownText = `<vscode_annotation details='${vulnText}'>${item.content.value}</vscode_annotation>`;
            if (previousItem?.kind === 'markdownContent') {
                result[result.length - 1] = { content: ( new MarkdownString(
                    previousItem.content.value + markdownText,
                    { isTrusted: previousItem.content.isTrusted }
                )), kind: 'markdownContent' };
            }
            else {
                result.push({ content: ( new MarkdownString(markdownText)), kind: 'markdownContent' });
            }
        }
    }
    return result;
}
function extractCodeblockUrisFromText(text) {
    const match = /<vscode_codeblock_uri( isEdit)?>(.*?)<\/vscode_codeblock_uri>/ms.exec(text);
    if (match) {
        const [all, isEdit, uriString] = match;
        if (uriString) {
            const result = ( URI.parse(uriString));
            const textWithoutResult = text.substring(0, match.index) + text.substring(match.index + all.length);
            return { uri: result, textWithoutResult, isEdit: !!isEdit };
        }
    }
    return undefined;
}
function extractVulnerabilitiesFromText(text) {
    const vulnerabilities = [];
    let newText = text;
    let match;
    while ((match = /<vscode_annotation details='(.*?)'>(.*?)<\/vscode_annotation>/ms.exec(newText)) !== null) {
        const [full, details, content] = match;
        const start = match.index;
        const textBefore = newText.substring(0, start);
        const linesBefore = textBefore.split('\n').length - 1;
        const linesInside = content.split('\n').length - 1;
        const previousNewlineIdx = textBefore.lastIndexOf('\n');
        const startColumn = start - (previousNewlineIdx + 1) + 1;
        const endPreviousNewlineIdx = (textBefore + content).lastIndexOf('\n');
        const endColumn = start + content.length - (endPreviousNewlineIdx + 1) + 1;
        try {
            const vulnDetails = JSON.parse(decodeURIComponent(details));
            vulnDetails.forEach(({ title, description }) => vulnerabilities.push({
                title, description, range: { startLineNumber: linesBefore + 1, startColumn, endLineNumber: linesBefore + linesInside + 1, endColumn }
            }));
        }
        catch (err) {
        }
        newText = newText.substring(0, start) + content + newText.substring(start + full.length);
    }
    return { newText, vulnerabilities };
}

export { annotateSpecialMarkdownContent, annotateVulnerabilitiesInText, contentRefUrl, extractCodeblockUrisFromText, extractVulnerabilitiesFromText };
