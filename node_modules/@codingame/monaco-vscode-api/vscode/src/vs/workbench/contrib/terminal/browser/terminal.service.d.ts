import { Orientation } from "../../../../base/browser/ui/sash/sash.js";
import { Event, DynamicListEventMultiplexer, IDynamicListEventMultiplexer } from "../../../../base/common/event.js";
import { IDisposable } from "../../../../base/common/lifecycle.js";
import { SingleOrMany } from "../../../../base/common/types.js";
import { URI } from "../../../../base/common/uri.js";
import { TerminalCapability, ITerminalCapabilityImplMap } from "../../../../platform/terminal/common/capabilities/capabilities.js";
import { ITerminalBackend, ITerminalLaunchError, TerminalLocation, type IShellLaunchConfig, type ITerminalProfile } from "../../../../platform/terminal/common/terminal.js";
import { GroupIdentifier } from "../../../common/editor.js";
import { EditorInput } from "../../../common/editor/editorInput.js";
import { IEditableData } from "../../../common/views.js";
import { SIDE_GROUP_TYPE, ACTIVE_GROUP_TYPE, AUX_WINDOW_GROUP_TYPE } from "../../../services/editor/common/editorService.js";
import { IStartExtensionTerminalRequest, ITerminalProcessExtHostProxy, IRemoteTerminalAttachTarget, type ITerminalConfiguration, type ITerminalFont } from "../common/terminal.js";
import { ITerminalInstanceHost, ITerminalInstance, IDetachedTerminalInstance, TerminalConnectionState, ITerminalGroup, ICreateTerminalOptions, IDetachedXTermOptions, ITerminalLocationOptions, ITerminalServiceNativeDelegate, type IDeserializedTerminalEditorInput, type TerminalEditorLocation, type IChatTerminalToolProgressPart } from "./terminal.js";
import { TerminalEditorInput } from "./terminalEditorInput.js";
import { IXtermCore } from "./xterm-private.js";
export declare const ITerminalService: import("../../../../platform/instantiation/common/instantiation.js").ServiceIdentifier<ITerminalService>;
export interface ITerminalService extends ITerminalInstanceHost {
    readonly _serviceBrand: undefined;
    /** Gets all terminal instances, including editor, terminal view (group), and background instances. */
    readonly instances: readonly ITerminalInstance[];
    readonly foregroundInstances: readonly ITerminalInstance[];
    /** Gets detached terminal instances created via {@link createDetachedXterm}. */
    readonly detachedInstances: Iterable<IDetachedTerminalInstance>;
    readonly isProcessSupportRegistered: boolean;
    readonly connectionState: TerminalConnectionState;
    readonly whenConnected: Promise<void>;
    /** The number of restored terminal groups on startup. */
    readonly restoredGroupCount: number;
    readonly onDidCreateInstance: Event<ITerminalInstance>;
    readonly onDidChangeInstanceDimensions: Event<ITerminalInstance>;
    readonly onDidRequestStartExtensionTerminal: Event<IStartExtensionTerminalRequest>;
    readonly onDidRegisterProcessSupport: Event<void>;
    readonly onDidChangeConnectionState: Event<void>;
    readonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;
    readonly onAnyInstanceData: Event<{
        instance: ITerminalInstance;
        data: string;
    }>;
    readonly onAnyInstanceDataInput: Event<ITerminalInstance>;
    readonly onAnyInstanceIconChange: Event<{
        instance: ITerminalInstance;
        userInitiated: boolean;
    }>;
    readonly onAnyInstanceMaximumDimensionsChange: Event<ITerminalInstance>;
    readonly onAnyInstancePrimaryStatusChange: Event<ITerminalInstance>;
    readonly onAnyInstanceProcessIdReady: Event<ITerminalInstance>;
    readonly onAnyInstanceSelectionChange: Event<ITerminalInstance>;
    readonly onAnyInstanceTitleChange: Event<ITerminalInstance>;
    readonly onAnyInstanceShellTypeChanged: Event<ITerminalInstance>;
    readonly onAnyInstanceAddedCapabilityType: Event<TerminalCapability>;
    /**
    * Creates a terminal.
    * @param options The options to create the terminal with, when not specified the default
    * profile will be used at the default target.
    */
    createTerminal(options?: ICreateTerminalOptions): Promise<ITerminalInstance>;
    /**
    * Creates and focuses a terminal.
    * @param options The options to create the terminal with, when not specified the default
    * profile will be used at the default target.
    */
    createAndFocusTerminal(options?: ICreateTerminalOptions): Promise<ITerminalInstance>;
    /**
    * Creates a detached xterm instance which is not attached to the DOM or
    * tracked as a terminal instance.
    * @params options The options to create the terminal with
    */
    createDetachedTerminal(options: IDetachedXTermOptions): Promise<IDetachedTerminalInstance>;
    /**
    * Creates a raw terminal instance, this should not be used outside of the terminal part.
    */
    getInstanceFromId(terminalId: number): ITerminalInstance | undefined;
    /**
    * An owner of terminals might be created after reconnection has occurred,
    * so store them to be requested/adopted later
    * @deprecated Use {@link onDidReconnectToSession}
    */
    getReconnectedTerminals(reconnectionOwner: string): ITerminalInstance[] | undefined;
    getActiveOrCreateInstance(options?: {
        acceptsInput?: boolean;
    }): Promise<ITerminalInstance>;
    revealTerminal(source: ITerminalInstance, preserveFocus?: boolean): Promise<void>;
    /**
    * @param instance
    * @param suppressSetActive Do not set the active instance when there is only one terminal
    * @param forceSaveState Used when the window is shutting down and we need to reveal and save hideFromUser terminals
    */
    showBackgroundTerminal(instance: ITerminalInstance, suppressSetActive?: boolean): Promise<void>;
    revealActiveTerminal(preserveFocus?: boolean): Promise<void>;
    moveToEditor(source: ITerminalInstance, group?: GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE | AUX_WINDOW_GROUP_TYPE): void;
    moveIntoNewEditor(source: ITerminalInstance): void;
    moveToTerminalView(source: ITerminalInstance | URI): Promise<void>;
    getPrimaryBackend(): ITerminalBackend | undefined;
    setNextCommandId(id: number, commandLine: string, commandId: string): Promise<void>;
    /**
    * Fire the onActiveTabChanged event, this will trigger the terminal dropdown to be updated,
    * among other things.
    */
    refreshActiveGroup(): void;
    registerProcessSupport(isSupported: boolean): void;
    showProfileQuickPick(type: "setDefault" | "createInstance", cwd?: string | URI): Promise<ITerminalInstance | undefined>;
    setContainers(panelContainer: HTMLElement, terminalContainer: HTMLElement): void;
    requestStartExtensionTerminal(proxy: ITerminalProcessExtHostProxy, cols: number, rows: number): Promise<ITerminalLaunchError | undefined>;
    isAttachedToTerminal(remoteTerm: IRemoteTerminalAttachTarget): boolean;
    safeDisposeTerminal(instance: ITerminalInstance): Promise<void>;
    getDefaultInstanceHost(): ITerminalInstanceHost;
    getInstanceHost(target: ITerminalLocationOptions | undefined): Promise<ITerminalInstanceHost>;
    resolveLocation(location?: ITerminalLocationOptions): Promise<TerminalLocation | undefined>;
    setNativeDelegate(nativeCalls: ITerminalServiceNativeDelegate): void;
    /**
    * Creates an instance event listener that listens to all instances, dynamically adding new
    * instances and removing old instances as needed.
    * @param getEvent Maps the instance to the event.
    */
    createOnInstanceEvent<T>(getEvent: (instance: ITerminalInstance) => Event<T>): DynamicListEventMultiplexer<ITerminalInstance, T>;
    /**
    * Creates a capability event listener that listens to capabilities on all instances,
    * dynamically adding and removing instances and capabilities as needed.
    * @param capabilityId The capability type to listen to an event on.
    * @param getEvent Maps the capability to the event.
    */
    createOnInstanceCapabilityEvent<T extends TerminalCapability, K>(capabilityId: T, getEvent: (capability: ITerminalCapabilityImplMap[T]) => Event<K>): IDynamicListEventMultiplexer<{
        instance: ITerminalInstance;
        data: K;
    }>;
    /**
    * Reveals the terminal and, if provided, scrolls to the command mark.
    * @param resource the terminal resource
    */
    openResource(resource: URI): void;
}
export declare const ITerminalConfigurationService: import("../../../../platform/instantiation/common/instantiation.js").ServiceIdentifier<ITerminalConfigurationService>;
/**
* A service that provides convenient access to the terminal configuration and derived values.
*/
export interface ITerminalConfigurationService {
    readonly _serviceBrand: undefined;
    /**
    * A typed and partially validated representation of the terminal configuration.
    */
    readonly config: Readonly<ITerminalConfiguration>;
    /**
    * The default location for terminals.
    */
    readonly defaultLocation: TerminalLocation;
    /**
    * Fires when something within the terminal configuration changes.
    */
    readonly onConfigChanged: Event<void>;
    setPanelContainer(panelContainer: HTMLElement): void;
    configFontIsMonospace(): boolean;
    getFont(w: Window, xtermCore?: IXtermCore, excludeDimensions?: boolean): ITerminalFont;
}
export declare const ITerminalEditorService: import("../../../../platform/instantiation/common/instantiation.js").ServiceIdentifier<ITerminalEditorService>;
/**
* This service is responsible for integrating with the editor service and managing terminal
* editors.
*/
export interface ITerminalEditorService extends ITerminalInstanceHost {
    readonly _serviceBrand: undefined;
    /** Gets all _terminal editor_ instances. */
    readonly instances: readonly ITerminalInstance[];
    openEditor(instance: ITerminalInstance, editorOptions?: TerminalEditorLocation): Promise<void>;
    detachInstance(instance: ITerminalInstance): void;
    splitInstance(instanceToSplit: ITerminalInstance, shellLaunchConfig?: IShellLaunchConfig): ITerminalInstance;
    revealActiveEditor(preserveFocus?: boolean): Promise<void>;
    resolveResource(instance: ITerminalInstance): URI;
    reviveInput(deserializedInput: IDeserializedTerminalEditorInput): EditorInput;
    getInputFromResource(resource: URI): TerminalEditorInput;
}
export declare const ITerminalEditingService: import("../../../../platform/instantiation/common/instantiation.js").ServiceIdentifier<ITerminalEditingService>;
/**
* A service responsible for managing terminal editing state and functionality. This includes
* tracking which terminal is currently being edited and managing editable data associated with
* terminal instances.
*/
export interface ITerminalEditingService {
    readonly _serviceBrand: undefined;
    /**
    * Get the editable data for a terminal instance.
    * @param instance The terminal instance.
    * @returns The editable data if the instance is editable, undefined otherwise.
    */
    getEditableData(instance: ITerminalInstance): IEditableData | undefined;
    /**
    * Set the editable data for a terminal instance.
    * @param instance The terminal instance.
    * @param data The editable data to set, or null to clear.
    */
    setEditable(instance: ITerminalInstance, data: IEditableData | null): void;
    /**
    * Check if a terminal instance is currently editable.
    * @param instance The terminal instance to check.
    * @returns True if the instance is editable, false otherwise.
    */
    isEditable(instance: ITerminalInstance | undefined): boolean;
    /**
    * Get the terminal instance that is currently being edited.
    * @returns The terminal instance being edited, or undefined if none.
    */
    getEditingTerminal(): ITerminalInstance | undefined;
    /**
    * Set the terminal instance that is currently being edited.
    * @param instance The terminal instance to set as editing, or undefined to clear.
    */
    setEditingTerminal(instance: ITerminalInstance | undefined): void;
}
export declare const ITerminalGroupService: import("../../../../platform/instantiation/common/instantiation.js").ServiceIdentifier<ITerminalGroupService>;
/**
* This service is responsible for managing terminal groups, that is the terminals that are hosted
* within the terminal panel, not in an editor.
*/
export interface ITerminalGroupService extends ITerminalInstanceHost {
    readonly _serviceBrand: undefined;
    /** Gets all _terminal view_ instances, ie. instances contained within terminal groups. */
    readonly instances: readonly ITerminalInstance[];
    readonly groups: readonly ITerminalGroup[];
    activeGroup: ITerminalGroup | undefined;
    readonly activeGroupIndex: number;
    /**
    * Gets or sets the last accessed menu, this is used to select the instance(s) for menu actions.
    */
    lastAccessedMenu: "inline-tab" | "tab-list";
    readonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;
    readonly onDidDisposeGroup: Event<ITerminalGroup>;
    /** Fires when a group is created, disposed of, or shown (in the case of a background group). */
    readonly onDidChangeGroups: Event<void>;
    /** Fires when the panel has been shown and expanded, so has non-zero dimensions. */
    readonly onDidShow: Event<void>;
    readonly onDidChangePanelOrientation: Event<Orientation>;
    createGroup(shellLaunchConfig?: IShellLaunchConfig): ITerminalGroup;
    createGroup(instance?: ITerminalInstance): ITerminalGroup;
    getGroupForInstance(instance: ITerminalInstance): ITerminalGroup | undefined;
    /**
    * Moves a terminal instance's group to the target instance group's position.
    * @param source The source instance to move.
    * @param target The target instance to move the source instance to.
    */
    moveGroup(source: SingleOrMany<ITerminalInstance>, target: ITerminalInstance): void;
    moveGroupToEnd(source: SingleOrMany<ITerminalInstance>): void;
    moveInstance(source: ITerminalInstance, target: ITerminalInstance, side: "before" | "after"): void;
    unsplitInstance(instance: ITerminalInstance): void;
    joinInstances(instances: ITerminalInstance[]): void;
    instanceIsSplit(instance: ITerminalInstance): boolean;
    getGroupLabels(): string[];
    setActiveGroupByIndex(index: number): void;
    setActiveGroupToNext(): void;
    setActiveGroupToPrevious(): void;
    setActiveInstanceByIndex(terminalIndex: number): void;
    setContainer(container: HTMLElement): void;
    showPanel(focus?: boolean): Promise<void>;
    hidePanel(): void;
    focusTabs(): void;
    focusHover(): void;
    updateVisibility(): void;
}
export declare const ITerminalInstanceService: import("../../../../platform/instantiation/common/instantiation.js").ServiceIdentifier<ITerminalInstanceService>;
/**
* A service used to create instances or fetch backends, this services allows services that
* ITerminalService depends on to also create instances.
*
* **This service is intended to only be used within the terminal contrib.**
*/
export interface ITerminalInstanceService {
    readonly _serviceBrand: undefined;
    /**
    * An event that's fired when a terminal instance is created.
    */
    readonly onDidCreateInstance: Event<ITerminalInstance>;
    /**
    * An event that's fired when a new backend is registered.
    */
    readonly onDidRegisterBackend: Event<ITerminalBackend>;
    /**
    * Helper function to convert a shell launch config, a profile or undefined into its equivalent
    * shell launch config.
    * @param shellLaunchConfigOrProfile A shell launch config, a profile or undefined
    * @param cwd A cwd to override.
    */
    convertProfileToShellLaunchConfig(shellLaunchConfigOrProfile?: IShellLaunchConfig | ITerminalProfile, cwd?: string | URI): IShellLaunchConfig;
    /**
    * Create a new terminal instance.
    * @param launchConfig The shell launch config.
    * @param target The target of the terminal.
    */
    createInstance(launchConfig: IShellLaunchConfig, target: TerminalLocation, editorOptions?: TerminalEditorLocation): ITerminalInstance;
    /**
    * Gets the registered backend for a remote authority (undefined = local). This is a convenience
    * method to avoid using the more verbose fetching from the registry.
    * @param remoteAuthority The remote authority of the backend.
    */
    getBackend(remoteAuthority?: string): Promise<ITerminalBackend | undefined>;
    getRegisteredBackends(): IterableIterator<ITerminalBackend>;
    didRegisterBackend(backend: ITerminalBackend): void;
}
export declare const ITerminalChatService: import("../../../../platform/instantiation/common/instantiation.js").ServiceIdentifier<ITerminalChatService>;
export interface ITerminalChatService {
    readonly _serviceBrand: undefined;
    /**
    * Fired when a terminal instance is registered for a tool session id. This can happen after
    * the chat UI first renders, enabling late binding of the focus action.
    */
    readonly onDidRegisterTerminalInstanceWithToolSession: Event<ITerminalInstance>;
    /**
    * Associate a tool session id with a terminal instance. The association is automatically
    * cleared when the instance is disposed.
    */
    registerTerminalInstanceWithToolSession(terminalToolSessionId: string | undefined, instance: ITerminalInstance): void;
    /**
    * Resolve a terminal instance by its tool session id.
    * @param terminalToolSessionId The tool session id provided in toolSpecificData.
    * If no tool session ID is provided, we do nothing.
    */
    getTerminalInstanceByToolSessionId(terminalToolSessionId: string): Promise<ITerminalInstance | undefined>;
    /**
    * Returns the list of terminal instances that have been registered with a tool session id.
    * This is used for surfacing tool-driven/background terminals in UI (eg. quick picks).
    */
    getToolSessionTerminalInstances(hiddenOnly?: boolean): readonly ITerminalInstance[];
    /**
    * Returns the tool session ID for a given terminal instance, if it has been registered.
    * @param instance The terminal instance to look up
    * @returns The tool session ID if found, undefined otherwise
    */
    getToolSessionIdForInstance(instance: ITerminalInstance): string | undefined;
    /**
    * Associate a chat session ID with a terminal instance. This is used to retrieve the chat
    * session title for display purposes.
    * @param chatSessionId The chat session ID
    * @param instance The terminal instance
    */
    registerTerminalInstanceWithChatSession(chatSessionId: string, instance: ITerminalInstance): void;
    /**
    * Returns the chat session ID for a given terminal instance, if it has been registered.
    * @param instance The terminal instance to look up
    * @returns The chat session ID if found, undefined otherwise
    */
    getChatSessionIdForInstance(instance: ITerminalInstance): string | undefined;
    /**
    * Check if a terminal is a background terminal (tool-driven terminal that may be hidden from
    * normal UI).
    * @param terminalToolSessionId The tool session ID to check, if provided
    * @returns True if the terminal is a background terminal, false otherwise
    */
    isBackgroundTerminal(terminalToolSessionId?: string): boolean;
    /**
    * Register a chat terminal tool progress part for tracking and focus management.
    * @param part The progress part to register
    * @returns A disposable that unregisters the progress part when disposed
    */
    registerProgressPart(part: IChatTerminalToolProgressPart): IDisposable;
    /**
    * Set the currently focused progress part.
    * @param part The progress part to focus
    */
    setFocusedProgressPart(part: IChatTerminalToolProgressPart): void;
    /**
    * Clear the focused state from a progress part.
    * @param part The progress part to clear focus from
    */
    clearFocusedProgressPart(part: IChatTerminalToolProgressPart): void;
    /**
    * Get the currently focused progress part, if any.
    * @returns The focused progress part or undefined if none is focused
    */
    getFocusedProgressPart(): IChatTerminalToolProgressPart | undefined;
    /**
    * Get the most recently registered progress part, if any.
    * @returns The most recent progress part or undefined if none exist
    */
    getMostRecentProgressPart(): IChatTerminalToolProgressPart | undefined;
    /**
    * Enable or disable auto approval for all commands in a specific session.
    * @param chatSessionId The chat session ID
    * @param enabled Whether to enable or disable session auto approval
    */
    setChatSessionAutoApproval(chatSessionId: string, enabled: boolean): void;
    /**
    * Check if a session has auto approval enabled for all commands.
    * @param chatSessionId The chat session ID
    * @returns True if the session has auto approval enabled
    */
    hasChatSessionAutoApproval(chatSessionId: string): boolean;
    /**
    * Add a session-scoped auto-approve rule.
    * @param chatSessionId The chat session ID to associate the rule with
    * @param key The rule key (command or regex pattern)
    * @param value The rule value (approval boolean or object with approve and matchCommandLine)
    */
    addSessionAutoApproveRule(chatSessionId: string, key: string, value: boolean | {
        approve: boolean;
        matchCommandLine?: boolean;
    }): void;
    /**
    * Get all session-scoped auto-approve rules for a specific chat session.
    * @param chatSessionId The chat session ID to get rules for
    * @returns A record of all session-scoped auto-approve rules for the session
    */
    getSessionAutoApproveRules(chatSessionId: string): Readonly<Record<string, boolean | {
        approve: boolean;
        matchCommandLine?: boolean;
    }>>;
}
