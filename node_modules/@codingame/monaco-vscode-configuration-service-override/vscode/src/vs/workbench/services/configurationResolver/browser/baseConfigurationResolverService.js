
import { Queue } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { Iterable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/iterator';
import { LRUCache } from '@codingame/monaco-vscode-api/vscode/vs/base/common/map';
import { Schemas } from '@codingame/monaco-vscode-api/vscode/vs/base/common/network';
import { isUndefinedOrNull, isString } from '@codingame/monaco-vscode-api/vscode/vs/base/common/types';
import { isCodeEditor, isDiffEditor } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/editorBrowser';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { ConfigurationTarget } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration';
import { StorageScope, StorageTarget } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage';
import { EditorResourceAccessor, SideBySideEditor } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor';
import { VariableError, VariableKind } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/configurationResolver/common/configurationResolver';
import { ConfigurationResolverExpression } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/configurationResolver/common/configurationResolverExpression';
import { AbstractVariableResolverService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/configurationResolver/common/variableResolver';

const LAST_INPUT_STORAGE_KEY = 'configResolveInputLru';
const LAST_INPUT_CACHE_SIZE = 5;
class BaseConfigurationResolverService extends AbstractVariableResolverService {
    static { this.INPUT_OR_COMMAND_VARIABLES_PATTERN = /\${((input|command):(.*?))}/g; }
    constructor(context, envVariablesPromise, editorService, configurationService, commandService, workspaceContextService, quickInputService, labelService, pathService, extensionService, storageService) {
        super({
            getFolderUri: (folderName) => {
                const folder = workspaceContextService.getWorkspace().folders.filter(f => f.name === folderName).pop();
                return folder ? folder.uri : undefined;
            },
            getWorkspaceFolderCount: () => {
                return workspaceContextService.getWorkspace().folders.length;
            },
            getConfigurationValue: (folderUri, section) => {
                return configurationService.getValue(section, folderUri ? { resource: folderUri } : {});
            },
            getAppRoot: () => {
                return context.getAppRoot();
            },
            getExecPath: () => {
                return context.getExecPath();
            },
            getFilePath: () => {
                const fileResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, {
                    supportSideBySide: SideBySideEditor.PRIMARY,
                    filterByScheme: [Schemas.file, Schemas.vscodeUserData, this.pathService.defaultUriScheme]
                });
                if (!fileResource) {
                    return undefined;
                }
                return this.labelService.getUriLabel(fileResource, { noPrefix: true });
            },
            getWorkspaceFolderPathForFile: () => {
                const fileResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, {
                    supportSideBySide: SideBySideEditor.PRIMARY,
                    filterByScheme: [Schemas.file, Schemas.vscodeUserData, this.pathService.defaultUriScheme]
                });
                if (!fileResource) {
                    return undefined;
                }
                const wsFolder = workspaceContextService.getWorkspaceFolder(fileResource);
                if (!wsFolder) {
                    return undefined;
                }
                return this.labelService.getUriLabel(wsFolder.uri, { noPrefix: true });
            },
            getSelectedText: () => {
                const activeTextEditorControl = editorService.activeTextEditorControl;
                let activeControl = null;
                if (isCodeEditor(activeTextEditorControl)) {
                    activeControl = activeTextEditorControl;
                }
                else if (isDiffEditor(activeTextEditorControl)) {
                    const original = activeTextEditorControl.getOriginalEditor();
                    const modified = activeTextEditorControl.getModifiedEditor();
                    activeControl = original.hasWidgetFocus() ? original : modified;
                }
                const activeModel = activeControl?.getModel();
                const activeSelection = activeControl?.getSelection();
                if (activeModel && activeSelection) {
                    return activeModel.getValueInRange(activeSelection);
                }
                return undefined;
            },
            getLineNumber: () => {
                const activeTextEditorControl = editorService.activeTextEditorControl;
                if (isCodeEditor(activeTextEditorControl)) {
                    const selection = activeTextEditorControl.getSelection();
                    if (selection) {
                        const lineNumber = selection.positionLineNumber;
                        return String(lineNumber);
                    }
                }
                return undefined;
            },
            getColumnNumber: () => {
                const activeTextEditorControl = editorService.activeTextEditorControl;
                if (isCodeEditor(activeTextEditorControl)) {
                    const selection = activeTextEditorControl.getSelection();
                    if (selection) {
                        const columnNumber = selection.positionColumn;
                        return String(columnNumber);
                    }
                }
                return undefined;
            },
            getExtension: id => {
                return extensionService.getExtension(id);
            },
        }, labelService, pathService.userHome().then(home => home.path), envVariablesPromise);
        this.configurationService = configurationService;
        this.commandService = commandService;
        this.quickInputService = quickInputService;
        this.labelService = labelService;
        this.pathService = pathService;
        this.storageService = storageService;
        this.userInputAccessQueue = ( new Queue());
        this.resolvableVariables.add('command');
        this.resolvableVariables.add('input');
    }
    async resolveWithInteractionReplace(folder, config, section, variables, target) {
        const parsed = ConfigurationResolverExpression.parse(config);
        await this.resolveWithInteraction(folder, parsed, section, variables, target);
        return parsed.toObject();
    }
    async resolveWithInteraction(folder, config, section, variableToCommandMap, target) {
        const expr = ConfigurationResolverExpression.parse(config);
        for (const variable of expr.unresolved()) {
            let result;
            if (variable.name === 'command') {
                const commandId = (variableToCommandMap ? variableToCommandMap[variable.arg] : undefined) || variable.arg;
                const value = await this.commandService.executeCommand(commandId, expr.toObject());
                if (!isUndefinedOrNull(value)) {
                    if (typeof value !== 'string') {
                        throw ( new VariableError(VariableKind.Command, ( localize(
                            13801,
                            "Cannot substitute command variable '{0}' because command did not return a result of type string.",
                            commandId
                        ))));
                    }
                    result = { value };
                }
            }
            else if (variable.name === 'input') {
                result = await this.showUserInput(section, variable.arg, await this.resolveInputs(folder, section, target), variableToCommandMap);
            }
            else if (( this._contributedVariables.has(variable.inner))) {
                result = { value: await this._contributedVariables.get(variable.inner)() };
            }
            else {
                const resolvedValue = await this.evaluateSingleVariable(variable, folder?.uri);
                if (resolvedValue === undefined) {
                    continue;
                }
                result = typeof resolvedValue === 'string' ? { value: resolvedValue } : resolvedValue;
            }
            if (result === undefined) {
                return undefined;
            }
            expr.resolve(variable, result);
        }
        return ( new Map(( Iterable.map(expr.resolved(), ([key, value]) => [key.inner, value.value]))));
    }
    async resolveInputs(folder, section, target) {
        if (!section) {
            return undefined;
        }
        let inputs;
        const overrides = folder ? { resource: folder.uri } : {};
        const result = this.configurationService.inspect(section, overrides);
        if (result) {
            switch (target) {
                case ConfigurationTarget.MEMORY:
                    inputs = result.memoryValue?.inputs;
                    break;
                case ConfigurationTarget.DEFAULT:
                    inputs = result.defaultValue?.inputs;
                    break;
                case ConfigurationTarget.USER:
                    inputs = result.userValue?.inputs;
                    break;
                case ConfigurationTarget.USER_LOCAL:
                    inputs = result.userLocalValue?.inputs;
                    break;
                case ConfigurationTarget.USER_REMOTE:
                    inputs = result.userRemoteValue?.inputs;
                    break;
                case ConfigurationTarget.APPLICATION:
                    inputs = result.applicationValue?.inputs;
                    break;
                case ConfigurationTarget.WORKSPACE:
                    inputs = result.workspaceValue?.inputs;
                    break;
                case ConfigurationTarget.WORKSPACE_FOLDER:
                default:
                    inputs = result.workspaceFolderValue?.inputs;
                    break;
            }
        }
        inputs ??= this.configurationService.getValue(section, overrides)?.inputs;
        return inputs;
    }
    readInputLru() {
        const contents = this.storageService.get(LAST_INPUT_STORAGE_KEY, StorageScope.WORKSPACE);
        const lru = ( new LRUCache(LAST_INPUT_CACHE_SIZE));
        try {
            if (contents) {
                lru.fromJSON(JSON.parse(contents));
            }
        }
        catch {
        }
        return lru;
    }
    storeInputLru(lru) {
        this.storageService.store(LAST_INPUT_STORAGE_KEY, JSON.stringify(lru.toJSON()), StorageScope.WORKSPACE, StorageTarget.MACHINE);
    }
    async showUserInput(section, variable, inputInfos, variableToCommandMap) {
        if (!inputInfos) {
            throw ( new VariableError(VariableKind.Input, ( localize(
                13802,
                "Variable '{0}' must be defined in an '{1}' section of the debug or task configuration.",
                variable,
                'inputs'
            ))));
        }
        const info = inputInfos.filter(item => item.id === variable).pop();
        if (info) {
            const missingAttribute = (attrName) => {
                throw ( new VariableError(VariableKind.Input, ( localize(
                    13803,
                    "Input variable '{0}' is of type '{1}' and must include '{2}'.",
                    variable,
                    info.type,
                    attrName
                ))));
            };
            const defaultValueMap = this.readInputLru();
            const defaultValueKey = `${section}.${variable}`;
            const previousPickedValue = defaultValueMap.get(defaultValueKey);
            switch (info.type) {
                case 'promptString': {
                    if (!isString(info.description)) {
                        missingAttribute('description');
                    }
                    const inputOptions = { prompt: info.description, ignoreFocusLost: true, value: variableToCommandMap?.[`input:${variable}`] ?? previousPickedValue ?? info.default };
                    if (info.password) {
                        inputOptions.password = info.password;
                    }
                    return this.userInputAccessQueue.queue(() => this.quickInputService.input(inputOptions)).then(resolvedInput => {
                        if (typeof resolvedInput === 'string' && !info.password) {
                            this.storeInputLru(defaultValueMap.set(defaultValueKey, resolvedInput));
                        }
                        return resolvedInput !== undefined ? { value: resolvedInput, input: info } : undefined;
                    });
                }
                case 'pickString': {
                    if (!isString(info.description)) {
                        missingAttribute('description');
                    }
                    if (Array.isArray(info.options)) {
                        for (const pickOption of info.options) {
                            if (!isString(pickOption) && !isString(pickOption.value)) {
                                missingAttribute('value');
                            }
                        }
                    }
                    else {
                        missingAttribute('options');
                    }
                    const picks = ( new Array());
                    for (const pickOption of info.options) {
                        const value = isString(pickOption) ? pickOption : pickOption.value;
                        const label = isString(pickOption) ? undefined : pickOption.label;
                        const item = {
                            label: label ? `${label}: ${value}` : value,
                            value: value
                        };
                        const topValue = variableToCommandMap?.[`input:${variable}`] ?? previousPickedValue ?? info.default;
                        if (value === info.default) {
                            item.description = ( localize(13804, "(Default)"));
                            picks.unshift(item);
                        }
                        else if (value === topValue) {
                            picks.unshift(item);
                        }
                        else {
                            picks.push(item);
                        }
                    }
                    const pickOptions = { placeHolder: info.description, matchOnDetail: true, ignoreFocusLost: true };
                    return this.userInputAccessQueue.queue(() => this.quickInputService.pick(picks, pickOptions, undefined)).then(resolvedInput => {
                        if (resolvedInput) {
                            const value = resolvedInput.value;
                            this.storeInputLru(defaultValueMap.set(defaultValueKey, value));
                            return { value, input: info };
                        }
                        return undefined;
                    });
                }
                case 'command': {
                    if (!isString(info.command)) {
                        missingAttribute('command');
                    }
                    return this.userInputAccessQueue.queue(() => this.commandService.executeCommand(info.command, info.args)).then(result => {
                        if (typeof result === 'string' || isUndefinedOrNull(result)) {
                            return { value: result, input: info };
                        }
                        throw ( new VariableError(VariableKind.Input, ( localize(
                            13805,
                            "Cannot substitute input variable '{0}' because command '{1}' did not return a result of type string.",
                            variable,
                            info.command
                        ))));
                    });
                }
                default:
                    throw ( new VariableError(VariableKind.Input, ( localize(
                        13806,
                        "Input variable '{0}' can only be of type 'promptString', 'pickString', or 'command'.",
                        variable
                    ))));
            }
        }
        throw ( new VariableError(VariableKind.Input, ( localize(
            13807,
            "Undefined input variable '{0}' encountered. Remove or define '{0}' to continue.",
            variable
        ))));
    }
}

export { BaseConfigurationResolverService };
