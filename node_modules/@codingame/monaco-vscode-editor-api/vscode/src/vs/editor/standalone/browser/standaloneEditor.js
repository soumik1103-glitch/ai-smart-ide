
import { registerCss } from '@codingame/monaco-vscode-api/css';
import { mainWindow } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/window';
import { DisposableStore, Disposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { splitLines } from '@codingame/monaco-vscode-api/vscode/vs/base/common/strings';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import * as standaloneTokens from './standalone-tokens.css';
import { FontMeasurements } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/config/fontMeasurements';
import { EditorCommand } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/editorExtensions';
import { ICodeEditorService } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/services/codeEditorService.service';
import { createWebWorker as createWebWorker$1 } from './standaloneWebWorker.js';
import { EditorOptions, ApplyUpdateResult, ConfigurationChangedEvent } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/config/editorOptions';
import { EditorZoom } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/config/editorZoom';
import { FontInfo, BareFontInfo } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/config/fontInfo';
import { EditorType } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/editorCommon';
import { TokenizationRegistry } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages';
import { ILanguageService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages/language.service';
import { PLAINTEXT_LANGUAGE_ID } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages/modesRegistry';
import { NullState, nullTokenize } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages/nullTokenize';
import { FindMatch, TextModelResolvedOptions } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/model';
import { IModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/model.service';
import { TextDirection, ShowLightbulbIconMode, PositionAffinity, InjectedTextCursorStops, WrappingIndent, TrackedRangeStickiness, TextEditorCursorStyle, TextEditorCursorBlinkingStyle, ScrollType, ScrollbarVisibility, RenderMinimap, RenderLineNumbersType, GlyphMarginLane, OverviewRulerLane, OverlayWidgetPositionPreference, MouseTargetType, MinimapSectionHeaderStyle, MinimapPosition, EndOfLineSequence, EndOfLinePreference, EditorOption, EditorAutoIndentStrategy, DefaultEndOfLine, CursorChangeReason, ContentWidgetPositionPreference, AccessibilitySupport } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/standalone/standaloneEnums';
import { Colorizer } from './colorizer.js';
import { StandaloneEditor, StandaloneDiffEditor2, createTextModel } from '@codingame/monaco-vscode-api/vscode/vs/editor/standalone/browser/standaloneCodeEditor';
import { StandaloneServices, StandaloneKeybindingService } from '@codingame/monaco-vscode-api/vscode/vs/editor/standalone/browser/standaloneServices';
import { IStandaloneThemeService } from '@codingame/monaco-vscode-api/vscode/vs/editor/standalone/common/standaloneTheme.service';
import { MenuRegistry, MenuId } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { CommandsRegistry } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands';
import { ContextKeyExpr } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { IKeybindingService } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybinding.service';
import { IMarkerService } from '@codingame/monaco-vscode-api/vscode/vs/platform/markers/common/markers.service';
import { IOpenerService } from '@codingame/monaco-vscode-api/vscode/vs/platform/opener/common/opener.service';
import { MultiDiffEditorWidget } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/widget/multiDiffEditor/multiDiffEditorWidget';
import { IWebWorkerService } from '@codingame/monaco-vscode-api/vscode/vs/platform/webWorker/browser/webWorkerService.service';

registerCss(standaloneTokens);
function create(domElement, options, override) {
    const instantiationService = StandaloneServices.initialize(override || {});
    return instantiationService.createInstance(StandaloneEditor, domElement, options);
}
function onDidCreateEditor(listener) {
    const codeEditorService = StandaloneServices.get(ICodeEditorService);
    return codeEditorService.onCodeEditorAdd((editor) => {
        listener(editor);
    });
}
function onDidCreateDiffEditor(listener) {
    const codeEditorService = StandaloneServices.get(ICodeEditorService);
    return codeEditorService.onDiffEditorAdd((editor) => {
        listener(editor);
    });
}
function getEditors() {
    const codeEditorService = StandaloneServices.get(ICodeEditorService);
    return codeEditorService.listCodeEditors();
}
function getDiffEditors() {
    const codeEditorService = StandaloneServices.get(ICodeEditorService);
    return codeEditorService.listDiffEditors();
}
function createDiffEditor(domElement, options, override) {
    const instantiationService = StandaloneServices.initialize(override || {});
    return instantiationService.createInstance(StandaloneDiffEditor2, domElement, options);
}
function createMultiFileDiffEditor(domElement, override) {
    const instantiationService = StandaloneServices.initialize(override || {});
    return ( new MultiDiffEditorWidget(domElement, {}, instantiationService));
}
function addCommand(descriptor) {
    if ((typeof descriptor.id !== 'string') || (typeof descriptor.run !== 'function')) {
        throw ( new Error('Invalid command descriptor, `id` and `run` are required properties!'));
    }
    return CommandsRegistry.registerCommand(descriptor.id, descriptor.run);
}
function addEditorAction(descriptor) {
    if ((typeof descriptor.id !== 'string') || (typeof descriptor.label !== 'string') || (typeof descriptor.run !== 'function')) {
        throw ( new Error(
            'Invalid action descriptor, `id`, `label` and `run` are required properties!'
        ));
    }
    const precondition = ContextKeyExpr.deserialize(descriptor.precondition);
    const run = (accessor, ...args) => {
        return EditorCommand.runEditorCommand(accessor, args, precondition, (accessor, editor, args) => Promise.resolve(descriptor.run(editor, ...args)));
    };
    const toDispose = ( new DisposableStore());
    toDispose.add(CommandsRegistry.registerCommand(descriptor.id, run));
    if (descriptor.contextMenuGroupId) {
        const menuItem = {
            command: {
                id: descriptor.id,
                title: descriptor.label
            },
            when: precondition,
            group: descriptor.contextMenuGroupId,
            order: descriptor.contextMenuOrder || 0
        };
        toDispose.add(MenuRegistry.appendMenuItem(MenuId.EditorContext, menuItem));
    }
    if (Array.isArray(descriptor.keybindings)) {
        const keybindingService = StandaloneServices.get(IKeybindingService);
        if (!(keybindingService instanceof StandaloneKeybindingService)) {
            console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');
        }
        else {
            const keybindingsWhen = ( ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(descriptor.keybindingContext)));
            toDispose.add(keybindingService.addDynamicKeybindings(( descriptor.keybindings.map((keybinding) => {
                return {
                    keybinding,
                    command: descriptor.id,
                    when: keybindingsWhen
                };
            }))));
        }
    }
    return toDispose;
}
function addKeybindingRule(rule) {
    return addKeybindingRules([rule]);
}
function addKeybindingRules(rules) {
    const keybindingService = StandaloneServices.get(IKeybindingService);
    if (!(keybindingService instanceof StandaloneKeybindingService)) {
        console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');
        return Disposable.None;
    }
    return keybindingService.addDynamicKeybindings(( rules.map((rule) => {
        return {
            keybinding: rule.keybinding,
            command: rule.command,
            commandArgs: rule.commandArgs,
            when: ContextKeyExpr.deserialize(rule.when),
        };
    })));
}
function createModel(value, language, uri) {
    const languageService = StandaloneServices.get(ILanguageService);
    const languageId = languageService.getLanguageIdByMimeType(language) || language;
    return createTextModel(StandaloneServices.get(IModelService), languageService, value, languageId, uri);
}
function setModelLanguage(model, mimeTypeOrLanguageId) {
    const languageService = StandaloneServices.get(ILanguageService);
    const languageId = languageService.getLanguageIdByMimeType(mimeTypeOrLanguageId) || mimeTypeOrLanguageId || PLAINTEXT_LANGUAGE_ID;
    model.setLanguage(languageService.createById(languageId));
}
function setModelMarkers(model, owner, markers) {
    if (model) {
        const markerService = StandaloneServices.get(IMarkerService);
        markerService.changeOne(owner, model.uri, markers);
    }
}
function removeAllMarkers(owner) {
    const markerService = StandaloneServices.get(IMarkerService);
    markerService.changeAll(owner, []);
}
function getModelMarkers(filter) {
    const markerService = StandaloneServices.get(IMarkerService);
    return markerService.read(filter);
}
function onDidChangeMarkers(listener) {
    const markerService = StandaloneServices.get(IMarkerService);
    return markerService.onMarkerChanged(listener);
}
function getModel(uri) {
    const modelService = StandaloneServices.get(IModelService);
    return modelService.getModel(uri);
}
function getModels() {
    const modelService = StandaloneServices.get(IModelService);
    return modelService.getModels();
}
function onDidCreateModel(listener) {
    const modelService = StandaloneServices.get(IModelService);
    return modelService.onModelAdded(listener);
}
function onWillDisposeModel(listener) {
    const modelService = StandaloneServices.get(IModelService);
    return modelService.onModelRemoved(listener);
}
function onDidChangeModelLanguage(listener) {
    const modelService = StandaloneServices.get(IModelService);
    return modelService.onModelLanguageChanged((e) => {
        listener({
            model: e.model,
            oldLanguage: e.oldLanguageId
        });
    });
}
function createWebWorker(opts) {
    return createWebWorker$1(StandaloneServices.get(IModelService), StandaloneServices.get(IWebWorkerService), opts);
}
function colorizeElement(domNode, options) {
    const languageService = StandaloneServices.get(ILanguageService);
    const themeService = StandaloneServices.get(IStandaloneThemeService);
    return Colorizer.colorizeElement(themeService, languageService, domNode, options).then(() => {
        themeService.registerEditorContainer(domNode);
    });
}
function colorize(text, languageId, options) {
    const languageService = StandaloneServices.get(ILanguageService);
    const themeService = StandaloneServices.get(IStandaloneThemeService);
    themeService.registerEditorContainer(mainWindow.document.body);
    return Colorizer.colorize(languageService, text, languageId, options);
}
function colorizeModelLine(model, lineNumber, tabSize = 4) {
    const themeService = StandaloneServices.get(IStandaloneThemeService);
    themeService.registerEditorContainer(mainWindow.document.body);
    return Colorizer.colorizeModelLine(model, lineNumber, tabSize);
}
function getSafeTokenizationSupport(language) {
    const tokenizationSupport = TokenizationRegistry.get(language);
    if (tokenizationSupport) {
        return tokenizationSupport;
    }
    return {
        getInitialState: () => NullState,
        tokenize: (line, hasEOL, state) => nullTokenize(language, state)
    };
}
function tokenize(text, languageId) {
    TokenizationRegistry.getOrCreate(languageId);
    const tokenizationSupport = getSafeTokenizationSupport(languageId);
    const lines = splitLines(text);
    const result = [];
    let state = tokenizationSupport.getInitialState();
    for (let i = 0, len = lines.length; i < len; i++) {
        const line = lines[i];
        const tokenizationResult = tokenizationSupport.tokenize(line, true, state);
        result[i] = tokenizationResult.tokens;
        state = tokenizationResult.endState;
    }
    return result;
}
function defineTheme(themeName, themeData) {
    const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);
    standaloneThemeService.defineTheme(themeName, themeData);
}
function setTheme(themeName) {
    const standaloneThemeService = StandaloneServices.get(IStandaloneThemeService);
    standaloneThemeService.setTheme(themeName);
}
function remeasureFonts() {
    FontMeasurements.clearAllFontInfos();
}
function registerCommand(id, handler) {
    return CommandsRegistry.registerCommand({ id, handler });
}
function registerLinkOpener(opener) {
    const openerService = StandaloneServices.get(IOpenerService);
    return openerService.registerOpener({
        async open(resource) {
            if (typeof resource === 'string') {
                resource = ( URI.parse(resource));
            }
            return opener.open(resource);
        }
    });
}
function registerEditorOpener(opener) {
    const codeEditorService = StandaloneServices.get(ICodeEditorService);
    return codeEditorService.registerCodeEditorOpenHandler(async (input, source, sideBySide) => {
        if (!source) {
            return null;
        }
        const selection = input.options?.selection;
        let selectionOrPosition;
        if (selection && typeof selection.endLineNumber === 'number' && typeof selection.endColumn === 'number') {
            selectionOrPosition = selection;
        }
        else if (selection) {
            selectionOrPosition = { lineNumber: selection.startLineNumber, column: selection.startColumn };
        }
        if (await opener.openCodeEditor(source, input.resource, selectionOrPosition)) {
            return source;
        }
        return null;
    });
}
function createMonacoEditorAPI() {
    return {
        create: create,
        getEditors: getEditors,
        getDiffEditors: getDiffEditors,
        onDidCreateEditor: onDidCreateEditor,
        onDidCreateDiffEditor: onDidCreateDiffEditor,
        createDiffEditor: createDiffEditor,
        addCommand: addCommand,
        addEditorAction: addEditorAction,
        addKeybindingRule: addKeybindingRule,
        addKeybindingRules: addKeybindingRules,
        createModel: createModel,
        setModelLanguage: setModelLanguage,
        setModelMarkers: setModelMarkers,
        getModelMarkers: getModelMarkers,
        removeAllMarkers: removeAllMarkers,
        onDidChangeMarkers: onDidChangeMarkers,
        getModels: getModels,
        getModel: getModel,
        onDidCreateModel: onDidCreateModel,
        onWillDisposeModel: onWillDisposeModel,
        onDidChangeModelLanguage: onDidChangeModelLanguage,
        createWebWorker: createWebWorker,
        colorizeElement: colorizeElement,
        colorize: colorize,
        colorizeModelLine: colorizeModelLine,
        tokenize: tokenize,
        defineTheme: defineTheme,
        setTheme: setTheme,
        remeasureFonts: remeasureFonts,
        registerCommand: registerCommand,
        registerLinkOpener: registerLinkOpener,
        registerEditorOpener: registerEditorOpener,
        AccessibilitySupport: AccessibilitySupport,
        ContentWidgetPositionPreference: ContentWidgetPositionPreference,
        CursorChangeReason: CursorChangeReason,
        DefaultEndOfLine: DefaultEndOfLine,
        EditorAutoIndentStrategy: EditorAutoIndentStrategy,
        EditorOption: EditorOption,
        EndOfLinePreference: EndOfLinePreference,
        EndOfLineSequence: EndOfLineSequence,
        MinimapPosition: MinimapPosition,
        MinimapSectionHeaderStyle: MinimapSectionHeaderStyle,
        MouseTargetType: MouseTargetType,
        OverlayWidgetPositionPreference: OverlayWidgetPositionPreference,
        OverviewRulerLane: OverviewRulerLane,
        GlyphMarginLane: GlyphMarginLane,
        RenderLineNumbersType: RenderLineNumbersType,
        RenderMinimap: RenderMinimap,
        ScrollbarVisibility: ScrollbarVisibility,
        ScrollType: ScrollType,
        TextEditorCursorBlinkingStyle: TextEditorCursorBlinkingStyle,
        TextEditorCursorStyle: TextEditorCursorStyle,
        TrackedRangeStickiness: TrackedRangeStickiness,
        WrappingIndent: WrappingIndent,
        InjectedTextCursorStops: InjectedTextCursorStops,
        PositionAffinity: PositionAffinity,
        ShowLightbulbIconMode: ShowLightbulbIconMode,
        TextDirection: TextDirection,
        ConfigurationChangedEvent: ConfigurationChangedEvent,
        BareFontInfo: BareFontInfo,
        FontInfo: FontInfo,
        TextModelResolvedOptions: TextModelResolvedOptions,
        FindMatch: FindMatch,
        ApplyUpdateResult: ApplyUpdateResult,
        EditorZoom: EditorZoom,
        createMultiFileDiffEditor: createMultiFileDiffEditor,
        EditorType: EditorType,
        EditorOptions: EditorOptions
    };
}

export { addCommand, addEditorAction, addKeybindingRule, addKeybindingRules, colorize, colorizeElement, colorizeModelLine, create, createDiffEditor, createModel, createMonacoEditorAPI, createMultiFileDiffEditor, createWebWorker, defineTheme, getDiffEditors, getEditors, getModel, getModelMarkers, getModels, onDidChangeMarkers, onDidChangeModelLanguage, onDidCreateDiffEditor, onDidCreateEditor, onDidCreateModel, onWillDisposeModel, registerCommand, registerEditorOpener, registerLinkOpener, remeasureFonts, removeAllMarkers, setModelLanguage, setModelMarkers, setTheme, tokenize };
