
import { createTrustedTypesPolicy } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/trustedTypes';
import { startsWithUTF8BOM, splitLines } from '@codingame/monaco-vscode-api/vscode/vs/base/common/strings';
import { FontStyle, MetadataConsts, ColorId } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/encodedTokenAttributes';
import { TokenizationRegistry } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages';
import { LineTokens } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/tokens/lineTokens';
import { renderViewLine2, RenderLineInput } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/viewLayout/viewLineRenderer';
import { ViewLineRenderingData } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/viewModel';
import { MonarchTokenizer } from '../common/monarch/monarchLexer.js';

const ttPolicy = createTrustedTypesPolicy('standaloneColorizer', { createHTML: value => value });
class Colorizer {
    static colorizeElement(themeService, languageService, domNode, options) {
        options = options || {};
        const theme = options.theme || 'vs';
        const mimeType = options.mimeType || domNode.getAttribute('lang') || domNode.getAttribute('data-lang');
        if (!mimeType) {
            console.error('Mode not detected');
            return Promise.resolve();
        }
        const languageId = languageService.getLanguageIdByMimeType(mimeType) || mimeType;
        themeService.setTheme(theme);
        const text = domNode.firstChild ? domNode.firstChild.nodeValue : '';
        domNode.className += ' ' + theme;
        const render = (str) => {
            const trustedhtml = ttPolicy?.createHTML(str) ?? str;
            domNode.innerHTML = trustedhtml;
        };
        return this.colorize(languageService, text || '', languageId, options).then(render, (err) => console.error(err));
    }
    static async colorize(languageService, text, languageId, options) {
        const languageIdCodec = languageService.languageIdCodec;
        let tabSize = 4;
        if (options && typeof options.tabSize === 'number') {
            tabSize = options.tabSize;
        }
        if (startsWithUTF8BOM(text)) {
            text = text.substr(1);
        }
        const lines = splitLines(text);
        if (!languageService.isRegisteredLanguageId(languageId)) {
            return _fakeColorize(lines, tabSize, languageIdCodec);
        }
        const tokenizationSupport = await TokenizationRegistry.getOrCreate(languageId);
        if (tokenizationSupport) {
            return _colorize(lines, tabSize, tokenizationSupport, languageIdCodec);
        }
        return _fakeColorize(lines, tabSize, languageIdCodec);
    }
    static colorizeLine(line, mightContainNonBasicASCII, mightContainRTL, tokens, tabSize = 4) {
        const isBasicASCII = ViewLineRenderingData.isBasicASCII(line, mightContainNonBasicASCII);
        const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII, mightContainRTL);
        const renderResult = renderViewLine2(( new RenderLineInput(
            false,
            true,
            line,
            false,
            isBasicASCII,
            containsRTL,
            0,
            tokens,
            [],
            tabSize,
            0,
            0,
            0,
            0,
            -1,
            'none',
            false,
            false,
            null,
            null,
            0
        )));
        return renderResult.html;
    }
    static colorizeModelLine(model, lineNumber, tabSize = 4) {
        const content = model.getLineContent(lineNumber);
        model.tokenization.forceTokenization(lineNumber);
        const tokens = model.tokenization.getLineTokens(lineNumber);
        const inflatedTokens = tokens.inflate();
        return this.colorizeLine(content, model.mightContainNonBasicASCII(), model.mightContainRTL(), inflatedTokens, tabSize);
    }
}
function _colorize(lines, tabSize, tokenizationSupport, languageIdCodec) {
    return ( new Promise((c, e) => {
        const execute = () => {
            const result = _actualColorize(lines, tabSize, tokenizationSupport, languageIdCodec);
            if (tokenizationSupport instanceof MonarchTokenizer) {
                const status = tokenizationSupport.getLoadStatus();
                if (status.loaded === false) {
                    status.promise.then(execute, e);
                    return;
                }
            }
            c(result);
        };
        execute();
    }));
}
function _fakeColorize(lines, tabSize, languageIdCodec) {
    let html = [];
    const defaultMetadata = ((FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)
        | (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)
        | (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)) >>> 0;
    const tokens = ( new Uint32Array(2));
    tokens[0] = 0;
    tokens[1] = defaultMetadata;
    for (let i = 0, length = lines.length; i < length; i++) {
        const line = lines[i];
        tokens[0] = line.length;
        const lineTokens = ( new LineTokens(tokens, line, languageIdCodec));
        const isBasicASCII = ViewLineRenderingData.isBasicASCII(line,  true);
        const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII,  true);
        const renderResult = renderViewLine2(( new RenderLineInput(
            false,
            true,
            line,
            false,
            isBasicASCII,
            containsRTL,
            0,
            lineTokens,
            [],
            tabSize,
            0,
            0,
            0,
            0,
            -1,
            'none',
            false,
            false,
            null,
            null,
            0
        )));
        html = html.concat(renderResult.html);
        html.push('<br/>');
    }
    return html.join('');
}
function _actualColorize(lines, tabSize, tokenizationSupport, languageIdCodec) {
    let html = [];
    let state = tokenizationSupport.getInitialState();
    for (let i = 0, length = lines.length; i < length; i++) {
        const line = lines[i];
        const tokenizeResult = tokenizationSupport.tokenizeEncoded(line, true, state);
        LineTokens.convertToEndOffset(tokenizeResult.tokens, line.length);
        const lineTokens = ( new LineTokens(tokenizeResult.tokens, line, languageIdCodec));
        const isBasicASCII = ViewLineRenderingData.isBasicASCII(line,  true);
        const containsRTL = ViewLineRenderingData.containsRTL(line, isBasicASCII,  true);
        const renderResult = renderViewLine2(( new RenderLineInput(
            false,
            true,
            line,
            false,
            isBasicASCII,
            containsRTL,
            0,
            lineTokens.inflate(),
            [],
            tabSize,
            0,
            0,
            0,
            0,
            -1,
            'none',
            false,
            false,
            null,
            null,
            0
        )));
        html = html.concat(renderResult.html);
        html.push('<br/>');
        state = tokenizeResult.endState;
    }
    return html.join('');
}

export { Colorizer };
