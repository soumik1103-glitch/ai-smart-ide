
import { Disposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/index';
import { LineRange } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/ranges/lineRange';
import { Range } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/range';
import { TokenizationStateStore } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/model/textModelTokens';
import { deserializeFontTokenOptions } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/textModelEvents';
import { ContiguousMultilineTokensBuilder } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/tokens/contiguousMultilineTokensBuilder';
import { observableConfigValue } from '@codingame/monaco-vscode-api/vscode/vs/platform/observable/common/platformObservableUtils';
import { MonotonousIndexTransformer } from '../indexTransformer.js';
import { linesLengthEditFromModelContentChange } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/model/textModelStringEdit';
import { StringEdit } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/edits/stringEdit';
import { OffsetRange } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/ranges/offsetRange';
import { AnnotationsUpdate } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/model/tokens/annotations';
import { keepObserved } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/utils/utils';
import { autorun } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/reactions/autorun';

class TextMateWorkerTokenizerController extends Disposable {
    static { this._id = 0; }
    constructor(_model, _worker, _languageIdCodec, _backgroundTokenizationStore, _configurationService, _maxTokenizationLineLength) {
        super();
        this._model = _model;
        this._worker = _worker;
        this._languageIdCodec = _languageIdCodec;
        this._backgroundTokenizationStore = _backgroundTokenizationStore;
        this._configurationService = _configurationService;
        this._maxTokenizationLineLength = _maxTokenizationLineLength;
        this.controllerId = TextMateWorkerTokenizerController._id++;
        this._pendingChanges = [];
        this._states = ( new TokenizationStateStore());
        this._loggingEnabled = observableConfigValue('editor.experimental.asyncTokenizationLogging', false, this._configurationService);
        this._register(keepObserved(this._loggingEnabled));
        this._register(this._model.onDidChangeContent((e) => {
            if (this._shouldLog) {
                console.log('model change', {
                    fileName: this._model.uri.fsPath.split('\\').pop(),
                    changes: changesToString(e.changes),
                });
            }
            this._worker.$acceptModelChanged(this.controllerId, e);
            this._pendingChanges.push(e);
        }));
        this._register(this._model.onDidChangeLanguage((e) => {
            const languageId = this._model.getLanguageId();
            const encodedLanguageId = this._languageIdCodec.encodeLanguageId(languageId);
            this._worker.$acceptModelLanguageChanged(this.controllerId, languageId, encodedLanguageId);
        }));
        const languageId = this._model.getLanguageId();
        const encodedLanguageId = this._languageIdCodec.encodeLanguageId(languageId);
        this._worker.$acceptNewModel({
            uri: this._model.uri,
            versionId: this._model.getVersionId(),
            lines: this._model.getLinesContent(),
            EOL: this._model.getEOL(),
            languageId,
            encodedLanguageId,
            maxTokenizationLineLength: this._maxTokenizationLineLength.get(),
            controllerId: this.controllerId,
        });
        this._register(autorun(reader => {
            const maxTokenizationLineLength = this._maxTokenizationLineLength.read(reader);
            this._worker.$acceptMaxTokenizationLineLength(this.controllerId, maxTokenizationLineLength);
        }));
    }
    dispose() {
        super.dispose();
        this._worker.$acceptRemovedModel(this.controllerId);
    }
    requestTokens(startLineNumber, endLineNumberExclusive) {
        this._worker.$retokenize(this.controllerId, startLineNumber, endLineNumberExclusive);
    }
    async setTokensAndStates(controllerId, versionId, rawTokens, fontTokens, stateDeltas) {
        if (this.controllerId !== controllerId) {
            return;
        }
        let tokens = ContiguousMultilineTokensBuilder.deserialize(( new Uint8Array(rawTokens)));
        const fontTokensUpdate = AnnotationsUpdate.deserialize(fontTokens, deserializeFontTokenOptions());
        if (this._shouldLog) {
            console.log('received background tokenization result', {
                fileName: this._model.uri.fsPath.split('\\').pop(),
                updatedTokenLines: ( tokens.map((t) => t.getLineRange())).join(' & '),
                updatedStateLines: ( stateDeltas.map((s) => ( ( new LineRange(s.startLineNumber, s.startLineNumber + s.stateDeltas.length)).toString()))).join(' & '),
            });
        }
        if (this._shouldLog) {
            const changes = ( ( this._pendingChanges.filter(c => c.versionId <= versionId).map(c => c.changes)).map(c => changesToString(c))).join(' then ');
            console.log('Applying changes to local states', changes);
        }
        while (this._pendingChanges.length > 0 &&
            this._pendingChanges[0].versionId <= versionId) {
            const change = this._pendingChanges.shift();
            this._states.acceptChanges(change.changes);
        }
        if (this._pendingChanges.length > 0) {
            if (this._shouldLog) {
                const changes = ( ( this._pendingChanges.map(c => c.changes)).map(c => changesToString(c))).join(' then ');
                console.log('Considering non-processed changes', changes);
            }
            const curToFutureTransformerTokens = MonotonousIndexTransformer.fromMany(( this._pendingChanges.map((c) => linesLengthEditFromModelContentChange(c.changes))));
            const b = ( new ContiguousMultilineTokensBuilder());
            for (const t of tokens) {
                for (let i = t.startLineNumber; i <= t.endLineNumber; i++) {
                    const result = curToFutureTransformerTokens.transform(i - 1);
                    if (result !== undefined) {
                        b.add(i, t.getLineTokens(i));
                    }
                }
            }
            tokens = b.finalize();
            for (const change of this._pendingChanges) {
                for (const innerChanges of change.changes) {
                    for (let j = 0; j < tokens.length; j++) {
                        tokens[j].applyEdit(innerChanges.range, innerChanges.text);
                    }
                }
            }
            fontTokensUpdate.rebase(this._stringEditFromChanges(this._model, this._pendingChanges));
        }
        const curToFutureTransformerStates = MonotonousIndexTransformer.fromMany(( this._pendingChanges.map((c) => linesLengthEditFromModelContentChange(c.changes))));
        if (!this._applyStateStackDiffFn || !this._initialState) {
            const { applyStateStackDiff, INITIAL } = await import('@codingame/monaco-vscode-api/_virtual/main').then(function (n) { return n.main; });
            this._applyStateStackDiffFn = applyStateStackDiff;
            this._initialState = INITIAL;
        }
        for (const d of stateDeltas) {
            let prevState = d.startLineNumber <= 1 ? this._initialState : this._states.getEndState(d.startLineNumber - 1);
            for (let i = 0; i < d.stateDeltas.length; i++) {
                const delta = d.stateDeltas[i];
                let state;
                if (delta) {
                    state = this._applyStateStackDiffFn(prevState, delta);
                    this._states.setEndState(d.startLineNumber + i, state);
                }
                else {
                    state = this._states.getEndState(d.startLineNumber + i);
                }
                const offset = curToFutureTransformerStates.transform(d.startLineNumber + i - 1);
                if (offset !== undefined) {
                    this._backgroundTokenizationStore.setEndState(offset + 1, state);
                }
                if (d.startLineNumber + i >= this._model.getLineCount() - 1) {
                    this._backgroundTokenizationStore.backgroundTokenizationFinished();
                }
                prevState = state;
            }
        }
        this._backgroundTokenizationStore.setTokens(tokens);
        this._backgroundTokenizationStore.setFontInfo(fontTokensUpdate);
    }
    _stringEditFromChanges(model, pendingChanges) {
        const edits = [];
        for (const change of pendingChanges) {
            for (const innerChanges of change.changes) {
                const range = Range.lift(innerChanges.range);
                const text = innerChanges.text;
                const offsetEditStart = model.getOffsetAt(range.getStartPosition());
                const offsetEditEnd = model.getOffsetAt(range.getEndPosition());
                edits.push(StringEdit.replace(( new OffsetRange(offsetEditStart, offsetEditEnd)), text));
            }
        }
        return StringEdit.compose(edits);
    }
    get _shouldLog() { return this._loggingEnabled.get(); }
}
function changesToString(changes) {
    return ( changes.map(c => ( Range.lift(c.range).toString()) + ' => ' + c.text)).join(' & ');
}

export { TextMateWorkerTokenizerController };
