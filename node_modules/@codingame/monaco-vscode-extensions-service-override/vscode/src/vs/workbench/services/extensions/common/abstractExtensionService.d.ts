import { Disposable } from "@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle";
import { IConfigurationService } from "@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration.service";
import { IDialogService } from "@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service";
import { ExtensionIdentifier, IExtension, IExtensionContributions, IExtensionDescription } from "@codingame/monaco-vscode-api/vscode/vs/platform/extensions/common/extensions";
import { IFileService } from "@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service";
import { IInstantiationService } from "@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation";
import { ILogService } from "@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service";
import { INotificationService } from "@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification.service";
import { IProductService } from "@codingame/monaco-vscode-api/vscode/vs/platform/product/common/productService.service";
import { ResolverResult } from "@codingame/monaco-vscode-api/vscode/vs/platform/remote/common/remoteAuthorityResolver";
import { IRemoteAuthorityResolverService } from "@codingame/monaco-vscode-api/vscode/vs/platform/remote/common/remoteAuthorityResolver.service";
import { IRemoteExtensionsScannerService } from "@codingame/monaco-vscode-api/vscode/vs/platform/remote/common/remoteExtensionsScanner.service";
import { ITelemetryService } from "@codingame/monaco-vscode-api/vscode/vs/platform/telemetry/common/telemetry.service";
import { IWorkspaceContextService } from "@codingame/monaco-vscode-api/vscode/vs/platform/workspace/common/workspace.service";
import { IWorkbenchEnvironmentService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/environment/common/environmentService.service";
import { IWorkbenchExtensionEnablementService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensionManagement/common/extensionManagement.service";
import { IWorkbenchExtensionManagementService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensionManagement/common/extensionManagement.service";
import { ExtensionDescriptionRegistrySnapshot, IActivationEventsReader } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensionDescriptionRegistry";
import { ExtensionHostKind, IExtensionHostKindPicker } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensionHostKind";
import { IExtensionHostManager } from "./extensionHostManagers.js";
import { IExtensionManifestPropertiesService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensionManifestPropertiesService.service";
import { ExtensionRunningLocation } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensionRunningLocation";
import { ExtensionRunningLocationTracker } from "./extensionRunningLocationTracker.js";
import { ActivationKind, ActivationTimes, ExtensionActivationReason, ExtensionPointContribution, IExtensionHost, IExtensionInspectInfo, IExtensionsStatus, IMessage, IResponsiveStateChangeEvent, IWillActivateEvent, WillStopExtensionHostsEvent } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions";
import { IExtensionService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions.service";
import { ExtensionsProposedApi } from "./extensionsProposedApi.js";
import { IExtensionPoint } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensionsRegistry";
import { ILifecycleService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/lifecycle/common/lifecycle.service";
import { IRemoteAgentService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/remote/common/remoteAgentService.service";
export declare abstract class AbstractExtensionService extends Disposable implements IExtensionService {
    protected readonly _extensionsProposedApi: ExtensionsProposedApi;
    protected readonly _extensionHostFactory: IExtensionHostFactory;
    protected readonly _extensionHostKindPicker: IExtensionHostKindPicker;
    protected readonly _instantiationService: IInstantiationService;
    protected readonly _notificationService: INotificationService;
    protected readonly _environmentService: IWorkbenchEnvironmentService;
    protected readonly _telemetryService: ITelemetryService;
    protected readonly _extensionEnablementService: IWorkbenchExtensionEnablementService;
    protected readonly _fileService: IFileService;
    protected readonly _productService: IProductService;
    protected readonly _extensionManagementService: IWorkbenchExtensionManagementService;
    private readonly _contextService;
    protected readonly _configurationService: IConfigurationService;
    private readonly _extensionManifestPropertiesService;
    protected readonly _logService: ILogService;
    protected readonly _remoteAgentService: IRemoteAgentService;
    protected readonly _remoteExtensionsScannerService: IRemoteExtensionsScannerService;
    private readonly _lifecycleService;
    protected readonly _remoteAuthorityResolverService: IRemoteAuthorityResolverService;
    private readonly _dialogService;
    _serviceBrand: undefined;
    private readonly _hasLocalProcess;
    private readonly _allowRemoteExtensionsInLocalWebWorker;
    private readonly _onDidRegisterExtensions;
    readonly onDidRegisterExtensions: import("@codingame/monaco-vscode-api/vscode/vs/base/common/event").Event<void>;
    private readonly _onDidChangeExtensionsStatus;
    readonly onDidChangeExtensionsStatus: import("@codingame/monaco-vscode-api/vscode/vs/base/common/event").Event<ExtensionIdentifier[]>;
    private readonly _onDidChangeExtensions;
    readonly onDidChangeExtensions: import("@codingame/monaco-vscode-api/vscode/vs/base/common/event").Event<{
        readonly added: ReadonlyArray<IExtensionDescription>;
        readonly removed: ReadonlyArray<IExtensionDescription>;
    }>;
    private readonly _onWillActivateByEvent;
    readonly onWillActivateByEvent: import("@codingame/monaco-vscode-api/vscode/vs/base/common/event").Event<IWillActivateEvent>;
    private readonly _onDidChangeResponsiveChange;
    readonly onDidChangeResponsiveChange: import("@codingame/monaco-vscode-api/vscode/vs/base/common/event").Event<IResponsiveStateChangeEvent>;
    private readonly _onWillStop;
    readonly onWillStop: import("@codingame/monaco-vscode-api/vscode/vs/base/common/event").Event<WillStopExtensionHostsEvent>;
    private readonly _activationEventReader;
    private readonly _registry;
    private readonly _installedExtensionsReady;
    private readonly _extensionStatus;
    private readonly _allRequestedActivateEvents;
    private readonly _runningLocations;
    private readonly _remoteCrashTracker;
    private _deltaExtensionsQueue;
    private _inHandleDeltaExtensions;
    private readonly _extensionHostManagers;
    private _resolveAuthorityAttempt;
    constructor(options: {
        hasLocalProcess: boolean;
        allowRemoteExtensionsInLocalWebWorker: boolean;
    }, _extensionsProposedApi: ExtensionsProposedApi, _extensionHostFactory: IExtensionHostFactory, _extensionHostKindPicker: IExtensionHostKindPicker, _instantiationService: IInstantiationService, _notificationService: INotificationService, _environmentService: IWorkbenchEnvironmentService, _telemetryService: ITelemetryService, _extensionEnablementService: IWorkbenchExtensionEnablementService, _fileService: IFileService, _productService: IProductService, _extensionManagementService: IWorkbenchExtensionManagementService, _contextService: IWorkspaceContextService, _configurationService: IConfigurationService, _extensionManifestPropertiesService: IExtensionManifestPropertiesService, _logService: ILogService, _remoteAgentService: IRemoteAgentService, _remoteExtensionsScannerService: IRemoteExtensionsScannerService, _lifecycleService: ILifecycleService, _remoteAuthorityResolverService: IRemoteAuthorityResolverService, _dialogService: IDialogService);
    protected _getExtensionHostManagers(kind: ExtensionHostKind): IExtensionHostManager[];
    protected _handleDeltaExtensions(item: DeltaExtensionsQueueItem): Promise<void>;
    private _deltaExtensions;
    private _updateExtensionsOnExtHosts;
    private _updateExtensionsOnExtHost;
    canAddExtension(extension: IExtensionDescription): boolean;
    private _canAddExtension;
    canRemoveExtension(extension: IExtensionDescription): boolean;
    private _activateAddedExtensionIfNeeded;
    private _initializePromise;
    protected _initializeIfNeeded(): Promise<void> | null;
    protected _initialize(): Promise<void>;
    private _resolveAndProcessExtensions;
    private _handleExtensionTests;
    private findTestExtensionHost;
    private _releaseBarrier;
    protected _resolveAuthorityInitial(remoteAuthority: string): Promise<ResolverResult>;
    protected _resolveAuthorityAgain(): Promise<void>;
    private _resolveAuthorityWithLogging;
    protected _resolveAuthorityOnExtensionHosts(kind: ExtensionHostKind, remoteAuthority: string): Promise<ResolverResult>;
    stopExtensionHosts(reason: string, auto?: boolean): Promise<boolean>;
    protected _doStopExtensionHosts(): Promise<void>;
    private _doStopExtensionHostsWithVeto;
    private _startExtensionHostsIfNecessary;
    private _createExtensionHostManager;
    protected _doCreateExtensionHostManager(extensionHost: IExtensionHost, initialActivationEvents: string[]): IExtensionHostManager;
    private _onExtensionHostCrashOrExit;
    protected _onExtensionHostCrashed(extensionHost: IExtensionHostManager, code: number, signal: string | null): void;
    private _getExtensionHostExitInfoWithTimeout;
    private _onRemoteExtensionHostCrashed;
    protected _logExtensionHostCrash(extensionHost: IExtensionHostManager): void;
    startExtensionHosts(updates?: {
        toAdd: IExtension[];
        toRemove: string[];
    }): Promise<void>;
    private _startOnDemandExtensionHosts;
    activateByEvent(activationEvent: string, activationKind?: ActivationKind): Promise<void>;
    private _activateByEvent;
    activateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;
    activationEventIsDone(activationEvent: string): boolean;
    whenInstalledExtensionsRegistered(): Promise<boolean>;
    get extensions(): IExtensionDescription[];
    protected _getExtensionRegistrySnapshotWhenReady(): Promise<ExtensionDescriptionRegistrySnapshot>;
    getExtension(id: string): Promise<IExtensionDescription | undefined>;
    readExtensionPointContributions<T extends IExtensionContributions[keyof IExtensionContributions]>(extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]>;
    getExtensionsStatus(): {
        [id: string]: IExtensionsStatus;
    };
    getInspectPorts(extensionHostKind: ExtensionHostKind, tryEnableInspector: boolean): Promise<IExtensionInspectInfo[]>;
    setRemoteEnvironment(env: {
        [key: string]: string | null;
    }): Promise<void>;
    private _safeInvokeIsEnabled;
    private _doHandleExtensionPoints;
    private _getOrCreateExtensionStatus;
    private _handleExtensionPointMessage;
    private static _handleExtensionPoint;
    private _acquireInternalAPI;
    _activateById(extensionId: ExtensionIdentifier, reason: ExtensionActivationReason): Promise<void>;
    private _onWillActivateExtension;
    private _onDidActivateExtension;
    private _onDidActivateExtensionError;
    private _onExtensionRuntimeError;
    protected abstract _resolveExtensions(): AsyncIterable<ResolvedExtensions>;
    protected abstract _onExtensionHostExit(code: number): Promise<void>;
    protected abstract _resolveAuthority(remoteAuthority: string): Promise<ResolverResult>;
}
export declare class ResolverExtensions {
    readonly extensions: IExtensionDescription[];
    constructor(extensions: IExtensionDescription[]);
}
export declare class LocalExtensions {
    readonly extensions: IExtensionDescription[];
    constructor(extensions: IExtensionDescription[]);
}
export declare class RemoteExtensions {
    readonly extensions: IExtensionDescription[];
    constructor(extensions: IExtensionDescription[]);
}
export type ResolvedExtensions = ResolverExtensions | LocalExtensions | RemoteExtensions;
export interface IExtensionHostFactory {
    createExtensionHost(runningLocations: ExtensionRunningLocationTracker, runningLocation: ExtensionRunningLocation, isInitialStart: boolean): IExtensionHost | null;
}
export declare class DeltaExtensionsQueueItem {
    readonly toAdd: IExtension[];
    readonly toRemove: string[] | IExtension[];
    constructor(toAdd: IExtension[], toRemove: string[] | IExtension[]);
}
export declare function isResolverExtension(extension: IExtensionDescription): boolean;
/**
 * @argument extensions The extensions to be checked.
 * @argument ignoreWorkspaceTrust Do not take workspace trust into account.
 */
export declare function checkEnabledAndProposedAPI(logService: ILogService, extensionEnablementService: IWorkbenchExtensionEnablementService, extensionsProposedApi: ExtensionsProposedApi, extensions: IExtensionDescription[], ignoreWorkspaceTrust: boolean): IExtensionDescription[];
/**
 * Return the subset of extensions that are enabled.
 * @argument ignoreWorkspaceTrust Do not take workspace trust into account.
 */
export declare function filterEnabledExtensions(logService: ILogService, extensionEnablementService: IWorkbenchExtensionEnablementService, extensions: IExtensionDescription[], ignoreWorkspaceTrust: boolean): IExtensionDescription[];
/**
 * @argument extension The extension to be checked.
 * @argument ignoreWorkspaceTrust Do not take workspace trust into account.
 */
export declare function extensionIsEnabled(logService: ILogService, extensionEnablementService: IWorkbenchExtensionEnablementService, extension: IExtensionDescription, ignoreWorkspaceTrust: boolean): boolean;
export declare class ExtensionStatus {
    readonly id: ExtensionIdentifier;
    private readonly _messages;
    get messages(): IMessage[];
    private _activationTimes;
    get activationTimes(): ActivationTimes | null;
    private _runtimeErrors;
    get runtimeErrors(): Error[];
    private _activationStarted;
    get activationStarted(): boolean;
    constructor(id: ExtensionIdentifier);
    clearRuntimeStatus(): void;
    addMessage(msg: IMessage): void;
    setActivationTimes(activationTimes: ActivationTimes): void;
    addRuntimeError(err: Error): void;
    onWillActivate(): void;
}
export declare class ExtensionHostCrashTracker {
    private static _TIME_LIMIT;
    private static _CRASH_LIMIT;
    private readonly _recentCrashes;
    private _removeOldCrashes;
    registerCrash(): void;
    shouldAutomaticallyRestart(): boolean;
}
/**
 * This can run correctly only on the renderer process because that is the only place
 * where all extension points and all implicit activation events generators are known.
 */
export declare class ImplicitActivationAwareReader implements IActivationEventsReader {
    readActivationEvents(extensionDescription: IExtensionDescription): string[];
}
