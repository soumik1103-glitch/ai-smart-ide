
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { Action } from '@codingame/monaco-vscode-api/vscode/vs/base/common/actions';
import { isCancellationError } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errors';
import { Disposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { Schemas } from '@codingame/monaco-vscode-api/vscode/vs/base/common/network';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification';
import { INotificationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification.service';
import { IOpenerService } from '@codingame/monaco-vscode-api/vscode/vs/platform/opener/common/opener.service';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { ExtHostContext, MainContext } from '@codingame/monaco-vscode-api/vscode/vs/workbench/api/common/extHost.protocol';
import { defaultExternalUriOpenerId } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/externalUriOpener/common/configuration';
import { ContributedExternalUriOpenersStore } from '../../contrib/externalUriOpener/common/contributedOpeners.js';
import { IExternalUriOpenerService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/externalUriOpener/common/externalUriOpenerService.service';
import { IExtensionService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions.service';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
import Severity from '@codingame/monaco-vscode-api/vscode/vs/base/common/severity';

let MainThreadUriOpeners = class MainThreadUriOpeners extends Disposable {
    constructor(context, storageService, externalUriOpenerService, extensionService, openerService, notificationService) {
        super();
        this.extensionService = extensionService;
        this.openerService = openerService;
        this.notificationService = notificationService;
        this._registeredOpeners = ( new Map());
        this.proxy = ( context.getProxy(ExtHostContext.ExtHostUriOpeners));
        this._register(externalUriOpenerService.registerExternalOpenerProvider(this));
        this._contributedExternalUriOpenersStore = this._register(( new ContributedExternalUriOpenersStore(storageService, extensionService)));
    }
    async *getOpeners(targetUri) {
        if (targetUri.scheme !== Schemas.http && targetUri.scheme !== Schemas.https) {
            return;
        }
        await this.extensionService.activateByEvent(`onOpenExternalUri:${targetUri.scheme}`);
        for (const [id, openerMetadata] of this._registeredOpeners) {
            if (( openerMetadata.schemes.has(targetUri.scheme))) {
                yield this.createOpener(id, openerMetadata);
            }
        }
    }
    createOpener(id, metadata) {
        return {
            id: id,
            label: metadata.label,
            canOpen: (uri, token) => {
                return this.proxy.$canOpenUri(id, uri, token);
            },
            openExternalUri: async (uri, ctx, token) => {
                try {
                    await this.proxy.$openUri(id, { resolvedUri: uri, sourceUri: ctx.sourceUri }, token);
                }
                catch (e) {
                    if (!isCancellationError(e)) {
                        const openDefaultAction = ( new Action('default', ( localize(2556, "Open using default opener")), undefined, undefined, async () => {
                            await this.openerService.open(uri, {
                                allowTunneling: false,
                                allowContributedOpeners: defaultExternalUriOpenerId,
                            });
                        }));
                        openDefaultAction.tooltip = ( uri.toString());
                        this.notificationService.notify({
                            severity: Severity.Error,
                            message: ( localize(2557, 'Could not open uri with \'{0}\': {1}', id, (e.toString()))),
                            actions: {
                                primary: [
                                    openDefaultAction
                                ]
                            }
                        });
                    }
                }
                return true;
            },
        };
    }
    async $registerUriOpener(id, schemes, extensionId, label) {
        if (( this._registeredOpeners.has(id))) {
            throw ( new Error(`Opener with id '${id}' already registered`));
        }
        this._registeredOpeners.set(id, {
            schemes: ( new Set(schemes)),
            label,
            extensionId,
        });
        this._contributedExternalUriOpenersStore.didRegisterOpener(id, extensionId.value);
    }
    async $unregisterUriOpener(id) {
        this._registeredOpeners.delete(id);
        this._contributedExternalUriOpenersStore.delete(id);
    }
    dispose() {
        super.dispose();
        this._registeredOpeners.clear();
    }
};
MainThreadUriOpeners = __decorate([
    extHostNamedCustomer(MainContext.MainThreadUriOpeners),
    ( __param(1, IStorageService)),
    ( __param(2, IExternalUriOpenerService)),
    ( __param(3, IExtensionService)),
    ( __param(4, IOpenerService)),
    ( __param(5, INotificationService))
], MainThreadUriOpeners);

export { MainThreadUriOpeners };
