
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { DeferredPromise } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { Emitter } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { Disposable, DisposableMap } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { revive } from '@codingame/monaco-vscode-api/vscode/vs/base/common/marshalling';
import { Schemas } from '@codingame/monaco-vscode-api/vscode/vs/base/common/network';
import { escapeRegExpCharacters } from '@codingame/monaco-vscode-api/vscode/vs/base/common/strings';
import { ThemeIcon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/themables';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { Range } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/range';
import { getWordAtText } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/wordHelper';
import { CompletionItemKind } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages';
import { ILanguageFeaturesService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/languageFeatures.service';
import { ExtensionIdentifier } from '@codingame/monaco-vscode-api/vscode/vs/platform/extensions/common/extensions';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { IUriIdentityService } from '@codingame/monaco-vscode-api/vscode/vs/platform/uriIdentity/common/uriIdentity.service';
import { IChatWidgetService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chat.service';
import { IChatAgentService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/participants/chatAgents.service';
import { IPromptsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/promptSyntax/service/promptsService.service';
import { IChatEditingService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/editing/chatEditingService.service';
import { ChatRequestAgentPart } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/requestParser/chatParserTypes';
import { ChatRequestParser } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/requestParser/chatRequestParser';
import { IChatService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatService/chatService.service';
import { IChatSessionsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatSessionsService.service';
import { ChatModeKind, ChatAgentLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/constants';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
import { IExtensionService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions.service';
import { ExtHostContext, MainContext } from '@codingame/monaco-vscode-api/vscode/vs/workbench/api/common/extHost.protocol';
import { NotebookDto } from './mainThreadNotebookDto.js';
import { addDynamicVariableActionId } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/widget/input/editor/chatDynamicVariablesConstant';

class MainThreadChatTask {
    get onDidAddProgress() { return this._onDidAddProgress.event; }
    constructor(content) {
        this.content = content;
        this.kind = 'progressTask';
        this.deferred = ( new DeferredPromise());
        this._onDidAddProgress = ( new Emitter());
        this.progress = [];
    }
    task() {
        return this.deferred.p;
    }
    isSettled() {
        return this.deferred.isSettled;
    }
    complete(v) {
        this.deferred.complete(v);
    }
    add(progress) {
        this.progress.push(progress);
        this._onDidAddProgress.fire(progress);
    }
    toJSON() {
        return {
            kind: 'progressTaskSerialized',
            content: this.content,
            progress: this.progress
        };
    }
}
let MainThreadChatAgents2 = class MainThreadChatAgents2 extends Disposable {
    constructor(extHostContext, _chatAgentService, _chatSessionService, _chatService, _chatEditingService, _languageFeaturesService, _chatWidgetService, _instantiationService, _logService, _extensionService, _uriIdentityService, _promptsService) {
        super();
        this._chatAgentService = _chatAgentService;
        this._chatSessionService = _chatSessionService;
        this._chatService = _chatService;
        this._chatEditingService = _chatEditingService;
        this._languageFeaturesService = _languageFeaturesService;
        this._chatWidgetService = _chatWidgetService;
        this._instantiationService = _instantiationService;
        this._logService = _logService;
        this._extensionService = _extensionService;
        this._uriIdentityService = _uriIdentityService;
        this._promptsService = _promptsService;
        this._agents = this._register(( new DisposableMap()));
        this._agentCompletionProviders = this._register(( new DisposableMap()));
        this._agentIdsToCompletionProviders = this._register(( new DisposableMap()));
        this._chatParticipantDetectionProviders = this._register(( new DisposableMap()));
        this._chatRelatedFilesProviders = this._register(( new DisposableMap()));
        this._customAgentsProviders = this._register(( new DisposableMap()));
        this._customAgentsProviderEmitters = this._register(( new DisposableMap()));
        this._pendingProgress = ( new Map());
        this._activeTasks = ( new Map());
        this._unresolvedAnchors = ( new Map());
        this._proxy = ( extHostContext.getProxy(ExtHostContext.ExtHostChatAgents2));
        this._register(this._chatService.onDidDisposeSession(e => {
            for (const resource of e.sessionResource) {
                this._proxy.$releaseSession(resource);
            }
        }));
        this._register(this._chatService.onDidPerformUserAction(e => {
            if (typeof e.agentId === 'string') {
                for (const [handle, agent] of this._agents) {
                    if (agent.id === e.agentId) {
                        if (e.action.kind === 'vote') {
                            this._proxy.$acceptFeedback(handle, e.result ?? {}, e.action);
                        }
                        else {
                            this._proxy.$acceptAction(handle, e.result || {}, e);
                        }
                        break;
                    }
                }
            }
        }));
    }
    $unregisterAgent(handle) {
        this._agents.deleteAndDispose(handle);
    }
    async $transferActiveChatSession(toWorkspace) {
        const widget = this._chatWidgetService.lastFocusedWidget;
        const model = widget?.viewModel?.model;
        if (!model) {
            this._logService.error(`MainThreadChat#$transferActiveChatSession: No active chat session found`);
            return;
        }
        await this._chatService.transferChatSession(model.sessionResource, URI.revive(toWorkspace));
    }
    async $registerAgent(handle, extension, id, metadata, dynamicProps) {
        await this._extensionService.whenInstalledExtensionsRegistered();
        const staticAgentRegistration = this._chatAgentService.getAgent(id, true);
        const chatSessionRegistration = this._chatSessionService.getAllChatSessionContributions().find(c => c.type === id || c.alternativeIds?.includes(id));
        if (!staticAgentRegistration && !chatSessionRegistration && !dynamicProps) {
            if (this._chatAgentService.getAgentsByName(id).length) {
                throw ( new Error(
                    `chatParticipant must be declared with an ID in package.json. The "id" property may be missing! "${id}"`
                ));
            }
            throw ( new Error(`chatParticipant must be declared in package.json: ${id}`));
        }
        const impl = {
            invoke: async (request, progress, history, token) => {
                const chatSession = this._chatService.getSession(request.sessionResource);
                this._pendingProgress.set(request.requestId, { progress, chatSession });
                try {
                    return (await this._proxy.$invokeAgent(handle, request, {
                        history,
                        chatSessionContext: chatSession?.contributedChatSession
                    }, token)) ?? {};
                }
                finally {
                    this._pendingProgress.delete(request.requestId);
                }
            },
            setRequestTools: (requestId, tools) => {
                this._proxy.$setRequestTools(requestId, tools);
            },
            provideFollowups: async (request, result, history, token) => {
                if (!this._agents.get(handle)?.hasFollowups) {
                    return [];
                }
                return this._proxy.$provideFollowups(request, handle, result, { history }, token);
            },
            provideChatTitle: (history, token) => {
                return this._proxy.$provideChatTitle(handle, history, token);
            },
            provideChatSummary: (history, token) => {
                return this._proxy.$provideChatSummary(handle, history, token);
            },
        };
        if (chatSessionRegistration?.alternativeIds?.includes(id)) {
            return;
        }
        let disposable;
        if (!staticAgentRegistration && dynamicProps) {
            const extensionDescription = this._extensionService.extensions.find(e => ExtensionIdentifier.equals(e.identifier, extension));
            disposable = this._chatAgentService.registerDynamicAgent({
                id,
                name: dynamicProps.name,
                description: dynamicProps.description,
                extensionId: extension,
                extensionVersion: extensionDescription?.version,
                extensionDisplayName: extensionDescription?.displayName ?? extension.value,
                extensionPublisherId: extensionDescription?.publisher ?? '',
                publisherDisplayName: dynamicProps.publisherName,
                fullName: dynamicProps.fullName,
                metadata: revive(metadata),
                slashCommands: [],
                disambiguation: [],
                locations: [ChatAgentLocation.Chat],
                modes: [ChatModeKind.Ask, ChatModeKind.Agent, ChatModeKind.Edit],
            }, impl);
        }
        else {
            disposable = this._chatAgentService.registerAgentImplementation(id, impl);
        }
        this._agents.set(handle, {
            id: id,
            extensionId: extension,
            dispose: () => disposable.dispose(),
            hasFollowups: metadata.hasFollowups
        });
    }
    async $updateAgent(handle, metadataUpdate) {
        await this._extensionService.whenInstalledExtensionsRegistered();
        const data = this._agents.get(handle);
        if (!data) {
            this._logService.error(`MainThreadChatAgents2#$updateAgent: No agent with handle ${handle} registered`);
            return;
        }
        data.hasFollowups = metadataUpdate.hasFollowups;
        this._chatAgentService.updateAgent(data.id, revive(metadataUpdate));
    }
    async $handleProgressChunk(requestId, chunks) {
        const pendingProgress = this._pendingProgress.get(requestId);
        if (!pendingProgress) {
            this._logService.warn(`MainThreadChatAgents2#$handleProgressChunk: No pending progress for requestId ${requestId}`);
            return;
        }
        const { progress, chatSession } = pendingProgress;
        const chatProgressParts = [];
        for (const item of chunks) {
            const [progress, responsePartHandle] = Array.isArray(item) ? item : [item];
            if (progress.kind === 'externalEdits') {
                const response = chatSession?.getRequests().at(-1)?.response;
                if (chatSession?.editingSession && responsePartHandle !== undefined && response) {
                    const parts = progress.start
                        ? await chatSession.editingSession.startExternalEdits(response, responsePartHandle, revive(progress.resources), progress.undoStopId)
                        : await chatSession.editingSession.stopExternalEdits(response, responsePartHandle);
                    chatProgressParts.push(...parts);
                }
                continue;
            }
            const revivedProgress = progress.kind === 'notebookEdit'
                ? ChatNotebookEdit.fromChatEdit(progress)
                : revive(progress);
            if (revivedProgress.kind === 'notebookEdit'
                || revivedProgress.kind === 'textEdit'
                || revivedProgress.kind === 'codeblockUri') {
                revivedProgress.uri = this._uriIdentityService.asCanonicalUri(revivedProgress.uri);
            }
            if (responsePartHandle !== undefined) {
                if (revivedProgress.kind === 'progressTask') {
                    const handle = responsePartHandle;
                    const responsePartId = `${requestId}_${handle}`;
                    const task = ( new MainThreadChatTask(revivedProgress.content));
                    this._activeTasks.set(responsePartId, task);
                    chatProgressParts.push(task);
                }
                else if (responsePartHandle !== undefined) {
                    const responsePartId = `${requestId}_${responsePartHandle}`;
                    const task = this._activeTasks.get(responsePartId);
                    switch (revivedProgress.kind) {
                        case 'progressTaskResult':
                            if (task && revivedProgress.content) {
                                task.complete(revivedProgress.content.value);
                                this._activeTasks.delete(responsePartId);
                            }
                            else {
                                task?.complete(undefined);
                            }
                            break;
                        case 'warning':
                        case 'reference':
                            task?.add(revivedProgress);
                            break;
                    }
                }
                continue;
            }
            if (revivedProgress.kind === 'inlineReference' && revivedProgress.resolveId) {
                if (!( this._unresolvedAnchors.has(requestId))) {
                    this._unresolvedAnchors.set(requestId, ( new Map()));
                }
                this._unresolvedAnchors.get(requestId)?.set(revivedProgress.resolveId, revivedProgress);
            }
            chatProgressParts.push(revivedProgress);
        }
        progress(chatProgressParts);
    }
    $handleAnchorResolve(requestId, handle, resolveAnchor) {
        const anchor = this._unresolvedAnchors.get(requestId)?.get(handle);
        if (!anchor) {
            return;
        }
        this._unresolvedAnchors.get(requestId)?.delete(handle);
        if (resolveAnchor) {
            const revivedAnchor = revive(resolveAnchor);
            anchor.inlineReference = revivedAnchor.inlineReference;
        }
    }
    $registerAgentCompletionsProvider(handle, id, triggerCharacters) {
        const provide = async (query, token) => {
            const completions = await this._proxy.$invokeCompletionProvider(handle, query, token);
            return ( completions.map((c) => ({ ...c, icon: c.icon ? ThemeIcon.fromId(c.icon) : undefined })));
        };
        this._agentIdsToCompletionProviders.set(id, this._chatAgentService.registerAgentCompletionProvider(id, provide));
        this._agentCompletionProviders.set(handle, this._languageFeaturesService.completionProvider.register({ scheme: Schemas.vscodeChatInput, hasAccessToAllModels: true }, {
            _debugDisplayName: 'chatAgentCompletions:' + handle,
            triggerCharacters,
            provideCompletionItems: async (model, position, _context, token) => {
                const widget = this._chatWidgetService.getWidgetByInputUri(model.uri);
                if (!widget || !widget.viewModel) {
                    return;
                }
                const triggerCharsPart = ( triggerCharacters.map(c => escapeRegExpCharacters(c))).join('');
                const wordRegex = ( new RegExp(`[${triggerCharsPart}]\\S*`, 'g'));
                const query = getWordAtText(position.column, wordRegex, model.getLineContent(position.lineNumber), 0)?.word ?? '';
                if (query && !( triggerCharacters.some(c => query.startsWith(c)))) {
                    return;
                }
                const parsedRequest = this._instantiationService.createInstance(ChatRequestParser).parseChatRequest(widget.viewModel.sessionResource, model.getValue()).parts;
                const agentPart = parsedRequest.find((part) => part instanceof ChatRequestAgentPart);
                const thisAgentId = this._agents.get(handle)?.id;
                if (agentPart?.agent.id !== thisAgentId) {
                    return;
                }
                const range = computeCompletionRanges(model, position, wordRegex);
                if (!range) {
                    return null;
                }
                const result = await provide(query, token);
                const variableItems = ( result.map(v => {
                    const insertText = v.insertText ?? (typeof v.label === 'string' ? v.label : v.label.label);
                    const rangeAfterInsert = ( new Range(
                        range.insert.startLineNumber,
                        range.insert.startColumn,
                        range.insert.endLineNumber,
                        range.insert.startColumn + insertText.length
                    ));
                    return {
                        label: v.label,
                        range,
                        insertText: insertText + ' ',
                        kind: CompletionItemKind.Text,
                        detail: v.detail,
                        documentation: v.documentation,
                        command: { id: addDynamicVariableActionId, title: '', arguments: [{ id: v.id, widget, range: rangeAfterInsert, variableData: revive(v.value), command: v.command }] }
                    };
                }));
                return {
                    suggestions: variableItems
                };
            }
        }));
    }
    $unregisterAgentCompletionsProvider(handle, id) {
        this._agentCompletionProviders.deleteAndDispose(handle);
        this._agentIdsToCompletionProviders.deleteAndDispose(id);
    }
    $registerChatParticipantDetectionProvider(handle) {
        this._chatParticipantDetectionProviders.set(handle, this._chatAgentService.registerChatParticipantDetectionProvider(handle, {
            provideParticipantDetection: async (request, history, options, token) => {
                return await this._proxy.$detectChatParticipant(handle, request, { history }, options, token);
            }
        }));
    }
    $unregisterChatParticipantDetectionProvider(handle) {
        this._chatParticipantDetectionProviders.deleteAndDispose(handle);
    }
    $registerRelatedFilesProvider(handle, metadata) {
        this._chatRelatedFilesProviders.set(handle, this._chatEditingService.registerRelatedFilesProvider(handle, {
            description: metadata.description,
            provideRelatedFiles: async (request, token) => {
                return (await this._proxy.$provideRelatedFiles(handle, request, token))?.map((v) => ({ uri: ( URI.from(v.uri)), description: v.description })) ?? [];
            }
        }));
    }
    $unregisterRelatedFilesProvider(handle) {
        this._chatRelatedFilesProviders.deleteAndDispose(handle);
    }
    async $registerCustomAgentsProvider(handle, extensionId) {
        const extension = await this._extensionService.getExtension(extensionId.value);
        if (!extension) {
            this._logService.error(`[MainThreadChatAgents2] Could not find extension for CustomAgentsProvider: ${extensionId.value}`);
            return;
        }
        const emitter = ( new Emitter());
        this._customAgentsProviderEmitters.set(handle, emitter);
        const disposable = this._promptsService.registerCustomAgentsProvider(extension, {
            onDidChangeCustomAgents: emitter.event,
            provideCustomAgents: async (options, token) => {
                const agents = await this._proxy.$provideCustomAgents(handle, options, token);
                if (!agents) {
                    return undefined;
                }
                return ( agents.map(agent => ({
                    ...agent,
                    uri: URI.revive(agent.uri)
                })));
            }
        });
        this._customAgentsProviders.set(handle, disposable);
    }
    $unregisterCustomAgentsProvider(handle) {
        this._customAgentsProviders.deleteAndDispose(handle);
        this._customAgentsProviderEmitters.deleteAndDispose(handle);
    }
    $onDidChangeCustomAgents(handle) {
        const emitter = this._customAgentsProviderEmitters.get(handle);
        if (emitter) {
            emitter.fire();
        }
    }
};
MainThreadChatAgents2 = __decorate([
    extHostNamedCustomer(MainContext.MainThreadChatAgents2),
    ( __param(1, IChatAgentService)),
    ( __param(2, IChatSessionsService)),
    ( __param(3, IChatService)),
    ( __param(4, IChatEditingService)),
    ( __param(5, ILanguageFeaturesService)),
    ( __param(6, IChatWidgetService)),
    ( __param(7, IInstantiationService)),
    ( __param(8, ILogService)),
    ( __param(9, IExtensionService)),
    ( __param(10, IUriIdentityService)),
    ( __param(11, IPromptsService))
], MainThreadChatAgents2);
function computeCompletionRanges(model, position, reg) {
    const varWord = getWordAtText(position.column, reg, model.getLineContent(position.lineNumber), 0);
    if (!varWord && model.getWordUntilPosition(position).word) {
        return;
    }
    let insert;
    let replace;
    if (!varWord) {
        insert = replace = Range.fromPositions(position);
    }
    else {
        insert = ( new Range(
            position.lineNumber,
            varWord.startColumn,
            position.lineNumber,
            position.column
        ));
        replace = ( new Range(
            position.lineNumber,
            varWord.startColumn,
            position.lineNumber,
            varWord.endColumn
        ));
    }
    return { insert, replace };
}
var ChatNotebookEdit;
(function (ChatNotebookEdit) {
    function fromChatEdit(part) {
        return {
            kind: 'notebookEdit',
            uri: URI.revive(part.uri),
            done: part.done,
            edits: ( part.edits.map(NotebookDto.fromCellEditOperationDto))
        };
    }
    ChatNotebookEdit.fromChatEdit = fromChatEdit;
})(ChatNotebookEdit || (ChatNotebookEdit = {}));

export { MainThreadChatAgents2, MainThreadChatTask };
