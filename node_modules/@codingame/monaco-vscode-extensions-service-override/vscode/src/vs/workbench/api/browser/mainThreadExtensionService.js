
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { toAction } from '@codingame/monaco-vscode-api/vscode/vs/base/common/actions';
import { CancellationToken } from '@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation';
import { transformErrorFromSerialization } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errors';
import { FileAccess } from '@codingame/monaco-vscode-api/vscode/vs/base/common/network';
import Severity from '@codingame/monaco-vscode-api/vscode/vs/base/common/severity';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { ICommandService } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands.service';
import { areSameExtensions } from '@codingame/monaco-vscode-api/vscode/vs/platform/extensionManagement/common/extensionManagementUtil';
import { INotificationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification.service';
import { RemoteConnectionType, WebSocketRemoteConnection, ManagedRemoteConnection } from '@codingame/monaco-vscode-api/vscode/vs/platform/remote/common/remoteAuthorityResolver';
import { ExtHostContext, MainContext } from '@codingame/monaco-vscode-api/vscode/vs/workbench/api/common/extHost.protocol';
import { IExtensionsWorkbenchService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/extensions/common/extensions.service';
import { IWorkbenchEnvironmentService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/environment/common/environmentService.service';
import { EnablementState } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensionManagement/common/extensionManagement';
import { IWorkbenchExtensionEnablementService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensionManagement/common/extensionManagement.service';
import { ExtensionHostKind } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensionHostKind';
import { IExtensionService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions.service';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
import { IHostService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/host/browser/host.service';
import { ITimerService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/timer/browser/timerService.service';

let MainThreadExtensionService = class MainThreadExtensionService {
    constructor(extHostContext, _extensionService, _notificationService, _extensionsWorkbenchService, _hostService, _extensionEnablementService, _timerService, _commandService, _environmentService) {
        this._extensionService = _extensionService;
        this._notificationService = _notificationService;
        this._extensionsWorkbenchService = _extensionsWorkbenchService;
        this._hostService = _hostService;
        this._extensionEnablementService = _extensionEnablementService;
        this._timerService = _timerService;
        this._commandService = _commandService;
        this._environmentService = _environmentService;
        this._extensionHostKind = extHostContext.extensionHostKind;
        const internalExtHostContext = extHostContext;
        this._internalExtensionService = internalExtHostContext.internalExtensionService;
        internalExtHostContext._setExtensionHostProxy(( new ExtensionHostProxy(( extHostContext.getProxy(ExtHostContext.ExtHostExtensionService)))));
        internalExtHostContext._setAllMainProxyIdentifiers(( ( Object.keys(MainContext)).map((key) => MainContext[key])));
    }
    dispose() {
    }
    $getExtension(extensionId) {
        return this._extensionService.getExtension(extensionId);
    }
    $activateExtension(extensionId, reason) {
        return this._internalExtensionService._activateById(extensionId, reason);
    }
    async $onWillActivateExtension(extensionId) {
        this._internalExtensionService._onWillActivateExtension(extensionId);
    }
    $onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) {
        this._internalExtensionService._onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason);
    }
    $onExtensionRuntimeError(extensionId, data) {
        const error = transformErrorFromSerialization(data);
        this._internalExtensionService._onExtensionRuntimeError(extensionId, error);
        console.error(`[${extensionId.value}]${error.message}`);
        console.error(error.stack);
    }
    async $onExtensionActivationError(extensionId, data, missingExtensionDependency) {
        const error = transformErrorFromSerialization(data);
        this._internalExtensionService._onDidActivateExtensionError(extensionId, error);
        if (missingExtensionDependency) {
            const extension = await this._extensionService.getExtension(extensionId.value);
            if (extension) {
                const local = await this._extensionsWorkbenchService.queryLocal();
                const installedDependency = local.find(i => areSameExtensions(i.identifier, { id: missingExtensionDependency.dependency }));
                if (installedDependency?.local) {
                    await this._handleMissingInstalledDependency(extension, installedDependency.local);
                    return;
                }
                else {
                    await this._handleMissingNotInstalledDependency(extension, missingExtensionDependency.dependency);
                    return;
                }
            }
        }
        const isDev = !this._environmentService.isBuilt || this._environmentService.isExtensionDevelopment;
        if (isDev) {
            this._notificationService.error(error);
            return;
        }
        console.error(error.message);
    }
    async _handleMissingInstalledDependency(extension, missingInstalledDependency) {
        const extName = extension.displayName || extension.name;
        if (this._extensionEnablementService.isEnabled(missingInstalledDependency)) {
            this._notificationService.notify({
                severity: Severity.Error,
                message: ( localize(
                    2504,
                    "Cannot activate the '{0}' extension because it depends on the '{1}' extension, which is not loaded. Would you like to reload the window to load the extension?",
                    extName,
                    missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                )),
                actions: {
                    primary: [toAction({ id: 'reload', label: ( localize(2505, "Reload Window")), run: () => this._hostService.reload() })]
                }
            });
        }
        else {
            const enablementState = this._extensionEnablementService.getEnablementState(missingInstalledDependency);
            if (enablementState === EnablementState.DisabledByVirtualWorkspace) {
                this._notificationService.notify({
                    severity: Severity.Error,
                    message: ( localize(
                        2506,
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is not supported in the current workspace",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    )),
                });
            }
            else if (enablementState === EnablementState.DisabledByTrustRequirement) {
                this._notificationService.notify({
                    severity: Severity.Error,
                    message: ( localize(
                        2507,
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is not supported in Restricted Mode",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    )),
                    actions: {
                        primary: [toAction({ id: 'manageWorkspaceTrust', label: ( localize(2508, "Manage Workspace Trust")), run: () => this._commandService.executeCommand('workbench.trust.manage') })]
                    }
                });
            }
            else if (this._extensionEnablementService.canChangeEnablement(missingInstalledDependency)) {
                this._notificationService.notify({
                    severity: Severity.Error,
                    message: ( localize(
                        2509,
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is disabled. Would you like to enable the extension and reload the window?",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    )),
                    actions: {
                        primary: [toAction({
                                id: 'enable', label: ( localize(2510, "Enable and Reload")), enabled: true,
                                run: () => this._extensionEnablementService.setEnablement([missingInstalledDependency], enablementState === EnablementState.DisabledGlobally ? EnablementState.EnabledGlobally : EnablementState.EnabledWorkspace)
                                    .then(() => this._hostService.reload(), e => this._notificationService.error(e))
                            })]
                    }
                });
            }
            else {
                this._notificationService.notify({
                    severity: Severity.Error,
                    message: ( localize(
                        2511,
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is disabled.",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    )),
                });
            }
        }
    }
    async _handleMissingNotInstalledDependency(extension, missingDependency) {
        const extName = extension.displayName || extension.name;
        let dependencyExtension = null;
        try {
            dependencyExtension = (await this._extensionsWorkbenchService.getExtensions([{ id: missingDependency }], CancellationToken.None))[0];
        }
        catch (err) {
        }
        if (dependencyExtension) {
            this._notificationService.notify({
                severity: Severity.Error,
                message: ( localize(
                    2512,
                    "Cannot activate the '{0}' extension because it depends on the '{1}' extension from '{2}', which is not installed. Would you like to install the extension and reload the window?",
                    extName,
                    dependencyExtension.displayName,
                    dependencyExtension.publisherDisplayName
                )),
                actions: {
                    primary: [toAction({
                            id: 'install',
                            label: ( localize(2513, "Install and Reload")),
                            run: () => this._extensionsWorkbenchService.install(dependencyExtension)
                                .then(() => this._hostService.reload(), e => this._notificationService.error(e))
                        })]
                }
            });
        }
        else {
            this._notificationService.error(( localize(
                2514,
                "Cannot activate the '{0}' extension because it depends on an unknown '{1}' extension.",
                extName,
                missingDependency
            )));
        }
    }
    async $setPerformanceMarks(marks) {
        if (this._extensionHostKind === ExtensionHostKind.LocalProcess) {
            this._timerService.setPerformanceMarks('localExtHost', marks);
        }
        else if (this._extensionHostKind === ExtensionHostKind.LocalWebWorker) {
            this._timerService.setPerformanceMarks('workerExtHost', marks);
        }
        else {
            this._timerService.setPerformanceMarks('remoteExtHost', marks);
        }
    }
    async $asBrowserUri(uri) {
        return FileAccess.uriToBrowserUri(URI.revive(uri));
    }
    async $getAllStaticBrowserUris() {
        return Array.from(FileAccess.getRegisteredBrowserUris(), uri => [
            uri,
            FileAccess.uriToBrowserUri(uri)
        ]);
    }
};
MainThreadExtensionService = __decorate([
    extHostNamedCustomer(MainContext.MainThreadExtensionService),
    ( __param(1, IExtensionService)),
    ( __param(2, INotificationService)),
    ( __param(3, IExtensionsWorkbenchService)),
    ( __param(4, IHostService)),
    ( __param(5, IWorkbenchExtensionEnablementService)),
    ( __param(6, ITimerService)),
    ( __param(7, ICommandService)),
    ( __param(8, IWorkbenchEnvironmentService))
], MainThreadExtensionService);
class ExtensionHostProxy {
    constructor(_actual) {
        this._actual = _actual;
    }
    async resolveAuthority(remoteAuthority, resolveAttempt) {
        const resolved = reviveResolveAuthorityResult(await this._actual.$resolveAuthority(remoteAuthority, resolveAttempt));
        return resolved;
    }
    async getCanonicalURI(remoteAuthority, uri) {
        const uriComponents = await this._actual.$getCanonicalURI(remoteAuthority, uri);
        return (uriComponents ? URI.revive(uriComponents) : uriComponents);
    }
    startExtensionHost(extensionsDelta) {
        return this._actual.$startExtensionHost(extensionsDelta);
    }
    extensionTestsExecute() {
        return this._actual.$extensionTestsExecute();
    }
    activateByEvent(activationEvent, activationKind) {
        return this._actual.$activateByEvent(activationEvent, activationKind);
    }
    activate(extensionId, reason) {
        return this._actual.$activate(extensionId, reason);
    }
    setRemoteEnvironment(env) {
        return this._actual.$setRemoteEnvironment(env);
    }
    updateRemoteConnectionData(connectionData) {
        return this._actual.$updateRemoteConnectionData(connectionData);
    }
    deltaExtensions(extensionsDelta) {
        return this._actual.$deltaExtensions(extensionsDelta);
    }
    test_latency(n) {
        return this._actual.$test_latency(n);
    }
    test_up(b) {
        return this._actual.$test_up(b);
    }
    test_down(size) {
        return this._actual.$test_down(size);
    }
}
function reviveResolveAuthorityResult(result) {
    if (result.type === 'ok') {
        return {
            type: 'ok',
            value: {
                ...result.value,
                authority: reviveResolvedAuthority(result.value.authority),
            }
        };
    }
    else {
        return result;
    }
}
function reviveResolvedAuthority(resolvedAuthority) {
    return {
        ...resolvedAuthority,
        connectTo: reviveConnection(resolvedAuthority.connectTo),
    };
}
function reviveConnection(connection) {
    if (connection.type === RemoteConnectionType.WebSocket) {
        return ( new WebSocketRemoteConnection(connection.host, connection.port));
    }
    return ( new ManagedRemoteConnection(connection.id));
}

export { MainThreadExtensionService };
