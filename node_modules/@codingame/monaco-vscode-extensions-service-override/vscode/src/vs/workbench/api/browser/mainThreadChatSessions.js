
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { raceCancellationError } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { CancellationToken } from '@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation';
import { Emitter, Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { MarkdownString } from '@codingame/monaco-vscode-api/vscode/vs/base/common/htmlContent';
import { Disposable, DisposableMap, DisposableStore } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { ResourceMap } from '@codingame/monaco-vscode-api/vscode/vs/base/common/map';
import { revive } from '@codingame/monaco-vscode-api/vscode/vs/base/common/marshalling';
import '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/index';
import { isEqual } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { IDialogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { hasValidDiff } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/agentSessions/agentSessionsModel';
import { isIChatViewViewContext, ChatViewPaneTarget } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chat';
import { IChatWidgetService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/chat.service';
import { ChatEditorInput } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/widgetHosts/editor/chatEditorInput';
import { awaitStatsForSession } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chat';
import { ResponseModelState } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatService/chatService';
import { IChatService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatService/chatService.service';
import { ChatSessionStatus } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatSessionsService';
import { IChatSessionsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/chatSessionsService.service';
import { ChatAgentLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/constants';
import { IEditorGroupsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorGroupsService.service';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
import { ExtHostContext, MainContext } from '@codingame/monaco-vscode-api/vscode/vs/workbench/api/common/extHost.protocol';
import { observableValue } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/observables/observableValue';
import { autorun } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/reactions/autorun';

class ObservableChatSession extends Disposable {
    get options() {
        return this._options;
    }
    get progressObs() {
        return this._progressObservable;
    }
    get isCompleteObs() {
        return this._isCompleteObservable;
    }
    constructor(resource, providerHandle, proxy, logService, dialogService) {
        super();
        this._progressObservable = observableValue(this, []);
        this._isCompleteObservable = observableValue(this, false);
        this._onWillDispose = ( new Emitter());
        this.onWillDispose = this._onWillDispose.event;
        this._pendingProgressChunks = ( new Map());
        this._isInitialized = false;
        this._interruptionWasCanceled = false;
        this._disposalPending = false;
        this.sessionResource = resource;
        this.providerHandle = providerHandle;
        this.history = [];
        this._proxy = proxy;
        this._providerHandle = providerHandle;
        this._logService = logService;
        this._dialogService = dialogService;
    }
    initialize(token) {
        if (!this._initializationPromise) {
            this._initializationPromise = this._doInitializeContent(token);
        }
        return this._initializationPromise;
    }
    async _doInitializeContent(token) {
        try {
            const sessionContent = await raceCancellationError(this._proxy.$provideChatSessionContent(this._providerHandle, this.sessionResource, token), token);
            this._options = sessionContent.options;
            this.history.length = 0;
            this.history.push(...( sessionContent.history.map((turn) => {
                if (turn.type === 'request') {
                    const variables = turn.variableData?.variables.map(v => {
                        const entry = {
                            ...v,
                            value: revive(v.value)
                        };
                        return entry;
                    });
                    return {
                        type: 'request',
                        prompt: turn.prompt,
                        participant: turn.participant,
                        command: turn.command,
                        variableData: variables ? { variables } : undefined,
                        id: turn.id
                    };
                }
                return {
                    type: 'response',
                    parts: ( turn.parts.map((part) => revive(part))),
                    participant: turn.participant
                };
            })));
            if (sessionContent.hasActiveResponseCallback && !this.interruptActiveResponseCallback) {
                this.interruptActiveResponseCallback = async () => {
                    const confirmInterrupt = () => {
                        if (this._disposalPending) {
                            this._proxy.$disposeChatSessionContent(this._providerHandle, this.sessionResource);
                            this._disposalPending = false;
                        }
                        this._proxy.$interruptChatSessionActiveResponse(this._providerHandle, this.sessionResource, 'ongoing');
                        return true;
                    };
                    if (sessionContent.supportsInterruption) {
                        return confirmInterrupt();
                    }
                    return this._dialogService.confirm({
                        message: ( localize(2498, 'Are you sure you want to interrupt the active session?'))
                    }).then(confirmed => {
                        if (confirmed.confirmed) {
                            return confirmInterrupt();
                        }
                        else {
                            this._addProgress([{
                                    kind: 'progressMessage',
                                    content: { value: '', isTrusted: false }
                                }]);
                            this._interruptionWasCanceled = true;
                            if (this._disposalPending) {
                                this._logService.info(`Canceling deferred disposal for session ${this.sessionResource} (user canceled interruption)`);
                                this._disposalPending = false;
                            }
                            return false;
                        }
                    });
                };
            }
            if (sessionContent.hasRequestHandler && !this.requestHandler) {
                this.requestHandler = async (request, progress, history, token) => {
                    this._progressObservable.set([], undefined);
                    this._isCompleteObservable.set(false, undefined);
                    let lastProgressLength = 0;
                    const progressDisposable = autorun(reader => {
                        const progressArray = this._progressObservable.read(reader);
                        const isComplete = this._isCompleteObservable.read(reader);
                        if (progressArray.length > lastProgressLength) {
                            const newProgress = progressArray.slice(lastProgressLength);
                            progress(newProgress);
                            lastProgressLength = progressArray.length;
                        }
                        if (isComplete) {
                            progressDisposable.dispose();
                        }
                    });
                    try {
                        await this._proxy.$invokeChatSessionRequestHandler(this._providerHandle, this.sessionResource, request, history, token);
                        if (!this._isCompleteObservable.get() && !this.interruptActiveResponseCallback) {
                            this._markComplete();
                        }
                    }
                    catch (error) {
                        const errorProgress = {
                            kind: 'progressMessage',
                            content: { value: `Error: ${error instanceof Error ? error.message : String(error)}`, isTrusted: false }
                        };
                        this._addProgress([errorProgress]);
                        this._markComplete();
                        throw error;
                    }
                    finally {
                        progressDisposable.dispose();
                    }
                };
            }
            this._isInitialized = true;
            const hasActiveResponse = sessionContent.hasActiveResponseCallback;
            const hasRequestHandler = sessionContent.hasRequestHandler;
            const hasAnyCapability = hasActiveResponse || hasRequestHandler;
            for (const [requestId, chunks] of this._pendingProgressChunks) {
                this._logService.debug(`Processing ${chunks.length} pending progress chunks for session ${this.sessionResource}, requestId ${requestId}`);
                this._addProgress(chunks);
            }
            this._pendingProgressChunks.clear();
            if (!hasAnyCapability) {
                this._isCompleteObservable.set(true, undefined);
            }
        }
        catch (error) {
            this._logService.error(`Failed to initialize chat session ${this.sessionResource}:`, error);
            throw error;
        }
    }
    handleProgressChunk(requestId, progress) {
        if (!this._isInitialized) {
            const existing = this._pendingProgressChunks.get(requestId) || [];
            this._pendingProgressChunks.set(requestId, [...existing, ...progress]);
            this._logService.debug(`Queuing ${progress.length} progress chunks for session ${this.sessionResource}, requestId ${requestId} (session not initialized)`);
            return;
        }
        this._addProgress(progress);
    }
    handleProgressComplete(requestId) {
        this._pendingProgressChunks.delete(requestId);
        if (this._isInitialized) {
            if (!this._interruptionWasCanceled) {
                this._markComplete();
            }
            else {
                this._interruptionWasCanceled = false;
            }
        }
    }
    _addProgress(progress) {
        const currentProgress = this._progressObservable.get();
        this._progressObservable.set([...currentProgress, ...progress], undefined);
    }
    _markComplete() {
        if (!this._isCompleteObservable.get()) {
            this._isCompleteObservable.set(true, undefined);
        }
    }
    dispose() {
        this._onWillDispose.fire();
        this._onWillDispose.dispose();
        this._pendingProgressChunks.clear();
        if (this.interruptActiveResponseCallback && !this._interruptionWasCanceled) {
            this._disposalPending = true;
        }
        else {
            this._proxy.$disposeChatSessionContent(this._providerHandle, this.sessionResource);
        }
        super.dispose();
    }
}
let MainThreadChatSessions = class MainThreadChatSessions extends Disposable {
    constructor(_extHostContext, _chatSessionsService, _chatService, _chatWidgetService, _dialogService, _editorService, editorGroupService, _logService) {
        super();
        this._extHostContext = _extHostContext;
        this._chatSessionsService = _chatSessionsService;
        this._chatService = _chatService;
        this._chatWidgetService = _chatWidgetService;
        this._dialogService = _dialogService;
        this._editorService = _editorService;
        this.editorGroupService = editorGroupService;
        this._logService = _logService;
        this._itemProvidersRegistrations = this._register(( new DisposableMap()));
        this._contentProvidersRegistrations = this._register(( new DisposableMap()));
        this._sessionTypeToHandle = ( new Map());
        this._activeSessions = ( new ResourceMap());
        this._sessionDisposables = ( new ResourceMap());
        this._proxy = ( this._extHostContext.getProxy(ExtHostContext.ExtHostChatSessions));
        this._chatSessionsService.setOptionsChangeCallback(async (sessionResource, updates) => {
            const handle = this._getHandleForSessionType(sessionResource.scheme);
            if (handle !== undefined) {
                await this.notifyOptionsChange(handle, sessionResource, updates);
            }
        });
    }
    _getHandleForSessionType(chatSessionType) {
        return this._sessionTypeToHandle.get(chatSessionType);
    }
    $registerChatSessionItemProvider(handle, chatSessionType) {
        const disposables = ( new DisposableStore());
        const changeEmitter = disposables.add(( new Emitter()));
        const provider = {
            chatSessionType,
            onDidChangeChatSessionItems: Event.debounce(changeEmitter.event, (_, e) => e, 200),
            provideChatSessionItems: (token) => this._provideChatSessionItems(handle, token),
        };
        disposables.add(this._chatSessionsService.registerChatSessionItemProvider(provider));
        this._itemProvidersRegistrations.set(handle, {
            dispose: () => disposables.dispose(),
            provider,
            onDidChangeItems: changeEmitter,
        });
        disposables.add(this._chatSessionsService.registerChatModelChangeListeners(this._chatService, chatSessionType, () => changeEmitter.fire()));
    }
    $onDidChangeChatSessionItems(handle) {
        this._itemProvidersRegistrations.get(handle)?.onDidChangeItems.fire();
    }
    $onDidChangeChatSessionOptions(handle, sessionResourceComponents, updates) {
        const sessionResource = URI.revive(sessionResourceComponents);
        this._chatSessionsService.notifySessionOptionsChange(sessionResource, updates);
    }
    async $onDidCommitChatSessionItem(handle, originalComponents, modifiedCompoennts) {
        const originalResource = URI.revive(originalComponents);
        const modifiedResource = URI.revive(modifiedCompoennts);
        this._logService.trace(`$onDidCommitChatSessionItem: handle(${handle}), original(${originalResource}), modified(${modifiedResource})`);
        const chatSessionType = this._itemProvidersRegistrations.get(handle)?.provider.chatSessionType;
        if (!chatSessionType) {
            this._logService.error(`No chat session type found for provider handle ${handle}`);
            return;
        }
        const originalEditor = this._editorService.editors.find(editor => editor.resource?.toString() === ( originalResource.toString()));
        const originalModel = this._chatService.getSession(originalResource);
        const contribution = this._chatSessionsService.getAllChatSessionContributions().find(c => c.type === chatSessionType);
        const originalGroup = this.editorGroupService.groups.find(group => ( group.editors.some(editor => isEqual(editor.resource, originalResource))))
            ?? this.editorGroupService.activeGroup;
        const options = {
            title: {
                preferred: originalEditor?.getName() || undefined,
                fallback: ( localize(2499, "{0}", contribution?.displayName)),
            }
        };
        const newSession = await this._chatSessionsService.getOrCreateChatSession(URI.revive(modifiedResource), CancellationToken.None);
        if (originalEditor) {
            newSession.transferredState = originalEditor instanceof ChatEditorInput
                ? { editingSession: originalEditor.transferOutEditingSession(), inputState: originalModel?.inputModel.toJSON() }
                : undefined;
            this._editorService.replaceEditors([{
                    editor: originalEditor,
                    replacement: {
                        resource: modifiedResource,
                        options,
                    },
                }], originalGroup);
            return;
        }
        if (originalModel) {
            newSession.transferredState = {
                editingSession: originalModel.editingSession,
                inputState: originalModel.inputModel.toJSON()
            };
        }
        const chatViewWidget = this._chatWidgetService.getWidgetBySessionResource(originalResource);
        if (chatViewWidget && isIChatViewViewContext(chatViewWidget.viewContext)) {
            await this._chatWidgetService.openSession(modifiedResource, ChatViewPaneTarget, { preserveFocus: true });
        }
        else {
            const ref = await this._chatService.loadSessionForResource(modifiedResource, ChatAgentLocation.Chat, CancellationToken.None);
            ref?.dispose();
        }
    }
    async _provideChatSessionItems(handle, token) {
        try {
            const sessions = await this._proxy.$provideChatSessionItems(handle, token);
            return Promise.all(( sessions.map(async (session) => {
                const uri = URI.revive(session.resource);
                const model = this._chatService.getSession(uri);
                if (model) {
                    session = await this.handleSessionModelOverrides(model, session);
                }
                if (!session.changes || !model) {
                    const stats = (await this._chatService.getMetadataForSession(uri))?.stats;
                    const diffs = {
                        files: stats?.fileCount || 0,
                        insertions: stats?.added || 0,
                        deletions: stats?.removed || 0
                    };
                    if (hasValidDiff(diffs)) {
                        session.changes = diffs;
                    }
                }
                return {
                    ...session,
                    changes: revive(session.changes),
                    resource: uri,
                    iconPath: session.iconPath,
                    tooltip: session.tooltip ? this._reviveTooltip(session.tooltip) : undefined,
                };
            })));
        }
        catch (error) {
            this._logService.error('Error providing chat sessions:', error);
        }
        return [];
    }
    async handleSessionModelOverrides(model, session) {
        const inProgress = model.getRequests().filter(r => r.response && !r.response.isComplete);
        if (inProgress.length) {
            session.description = this._chatSessionsService.getInProgressSessionDescription(model);
        }
        if (!(session.changes instanceof Array)) {
            const modelStats = await awaitStatsForSession(model);
            if (modelStats) {
                session.changes = {
                    files: modelStats.fileCount,
                    insertions: modelStats.added,
                    deletions: modelStats.removed
                };
            }
        }
        if (model.lastRequest?.response?.state === ResponseModelState.NeedsInput) {
            session.status = ChatSessionStatus.NeedsInput;
        }
        return session;
    }
    async _provideChatSessionContent(providerHandle, sessionResource, token) {
        let session = this._activeSessions.get(sessionResource);
        if (!session) {
            session = ( new ObservableChatSession(
                sessionResource,
                providerHandle,
                this._proxy,
                this._logService,
                this._dialogService
            ));
            this._activeSessions.set(sessionResource, session);
            const disposable = session.onWillDispose(() => {
                this._activeSessions.delete(sessionResource);
                this._sessionDisposables.get(sessionResource)?.dispose();
                this._sessionDisposables.delete(sessionResource);
            });
            this._sessionDisposables.set(sessionResource, disposable);
        }
        try {
            await session.initialize(token);
            if (session.options) {
                for (const [_, handle] of this._sessionTypeToHandle) {
                    if (handle === providerHandle) {
                        for (const [optionId, value] of Object.entries(session.options)) {
                            this._chatSessionsService.setSessionOption(sessionResource, optionId, value);
                        }
                        break;
                    }
                }
            }
            return session;
        }
        catch (error) {
            session.dispose();
            this._logService.error(`Error providing chat session content for handle ${providerHandle} and resource ${( sessionResource.toString())}:`, error);
            throw error;
        }
    }
    $unregisterChatSessionItemProvider(handle) {
        this._itemProvidersRegistrations.deleteAndDispose(handle);
    }
    $registerChatSessionContentProvider(handle, chatSessionScheme) {
        const provider = {
            provideChatSessionContent: (resource, token) => this._provideChatSessionContent(handle, resource, token)
        };
        this._sessionTypeToHandle.set(chatSessionScheme, handle);
        this._contentProvidersRegistrations.set(handle, this._chatSessionsService.registerChatSessionContentProvider(chatSessionScheme, provider));
        this._refreshProviderOptions(handle, chatSessionScheme);
    }
    $unregisterChatSessionContentProvider(handle) {
        this._contentProvidersRegistrations.deleteAndDispose(handle);
        for (const [sessionType, h] of this._sessionTypeToHandle) {
            if (h === handle) {
                this._sessionTypeToHandle.delete(sessionType);
                break;
            }
        }
        for (const [key, session] of this._activeSessions) {
            if (session.providerHandle === handle) {
                session.dispose();
                this._activeSessions.delete(key);
            }
        }
    }
    async $handleProgressChunk(handle, sessionResource, requestId, chunks) {
        const resource = URI.revive(sessionResource);
        const observableSession = this._activeSessions.get(resource);
        if (!observableSession) {
            this._logService.warn(`No session found for progress chunks: handle ${handle}, sessionResource ${resource}, requestId ${requestId}`);
            return;
        }
        const chatProgressParts = ( chunks.map(chunk => {
            const [progress] = Array.isArray(chunk) ? chunk : [chunk];
            return revive(progress);
        }));
        observableSession.handleProgressChunk(requestId, chatProgressParts);
    }
    $handleProgressComplete(handle, sessionResource, requestId) {
        const resource = URI.revive(sessionResource);
        const observableSession = this._activeSessions.get(resource);
        if (!observableSession) {
            this._logService.warn(`No session found for progress completion: handle ${handle}, sessionResource ${resource}, requestId ${requestId}`);
            return;
        }
        observableSession.handleProgressComplete(requestId);
    }
    $handleAnchorResolve(handle, sesssionResource, requestId, requestHandle, anchor) {
    }
    $onDidChangeChatSessionProviderOptions(handle) {
        let sessionType;
        for (const [type, h] of this._sessionTypeToHandle) {
            if (h === handle) {
                sessionType = type;
                break;
            }
        }
        if (!sessionType) {
            this._logService.warn(`No session type found for chat session content provider handle ${handle} when refreshing provider options`);
            return;
        }
        this._refreshProviderOptions(handle, sessionType);
    }
    _refreshProviderOptions(handle, chatSessionScheme) {
        this._proxy.$provideChatSessionProviderOptions(handle, CancellationToken.None).then(options => {
            if (options?.optionGroups && options.optionGroups.length) {
                this._chatSessionsService.setOptionGroupsForSessionType(chatSessionScheme, handle, options.optionGroups);
            }
        }).catch(err => this._logService.error('Error fetching chat session options', err));
    }
    dispose() {
        for (const session of ( this._activeSessions.values())) {
            session.dispose();
        }
        this._activeSessions.clear();
        for (const disposable of ( this._sessionDisposables.values())) {
            disposable.dispose();
        }
        this._sessionDisposables.clear();
        super.dispose();
    }
    _reviveTooltip(tooltip) {
        if (!tooltip) {
            return undefined;
        }
        if (typeof tooltip === 'string') {
            return tooltip;
        }
        if (typeof tooltip === 'object' && 'value' in tooltip) {
            return MarkdownString.lift(tooltip);
        }
        return undefined;
    }
    async notifyOptionsChange(handle, sessionResource, updates) {
        try {
            await this._proxy.$provideHandleOptionsChange(handle, sessionResource, updates, CancellationToken.None);
        }
        catch (error) {
            this._logService.error(`Error notifying extension about options change for handle ${handle}, sessionResource ${sessionResource}:`, error);
        }
    }
};
MainThreadChatSessions = __decorate([
    extHostNamedCustomer(MainContext.MainThreadChatSessions),
    ( __param(1, IChatSessionsService)),
    ( __param(2, IChatService)),
    ( __param(3, IChatWidgetService)),
    ( __param(4, IDialogService)),
    ( __param(5, IEditorService)),
    ( __param(6, IEditorGroupsService)),
    ( __param(7, ILogService))
], MainThreadChatSessions);

export { MainThreadChatSessions, ObservableChatSession };
