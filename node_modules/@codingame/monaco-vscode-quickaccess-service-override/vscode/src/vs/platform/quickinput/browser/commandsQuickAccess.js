
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { toErrorMessage } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errorMessage';
import { isCancellationError } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errors';
import { or, matchesBaseContiguousSubString, matchesWords } from '@codingame/monaco-vscode-api/vscode/vs/base/common/filters';
import { createSingleCallFunction } from '@codingame/monaco-vscode-api/vscode/vs/base/common/functional';
import { Disposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { LRUCache } from '@codingame/monaco-vscode-api/vscode/vs/base/common/map';
import { ThemeIcon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/themables';
import { TfIdfCalculator, normalizeTfIdfScores } from '@codingame/monaco-vscode-api/vscode/vs/base/common/tfIdf';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { ICommandService } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands.service';
import { IConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration.service';
import { IDialogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { IKeybindingService } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybinding.service';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { PickerQuickAccessProvider, TriggerAction } from '@codingame/monaco-vscode-api/vscode/vs/platform/quickinput/browser/pickerQuickAccess';
import { WillSaveStateReason, StorageScope, StorageTarget } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { ITelemetryService } from '@codingame/monaco-vscode-api/vscode/vs/platform/telemetry/common/telemetry.service';
import { Categories } from '@codingame/monaco-vscode-api/vscode/vs/platform/action/common/actionCommonCategories';

var AbstractCommandsQuickAccessProvider_1, CommandsHistory_1;
let AbstractCommandsQuickAccessProvider = class AbstractCommandsQuickAccessProvider extends PickerQuickAccessProvider {
    static { AbstractCommandsQuickAccessProvider_1 = this; }
    static { this.PREFIX = '>'; }
    static { this.TFIDF_THRESHOLD = 0.5; }
    static { this.TFIDF_MAX_RESULTS = 5; }
    static { this.WORD_FILTER = or(matchesBaseContiguousSubString, matchesWords); }
    constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
        super(AbstractCommandsQuickAccessProvider_1.PREFIX, options);
        this.keybindingService = keybindingService;
        this.commandService = commandService;
        this.telemetryService = telemetryService;
        this.dialogService = dialogService;
        this.commandsHistory = this._register(instantiationService.createInstance(CommandsHistory));
        this.options = options;
    }
    async _getPicks(filter, _disposables, token, runOptions) {
        const allCommandPicks = await this.getCommandPicks(token);
        if (token.isCancellationRequested) {
            return [];
        }
        const runTfidf = createSingleCallFunction(() => {
            const tfidf = ( new TfIdfCalculator());
            tfidf.updateDocuments(( allCommandPicks.map(commandPick => ({
                key: commandPick.commandId,
                textChunks: [this.getTfIdfChunk(commandPick)]
            }))));
            const result = tfidf.calculateScores(filter, token);
            return normalizeTfIdfScores(result)
                .filter(score => score.score > AbstractCommandsQuickAccessProvider_1.TFIDF_THRESHOLD)
                .slice(0, AbstractCommandsQuickAccessProvider_1.TFIDF_MAX_RESULTS);
        });
        const filteredCommandPicks = [];
        for (const commandPick of allCommandPicks) {
            const labelHighlights = AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter, commandPick.label) ?? undefined;
            let aliasHighlights;
            if (commandPick.commandAlias) {
                aliasHighlights = AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter, commandPick.commandAlias) ?? undefined;
            }
            if (labelHighlights || aliasHighlights) {
                commandPick.highlights = {
                    label: labelHighlights,
                    detail: this.options.showAlias ? aliasHighlights : undefined
                };
                filteredCommandPicks.push(commandPick);
            }
            else if (filter === commandPick.commandId) {
                filteredCommandPicks.push(commandPick);
            }
            else if (filter.length >= 3) {
                const tfidf = runTfidf();
                if (token.isCancellationRequested) {
                    return [];
                }
                const tfidfScore = tfidf.find(score => score.key === commandPick.commandId);
                if (tfidfScore) {
                    commandPick.tfIdfScore = tfidfScore.score;
                    filteredCommandPicks.push(commandPick);
                }
            }
        }
        const mapLabelToCommand = ( new Map());
        for (const commandPick of filteredCommandPicks) {
            const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);
            if (existingCommandForLabel) {
                commandPick.description = commandPick.commandId;
                existingCommandForLabel.description = existingCommandForLabel.commandId;
            }
            else {
                mapLabelToCommand.set(commandPick.label, commandPick);
            }
        }
        filteredCommandPicks.sort((commandPickA, commandPickB) => {
            if (commandPickA.tfIdfScore && commandPickB.tfIdfScore) {
                if (commandPickA.tfIdfScore === commandPickB.tfIdfScore) {
                    return commandPickA.label.localeCompare(commandPickB.label);
                }
                return commandPickB.tfIdfScore - commandPickA.tfIdfScore;
            }
            else if (commandPickA.tfIdfScore) {
                return 1;
            }
            else if (commandPickB.tfIdfScore) {
                return -1;
            }
            const commandACounter = this.commandsHistory.peek(commandPickA.commandId);
            const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);
            if (commandACounter && commandBCounter) {
                return commandACounter > commandBCounter ? -1 : 1;
            }
            if (commandACounter) {
                return -1;
            }
            if (commandBCounter) {
                return 1;
            }
            if (this.options.suggestedCommandIds) {
                const commandASuggestion = ( this.options.suggestedCommandIds.has(commandPickA.commandId));
                const commandBSuggestion = ( this.options.suggestedCommandIds.has(commandPickB.commandId));
                if (commandASuggestion && commandBSuggestion) {
                    return 0;
                }
                if (commandASuggestion) {
                    return -1;
                }
                if (commandBSuggestion) {
                    return 1;
                }
            }
            const isDeveloperA = commandPickA.commandCategory === Categories.Developer.value;
            const isDeveloperB = commandPickB.commandCategory === Categories.Developer.value;
            if (isDeveloperA && !isDeveloperB) {
                return 1;
            }
            if (!isDeveloperA && isDeveloperB) {
                return -1;
            }
            return commandPickA.label.localeCompare(commandPickB.label);
        });
        const commandPicks = [];
        let addOtherSeparator = false;
        let addSuggestedSeparator = true;
        let addCommonlyUsedSeparator = !!this.options.suggestedCommandIds;
        for (let i = 0; i < filteredCommandPicks.length; i++) {
            const commandPick = filteredCommandPicks[i];
            const isInHistory = !!this.commandsHistory.peek(commandPick.commandId);
            if (i === 0 && isInHistory) {
                commandPicks.push({ type: 'separator', label: ( localize(2007, "recently used")) });
                addOtherSeparator = true;
            }
            if (addSuggestedSeparator && commandPick.tfIdfScore !== undefined) {
                commandPicks.push({ type: 'separator', label: ( localize(2008, "similar commands")) });
                addSuggestedSeparator = false;
            }
            if (addCommonlyUsedSeparator && commandPick.tfIdfScore === undefined && !isInHistory && this.options.suggestedCommandIds?.has(commandPick.commandId)) {
                commandPicks.push({ type: 'separator', label: ( localize(2009, "commonly used")) });
                addOtherSeparator = true;
                addCommonlyUsedSeparator = false;
            }
            if (addOtherSeparator && commandPick.tfIdfScore === undefined && !isInHistory && !this.options.suggestedCommandIds?.has(commandPick.commandId)) {
                commandPicks.push({ type: 'separator', label: ( localize(2010, "other commands")) });
                addOtherSeparator = false;
            }
            commandPicks.push(this.toCommandPick(commandPick, runOptions, isInHistory));
        }
        if (!this.hasAdditionalCommandPicks(filter, token)) {
            return commandPicks;
        }
        return {
            picks: commandPicks,
            additionalPicks: (async () => {
                const additionalCommandPicks = await this.getAdditionalCommandPicks(allCommandPicks, filteredCommandPicks, filter, token);
                if (token.isCancellationRequested) {
                    return [];
                }
                const commandPicks = ( additionalCommandPicks.map(commandPick => this.toCommandPick(commandPick, runOptions)));
                if (addSuggestedSeparator && commandPicks[0]?.type !== 'separator') {
                    commandPicks.unshift({ type: 'separator', label: ( localize(2008, "similar commands")) });
                }
                return commandPicks;
            })()
        };
    }
    toCommandPick(commandPick, runOptions, isRecentlyUsed = false) {
        if (commandPick.type === 'separator') {
            return commandPick;
        }
        const tooltip = commandPick.tooltip
            ?? commandPick.commandDescription?.value;
        const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);
        const ariaLabel = keybinding ?
            ( localize(2011, "{0}, {1}", commandPick.label, keybinding.getAriaLabel())) :
            commandPick.label;
        const existingButtons = commandPick.buttons || [];
        const buttons = isRecentlyUsed ? [
            ...existingButtons,
            {
                iconClass: ThemeIcon.asClassName(Codicon.close),
                tooltip: ( localize(2012, "Remove from Recently Used"))
            }
        ] : commandPick.buttons;
        return {
            ...commandPick,
            tooltip,
            ariaLabel,
            detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : undefined,
            keybinding,
            buttons,
            accept: async () => {
                this.commandsHistory.push(commandPick.commandId);
                this.telemetryService.publicLog2('workbenchActionExecuted', {
                    id: commandPick.commandId,
                    from: runOptions?.from ?? 'quick open'
                });
                try {
                    commandPick.args?.length
                        ? await this.commandService.executeCommand(commandPick.commandId, ...commandPick.args)
                        : await this.commandService.executeCommand(commandPick.commandId);
                }
                catch (error) {
                    if (!isCancellationError(error)) {
                        this.dialogService.error(( localize(2013, "Command '{0}' resulted in an error", commandPick.label)), toErrorMessage(error));
                    }
                }
            },
            trigger: isRecentlyUsed ? (buttonIndex, keyMods) => {
                const removeButtonIndex = existingButtons.length;
                if (buttonIndex === removeButtonIndex) {
                    this.commandsHistory.remove(commandPick.commandId);
                    return TriggerAction.REMOVE_ITEM;
                }
                if (commandPick.trigger) {
                    return commandPick.trigger(buttonIndex, keyMods);
                }
                return TriggerAction.NO_ACTION;
            } : commandPick.trigger
        };
    }
    getTfIdfChunk({ label, commandAlias, commandDescription }) {
        let chunk = label;
        if (commandAlias && commandAlias !== label) {
            chunk += ` - ${commandAlias}`;
        }
        if (commandDescription && commandDescription.value !== label) {
            chunk += ` - ${commandDescription.value === commandDescription.original ? commandDescription.value : `${commandDescription.value} (${commandDescription.original})`}`;
        }
        return chunk;
    }
};
AbstractCommandsQuickAccessProvider = AbstractCommandsQuickAccessProvider_1 = ( __decorate([
    ( __param(1, IInstantiationService)),
    ( __param(2, IKeybindingService)),
    ( __param(3, ICommandService)),
    ( __param(4, ITelemetryService)),
    ( __param(5, IDialogService))
], AbstractCommandsQuickAccessProvider));
let CommandsHistory = class CommandsHistory extends Disposable {
    static { CommandsHistory_1 = this; }
    static { this.DEFAULT_COMMANDS_HISTORY_LENGTH = 50; }
    static { this.PREF_KEY_CACHE = 'commandPalette.mru.cache'; }
    static { this.PREF_KEY_COUNTER = 'commandPalette.mru.counter'; }
    static { this.counter = 1; }
    static { this.hasChanges = false; }
    constructor(storageService, configurationService, logService) {
        super();
        this.storageService = storageService;
        this.configurationService = configurationService;
        this.logService = logService;
        this.configuredCommandsHistoryLength = 0;
        this.updateConfiguration();
        this.load();
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.configurationService.onDidChangeConfiguration(e => this.updateConfiguration(e)));
        this._register(this.storageService.onWillSaveState(e => {
            if (e.reason === WillSaveStateReason.SHUTDOWN) {
                this.saveState();
            }
        }));
    }
    updateConfiguration(e) {
        if (e && !e.affectsConfiguration('workbench.commandPalette.history')) {
            return;
        }
        this.configuredCommandsHistoryLength = CommandsHistory_1.getConfiguredCommandHistoryLength(this.configurationService);
        if (CommandsHistory_1.cache && CommandsHistory_1.cache.limit !== this.configuredCommandsHistoryLength) {
            CommandsHistory_1.cache.limit = this.configuredCommandsHistoryLength;
            CommandsHistory_1.hasChanges = true;
        }
    }
    load() {
        const raw = this.storageService.get(CommandsHistory_1.PREF_KEY_CACHE, StorageScope.PROFILE);
        let serializedCache;
        if (raw) {
            try {
                serializedCache = JSON.parse(raw);
            }
            catch (error) {
                this.logService.error(`[CommandsHistory] invalid data: ${error}`);
            }
        }
        const cache = CommandsHistory_1.cache = ( new LRUCache(this.configuredCommandsHistoryLength, 1));
        if (serializedCache) {
            let entries;
            if (serializedCache.usesLRU) {
                entries = serializedCache.entries;
            }
            else {
                entries = serializedCache.entries.sort((a, b) => a.value - b.value);
            }
            entries.forEach(entry => cache.set(entry.key, entry.value));
        }
        CommandsHistory_1.counter = this.storageService.getNumber(CommandsHistory_1.PREF_KEY_COUNTER, StorageScope.PROFILE, CommandsHistory_1.counter);
    }
    push(commandId) {
        if (!CommandsHistory_1.cache) {
            return;
        }
        CommandsHistory_1.cache.set(commandId, CommandsHistory_1.counter++);
        CommandsHistory_1.hasChanges = true;
    }
    peek(commandId) {
        return CommandsHistory_1.cache?.peek(commandId);
    }
    remove(commandId) {
        if (!CommandsHistory_1.cache) {
            return;
        }
        CommandsHistory_1.cache.delete(commandId);
        CommandsHistory_1.hasChanges = true;
    }
    saveState() {
        if (!CommandsHistory_1.cache) {
            return;
        }
        if (!CommandsHistory_1.hasChanges) {
            return;
        }
        const serializedCache = { usesLRU: true, entries: [] };
        CommandsHistory_1.cache.forEach((value, key) => serializedCache.entries.push({ key, value }));
        this.storageService.store(CommandsHistory_1.PREF_KEY_CACHE, JSON.stringify(serializedCache), StorageScope.PROFILE, StorageTarget.USER);
        this.storageService.store(CommandsHistory_1.PREF_KEY_COUNTER, CommandsHistory_1.counter, StorageScope.PROFILE, StorageTarget.USER);
        CommandsHistory_1.hasChanges = false;
    }
    static getConfiguredCommandHistoryLength(configurationService) {
        const config = configurationService.getValue();
        const configuredCommandHistoryLength = config.workbench?.commandPalette?.history;
        if (typeof configuredCommandHistoryLength === 'number') {
            return configuredCommandHistoryLength;
        }
        return CommandsHistory_1.DEFAULT_COMMANDS_HISTORY_LENGTH;
    }
    static clearHistory(configurationService, storageService) {
        const commandHistoryLength = CommandsHistory_1.getConfiguredCommandHistoryLength(configurationService);
        CommandsHistory_1.cache = ( new LRUCache(commandHistoryLength));
        CommandsHistory_1.counter = 1;
        CommandsHistory_1.hasChanges = true;
    }
};
CommandsHistory = CommandsHistory_1 = ( __decorate([
    ( __param(0, IStorageService)),
    ( __param(1, IConfigurationService)),
    ( __param(2, ILogService))
], CommandsHistory));

export { AbstractCommandsQuickAccessProvider, CommandsHistory };
