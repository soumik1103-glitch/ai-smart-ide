
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { isFirefox } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/browser';
import { raceTimeout, timeout } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { stripIcons } from '@codingame/monaco-vscode-api/vscode/vs/base/common/iconLabels';
import { KeyCode, KeyMod } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keyCodes';
import { Language } from '@codingame/monaco-vscode-api/vscode/vs/base/common/platform';
import { ThemeIcon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/themables';
import { AbstractEditorCommandsQuickAccessProvider } from '../../../../editor/contrib/quickAccess/browser/commandsQuickAccess.js';
import { localize, localize2 } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { isLocalizedString } from '@codingame/monaco-vscode-api/vscode/vs/platform/action/common/action';
import { MenuId, MenuItemAction, Action2 } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { IMenuService } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions.service';
import { ICommandService } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands.service';
import { IConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration.service';
import { IDialogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { IKeybindingService } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybinding.service';
import { KeybindingWeight } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybindingsRegistry';
import { IProductService } from '@codingame/monaco-vscode-api/vscode/vs/platform/product/common/productService.service';
import { CommandsHistory } from '../../../../platform/quickinput/browser/commandsQuickAccess.js';
import { TriggerAction } from '@codingame/monaco-vscode-api/vscode/vs/platform/quickinput/browser/pickerQuickAccess';
import { DefaultQuickAccessFilterValue } from '@codingame/monaco-vscode-api/vscode/vs/platform/quickinput/common/quickAccess';
import { IQuickInputService } from '@codingame/monaco-vscode-api/vscode/vs/platform/quickinput/common/quickInput.service';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { ITelemetryService } from '@codingame/monaco-vscode-api/vscode/vs/platform/telemetry/common/telemetry.service';
import { ASK_QUICK_QUESTION_ACTION_ID, CHAT_OPEN_ACTION_ID } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/browser/actions/chatConstants';
import { RelatedInformationType } from '../../../services/aiRelatedInformation/common/aiRelatedInformation.js';
import { IAiRelatedInformationService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/aiRelatedInformation/common/aiRelatedInformation.service';
import { IEditorGroupsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorGroupsService.service';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { IExtensionService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions.service';
import { createKeybindingCommandQuery } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/preferences/browser/keybindingsEditorModel';
import { IPreferencesService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/preferences/common/preferences.service';
import { IChatAgentService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/participants/chatAgents.service';
import { ChatAgentLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/chat/common/constants';

var CommandsQuickAccessProvider_1;
let CommandsQuickAccessProvider = class CommandsQuickAccessProvider extends AbstractEditorCommandsQuickAccessProvider {
    static { CommandsQuickAccessProvider_1 = this; }
    static { this.AI_RELATED_INFORMATION_MAX_PICKS = 5; }
    static { this.AI_RELATED_INFORMATION_DEBOUNCE = 200; }
    get activeTextEditorControl() { return this.editorService.activeTextEditorControl; }
    get defaultFilterValue() {
        if (this.configuration.preserveInput) {
            return DefaultQuickAccessFilterValue.LAST;
        }
        return undefined;
    }
    constructor(editorService, menuService, extensionService, instantiationService, keybindingService, commandService, telemetryService, dialogService, configurationService, editorGroupService, preferencesService, productService, aiRelatedInformationService, chatAgentService) {
        super({
            showAlias: !Language.isDefaultVariant(),
            noResultsPick: () => ({
                label: ( localize(10190, "No matching commands")),
                commandId: ''
            }),
        }, instantiationService, keybindingService, commandService, telemetryService, dialogService);
        this.editorService = editorService;
        this.menuService = menuService;
        this.configurationService = configurationService;
        this.editorGroupService = editorGroupService;
        this.preferencesService = preferencesService;
        this.productService = productService;
        this.aiRelatedInformationService = aiRelatedInformationService;
        this.chatAgentService = chatAgentService;
        this.useAiRelatedInfo = false;
        this.extensionRegistrationRace = raceTimeout(extensionService.whenInstalledExtensionsRegistered(), 800);
        this._register(configurationService.onDidChangeConfiguration((e) => this.updateOptions(e)));
        this.updateOptions();
    }
    get configuration() {
        const commandPaletteConfig = this.configurationService.getValue().workbench.commandPalette;
        return {
            preserveInput: commandPaletteConfig.preserveInput,
            showAskInChat: commandPaletteConfig.showAskInChat,
            experimental: commandPaletteConfig.experimental
        };
    }
    updateOptions(e) {
        if (e && !e.affectsConfiguration('workbench.commandPalette.experimental')) {
            return;
        }
        const config = this.configuration;
        const suggestedCommandIds = config.experimental.suggestCommands && this.productService.commandPaletteSuggestedCommandIds?.length
            ? ( new Set(this.productService.commandPaletteSuggestedCommandIds))
            : undefined;
        this.options.suggestedCommandIds = suggestedCommandIds;
        this.useAiRelatedInfo = config.experimental.enableNaturalLanguageSearch;
    }
    async getCommandPicks(token) {
        await this.extensionRegistrationRace;
        if (token.isCancellationRequested) {
            return [];
        }
        return ([
            ...this.getCodeEditorCommandPicks(),
            ...this.getGlobalCommandPicks()
        ].map(picks => ({
            ...picks,
            buttons: [{
                    iconClass: ThemeIcon.asClassName(Codicon.gear),
                    tooltip: ( localize(10191, "Configure Keybinding")),
                }],
            trigger: () => {
                this.preferencesService.openGlobalKeybindingSettings(false, { query: createKeybindingCommandQuery(picks.commandId, picks.commandWhen) });
                return TriggerAction.CLOSE_PICKER;
            },
        })));
    }
    hasAdditionalCommandPicks(filter, token) {
        if (!this.useAiRelatedInfo
            || token.isCancellationRequested
            || filter === ''
            || !this.aiRelatedInformationService.isEnabled()) {
            return false;
        }
        return true;
    }
    async getAdditionalCommandPicks(allPicks, picksSoFar, filter, token) {
        if (!this.hasAdditionalCommandPicks(filter, token)) {
            return [];
        }
        let additionalPicks = [];
        try {
            await timeout(CommandsQuickAccessProvider_1.AI_RELATED_INFORMATION_DEBOUNCE, token);
            additionalPicks = await this.getRelatedInformationPicks(allPicks, picksSoFar, filter, token);
        }
        catch (e) {
        }
        if (this.configuration.showAskInChat) {
            const defaultAgent = this.chatAgentService.getDefaultAgent(ChatAgentLocation.Chat);
            if (defaultAgent) {
                if (picksSoFar.length || additionalPicks.length) {
                    additionalPicks.push({
                        type: 'separator'
                    });
                }
                additionalPicks.push({
                    label: ( localize(10192, "Ask in Chat: {0}", filter)),
                    commandId: this.configuration.experimental.askChatLocation === 'quickChat' ? ASK_QUICK_QUESTION_ACTION_ID : CHAT_OPEN_ACTION_ID,
                    args: [filter],
                    buttons: [{
                            iconClass: ThemeIcon.asClassName(Codicon.gear),
                            tooltip: ( localize(10193, "Configure visibility")),
                        }],
                    trigger: () => {
                        void this.preferencesService.openSettings({ jsonEditor: false, query: 'workbench.commandPalette.showAskInChat' });
                        return TriggerAction.CLOSE_PICKER;
                    },
                });
            }
        }
        return additionalPicks;
    }
    async getRelatedInformationPicks(allPicks, picksSoFar, filter, token) {
        const relatedInformation = await this.aiRelatedInformationService.getRelatedInformation(filter, [RelatedInformationType.CommandInformation], token);
        relatedInformation.sort((a, b) => b.weight - a.weight);
        const setOfPicksSoFar = ( new Set(( picksSoFar.map(p => p.commandId))));
        const additionalPicks = ( new Array());
        for (const info of relatedInformation) {
            if (additionalPicks.length === CommandsQuickAccessProvider_1.AI_RELATED_INFORMATION_MAX_PICKS) {
                break;
            }
            const pick = allPicks.find(p => p.commandId === info.command && !( setOfPicksSoFar.has(p.commandId)));
            if (pick) {
                additionalPicks.push(pick);
            }
        }
        return additionalPicks;
    }
    getGlobalCommandPicks() {
        const globalCommandPicks = [];
        const scopedContextKeyService = this.editorService.activeEditorPane?.scopedContextKeyService || this.editorGroupService.activeGroup.scopedContextKeyService;
        const globalCommandsMenu = this.menuService.getMenuActions(MenuId.CommandPalette, scopedContextKeyService);
        const globalCommandsMenuActions = globalCommandsMenu
            .reduce((r, [, actions]) => [...r, ...actions], [])
            .filter(action => action instanceof MenuItemAction && action.enabled);
        for (const action of globalCommandsMenuActions) {
            let label = (typeof action.item.title === 'string' ? action.item.title : action.item.title.value) || action.item.id;
            const category = typeof action.item.category === 'string' ? action.item.category : action.item.category?.value;
            if (category) {
                label = ( localize(10194, "{0}: {1}", category, label));
            }
            const aliasLabel = typeof action.item.title !== 'string' ? action.item.title.original : undefined;
            const aliasCategory = (category && action.item.category && typeof action.item.category !== 'string') ? action.item.category.original : undefined;
            const commandAlias = (aliasLabel && category) ?
                aliasCategory ? `${aliasCategory}: ${aliasLabel}` : `${category}: ${aliasLabel}` :
                aliasLabel;
            const metadataDescription = action.item.metadata?.description;
            const commandDescription = metadataDescription === undefined || isLocalizedString(metadataDescription)
                ? metadataDescription
                : { value: metadataDescription, original: metadataDescription };
            globalCommandPicks.push({
                commandId: action.item.id,
                commandWhen: action.item.precondition?.serialize(),
                commandAlias,
                label: stripIcons(label),
                commandDescription,
                commandCategory: category,
            });
        }
        return globalCommandPicks;
    }
};
CommandsQuickAccessProvider = CommandsQuickAccessProvider_1 = ( __decorate([
    ( __param(0, IEditorService)),
    ( __param(1, IMenuService)),
    ( __param(2, IExtensionService)),
    ( __param(3, IInstantiationService)),
    ( __param(4, IKeybindingService)),
    ( __param(5, ICommandService)),
    ( __param(6, ITelemetryService)),
    ( __param(7, IDialogService)),
    ( __param(8, IConfigurationService)),
    ( __param(9, IEditorGroupsService)),
    ( __param(10, IPreferencesService)),
    ( __param(11, IProductService)),
    ( __param(12, IAiRelatedInformationService)),
    ( __param(13, IChatAgentService))
], CommandsQuickAccessProvider));
class ShowAllCommandsAction extends Action2 {
    static { this.ID = 'workbench.action.showCommands'; }
    constructor() {
        super({
            id: ShowAllCommandsAction.ID,
            title: ( localize2(10195, 'Show All Commands')),
            keybinding: {
                weight: KeybindingWeight.WorkbenchContrib,
                when: undefined,
                primary: !isFirefox ? (KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KeyP) : undefined,
                secondary: [KeyCode.F1]
            },
            f1: true
        });
    }
    async run(accessor) {
        accessor.get(IQuickInputService).quickAccess.show(CommandsQuickAccessProvider.PREFIX);
    }
}
class ClearCommandHistoryAction extends Action2 {
    constructor() {
        super({
            id: 'workbench.action.clearCommandHistory',
            title: ( localize2(10196, 'Clear Command History')),
            f1: true
        });
    }
    async run(accessor) {
        const configurationService = accessor.get(IConfigurationService);
        const storageService = accessor.get(IStorageService);
        const dialogService = accessor.get(IDialogService);
        const commandHistoryLength = CommandsHistory.getConfiguredCommandHistoryLength(configurationService);
        if (commandHistoryLength > 0) {
            const { confirmed } = await dialogService.confirm({
                type: 'warning',
                message: ( localize(10197, "Do you want to clear the history of recently used commands?")),
                detail: ( localize(10198, "This action is irreversible!")),
                primaryButton: ( localize(10199, "&&Clear"))
            });
            if (!confirmed) {
                return;
            }
            CommandsHistory.clearHistory(configurationService, storageService);
        }
    }
}

export { ClearCommandHistoryAction, CommandsQuickAccessProvider, ShowAllCommandsAction };
