
import '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/style';
import { createElement, runWhenWindowIdle } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';
import { Emitter, setGlobalLeakWarningThreshold, Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { timeout, RunOnceScheduler } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { isChrome, isFirefox, isSafari } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/browser';
import { mark } from '@codingame/monaco-vscode-api/vscode/vs/base/common/performance';
import { onUnexpectedError, setUnexpectedErrorHandler } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errors';
import { isNative, isMacintosh, isWindows, isLinux, isWeb } from '@codingame/monaco-vscode-api/vscode/vs/base/common/platform';
import { getSingletonServiceDescriptors } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/extensions';
import { Parts, Position, positionToString } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/layout/browser/layoutService';
import { IWorkbenchLayoutService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/layout/browser/layoutService.service';
import { WillSaveStateReason, StorageScope, StorageTarget } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { IConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration.service';
import { LifecyclePhase } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/lifecycle/common/lifecycle';
import { ILifecycleService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/lifecycle/common/lifecycle.service';
import { INotificationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification.service';
import { NotificationsCenter } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/notifications/notificationsCenter';
import { NotificationsAlerts } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/notifications/notificationsAlerts';
import { NotificationsStatus } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/notifications/notificationsStatus';
import { registerNotificationCommands } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/notifications/notificationsCommands';
import { NotificationsToasts } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/notifications/notificationsToasts';
import { setARIAContainer } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/aria/aria';
import { FontMeasurements } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/config/fontMeasurements';
import { createBareFontInfoFromRawSettings } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/config/fontInfoFromSettings';
import { toErrorMessage } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errorMessage';
import { coalesce } from '@codingame/monaco-vscode-api/vscode/vs/base/common/arrays';
import { InstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiationService';
import { Layout } from './layout.js';
import { IHostService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/host/browser/host.service';
import { IDialogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service';
import { mainWindow } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/window';
import { PixelRatio } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/pixelRatio';
import { AccessibilityProgressSignalScheduler } from '@codingame/monaco-vscode-api/vscode/vs/platform/accessibilitySignal/browser/progressAccessibilitySignalScheduler';
import { setProgressAccessibilitySignalScheduler } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/progressbar/progressAccessibilitySignal';
import { AccessibleViewRegistry } from '@codingame/monaco-vscode-api/vscode/vs/platform/accessibility/browser/accessibleViewRegistry';
import { NotificationAccessibleView } from './parts/notifications/notificationAccessibleView.js';
import { IMarkdownRendererService } from '@codingame/monaco-vscode-api/vscode/vs/platform/markdown/browser/markdownRenderer.service';
import { EditorMarkdownCodeBlockRenderer } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/widget/markdownRenderer/browser/editorMarkdownCodeBlockRenderer';

class Workbench extends Layout {
    constructor(parent, options, serviceCollection, logService) {
        super(parent, { resetLayout: options?.resetLayout, customEditorRestore: options?.customEditorRestore });
        this.options = options;
        this.serviceCollection = serviceCollection;
        this._onWillShutdown = this._register(( new Emitter()));
        this.onWillShutdown = this._onWillShutdown.event;
        this._onDidShutdown = this._register(( new Emitter()));
        this.onDidShutdown = this._onDidShutdown.event;
        this.previousUnexpectedError = { message: undefined, time: 0 };
        mark('code/willStartWorkbench');
        this.registerErrorHandler(logService);
        this.parent.appendChild(this.mainContainer);
    }
    registerErrorHandler(logService) {
        mainWindow.addEventListener('unhandledrejection', (event) => {
            onUnexpectedError(event.reason);
            event.preventDefault();
        });
        setUnexpectedErrorHandler(error => this.handleUnexpectedError(error, logService));
    }
    handleUnexpectedError(error, logService) {
        const message = toErrorMessage(error, true);
        if (!message) {
            return;
        }
        const now = Date.now();
        if (message === this.previousUnexpectedError.message && now - this.previousUnexpectedError.time <= 1000) {
            return;
        }
        this.previousUnexpectedError.time = now;
        this.previousUnexpectedError.message = message;
        logService.error(message);
    }
    startup() {
        try {
            this._register(setGlobalLeakWarningThreshold(175));
            const instantiationService = this.initServices(this.serviceCollection);
            instantiationService.invokeFunction(accessor => {
                const lifecycleService = accessor.get(ILifecycleService);
                const storageService = accessor.get(IStorageService);
                const configurationService = accessor.get(IConfigurationService);
                const hostService = accessor.get(IHostService);
                const dialogService = accessor.get(IDialogService);
                const notificationService = accessor.get(INotificationService);
                const markdownRendererService = accessor.get(IMarkdownRendererService);
                markdownRendererService.setDefaultCodeBlockRenderer(instantiationService.createInstance(EditorMarkdownCodeBlockRenderer));
                this.initLayout(accessor);
                this.registerListeners(lifecycleService, storageService, configurationService, hostService, dialogService);
                this.renderWorkbench(instantiationService, notificationService, storageService, configurationService);
                this.createWorkbenchLayout();
                this.layout();
                this.restore(instantiationService, lifecycleService);
            });
            return instantiationService;
        }
        catch (error) {
            onUnexpectedError(error);
            throw error;
        }
    }
    initServices(serviceCollection) {
        serviceCollection.set(IWorkbenchLayoutService, this);
        const contributedServices = getSingletonServiceDescriptors();
        for (const [id, descriptor] of contributedServices) {
            serviceCollection.set(id, descriptor);
        }
        const instantiationService = ( new InstantiationService(serviceCollection, true));
        instantiationService.invokeFunction(accessor => {
            const lifecycleService = accessor.get(ILifecycleService);
            const configurationService = accessor.get(IConfigurationService);
            if (configurationService && 'acquireInstantiationService' in configurationService) {
                configurationService.acquireInstantiationService(instantiationService);
            }
            lifecycleService.phase = LifecyclePhase.Ready;
        });
        return instantiationService;
    }
    registerListeners(lifecycleService, storageService, configurationService, hostService, dialogService) {
        this._register(configurationService.onDidChangeConfiguration(e => this.updateFontAliasing(e, configurationService)));
        if (isNative) {
            this._register(storageService.onWillSaveState(e => {
                if (e.reason === WillSaveStateReason.SHUTDOWN) {
                    this.storeFontInfo(storageService);
                }
            }));
        }
        else {
            this._register(lifecycleService.onWillShutdown(() => this.storeFontInfo(storageService)));
        }
        this._register(lifecycleService.onWillShutdown(event => this._onWillShutdown.fire(event)));
        this._register(lifecycleService.onDidShutdown(() => {
            this._onDidShutdown.fire();
            this.dispose();
        }));
        this._register(hostService.onDidChangeFocus(focus => {
            if (!focus) {
                storageService.flush();
            }
        }));
        this._register(dialogService.onWillShowDialog(() => this.mainContainer.classList.add('modal-dialog-visible')));
        this._register(dialogService.onDidShowDialog(() => this.mainContainer.classList.remove('modal-dialog-visible')));
    }
    updateFontAliasing(e, configurationService) {
        if (!isMacintosh) {
            return;
        }
        if (e && !e.affectsConfiguration('workbench.fontAliasing')) {
            return;
        }
        const aliasing = configurationService.getValue('workbench.fontAliasing');
        if (this.fontAliasing === aliasing) {
            return;
        }
        this.fontAliasing = aliasing;
        const fontAliasingValues = ['antialiased', 'none', 'auto'];
        this.mainContainer.classList.remove(...( fontAliasingValues.map(value => `monaco-font-aliasing-${value}`)));
        if (( fontAliasingValues.some(option => option === aliasing))) {
            this.mainContainer.classList.add(`monaco-font-aliasing-${aliasing}`);
        }
    }
    restoreFontInfo(storageService, configurationService) {
        const storedFontInfoRaw = storageService.get('editorFontInfo', StorageScope.APPLICATION);
        if (storedFontInfoRaw) {
            try {
                const storedFontInfo = JSON.parse(storedFontInfoRaw);
                if (Array.isArray(storedFontInfo)) {
                    FontMeasurements.restoreFontInfo(mainWindow, storedFontInfo);
                }
            }
            catch (err) {
            }
        }
        FontMeasurements.readFontInfo(mainWindow, createBareFontInfoFromRawSettings(configurationService.getValue('editor'), PixelRatio.getInstance(mainWindow).value));
    }
    storeFontInfo(storageService) {
        const serializedFontInfo = FontMeasurements.serializeFontInfo(mainWindow);
        if (serializedFontInfo) {
            storageService.store('editorFontInfo', JSON.stringify(serializedFontInfo), StorageScope.APPLICATION, StorageTarget.MACHINE);
        }
    }
    renderWorkbench(instantiationService, notificationService, storageService, configurationService) {
        setARIAContainer(this.mainContainer);
        setProgressAccessibilitySignalScheduler((msDelayTime, msLoopTime) => instantiationService.createInstance(AccessibilityProgressSignalScheduler, msDelayTime, msLoopTime));
        const platformClass = isWindows ? 'windows' : isLinux ? 'linux' : 'mac';
        const workbenchClasses = coalesce([
            'monaco-workbench',
            platformClass,
            isWeb ? 'web' : undefined,
            isChrome ? 'chromium' : isFirefox ? 'firefox' : isSafari ? 'safari' : undefined,
            ...this.getLayoutClasses(),
            ...(this.options?.extraClasses ? this.options.extraClasses : [])
        ]);
        this.mainContainer.classList.add(...workbenchClasses);
        this.updateFontAliasing(undefined, configurationService);
        this.restoreFontInfo(storageService, configurationService);
        for (const { id, role, classes, options } of [
            { id: Parts.TITLEBAR_PART, role: 'none', classes: ['titlebar'] },
            { id: Parts.BANNER_PART, role: 'banner', classes: ['banner'] },
            { id: Parts.ACTIVITYBAR_PART, role: 'none', classes: ['activitybar', this.getSideBarPosition() === Position.LEFT ? 'left' : 'right'] },
            { id: Parts.SIDEBAR_PART, role: 'none', classes: ['sidebar', this.getSideBarPosition() === Position.LEFT ? 'left' : 'right'] },
            { id: Parts.EDITOR_PART, role: 'main', classes: ['editor'], options: { restorePreviousState: this.willRestoreEditors() } },
            { id: Parts.PANEL_PART, role: 'none', classes: ['panel', 'basepanel', positionToString(this.getPanelPosition())] },
            { id: Parts.AUXILIARYBAR_PART, role: 'none', classes: ['auxiliarybar', 'basepanel', this.getSideBarPosition() === Position.LEFT ? 'right' : 'left'] },
            { id: Parts.STATUSBAR_PART, role: 'status', classes: ['statusbar'] }
        ]) {
            const partContainer = this.createPart(id, role, classes);
            mark(`code/willCreatePart/${id}`);
            this.getPart(id).create(partContainer, options);
            mark(`code/didCreatePart/${id}`);
        }
        this.createNotificationsHandlers(instantiationService, notificationService);
    }
    createPart(id, role, classes) {
        const part = createElement(role === 'status' ? 'footer'  : 'div');
        part.classList.add('part', ...classes);
        part.id = id;
        part.setAttribute('role', role);
        if (role === 'status') {
            part.setAttribute('aria-live', 'off');
        }
        return part;
    }
    createNotificationsHandlers(instantiationService, notificationService) {
        const notificationsCenter = this._register(instantiationService.createInstance(NotificationsCenter, this.mainContainer, notificationService.model));
        const notificationsToasts = this._register(instantiationService.createInstance(NotificationsToasts, this.mainContainer, notificationService.model));
        this._register(instantiationService.createInstance(NotificationsAlerts, notificationService.model));
        const notificationsStatus = instantiationService.createInstance(NotificationsStatus, notificationService.model);
        this._register(notificationsCenter.onDidChangeVisibility(() => {
            notificationsStatus.update(notificationsCenter.isVisible, notificationsToasts.isVisible);
            notificationsToasts.update(notificationsCenter.isVisible);
        }));
        this._register(notificationsToasts.onDidChangeVisibility(() => {
            notificationsStatus.update(notificationsCenter.isVisible, notificationsToasts.isVisible);
        }));
        registerNotificationCommands(notificationsCenter, notificationsToasts, notificationService.model);
        AccessibleViewRegistry.register(( new NotificationAccessibleView()));
        this.registerNotifications({
            onDidChangeNotificationsVisibility: ( Event.map(
                Event.any(notificationsToasts.onDidChangeVisibility, notificationsCenter.onDidChangeVisibility),
                () => notificationsToasts.isVisible || notificationsCenter.isVisible
            ))
        });
    }
    restore(instantiationService, lifecycleService) {
        try {
            this.restoreParts(instantiationService);
        }
        catch (error) {
            onUnexpectedError(error);
        }
        this.whenReady.finally(() => Promise.race([
            this.whenRestored,
            timeout(2000)
        ]).finally(() => {
            function markDidStartWorkbench() {
                mark('code/didStartWorkbench');
                performance.measure('perf: workbench create & restore', 'code/didLoadWorkbenchMain', 'code/didStartWorkbench');
            }
            if (this.isRestored()) {
                markDidStartWorkbench();
            }
            else {
                this.whenRestored.finally(() => markDidStartWorkbench());
            }
            lifecycleService.phase = LifecyclePhase.Restored;
            const eventuallyPhaseScheduler = this._register(( new RunOnceScheduler(() => {
                this._register(runWhenWindowIdle(mainWindow, () => lifecycleService.phase = LifecyclePhase.Eventually, 2500));
            }, 2500)));
            eventuallyPhaseScheduler.schedule();
        }));
    }
}

export { Workbench };
