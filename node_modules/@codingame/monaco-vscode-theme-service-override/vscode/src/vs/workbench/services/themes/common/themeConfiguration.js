
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { isUndefined } from '@codingame/monaco-vscode-api/vscode/vs/base/common/types';
import { Registry } from '@codingame/monaco-vscode-api/vscode/vs/platform/registry/common/platform';
import { Extensions, ConfigurationScope } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configurationRegistry';
import { textmateColorGroupSchemaId, textmateColorsSchemaId } from './colorThemeSchema.js';
import { workbenchColorsSchemaId } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colorUtils';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/baseColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/chartsColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/editorColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/inputColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/listColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/menuColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/minimapColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/miscColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/quickpickColors';
import '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/colors/searchColors';
import { tokenStylingSchemaId } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/tokenClassificationRegistry';
import { ThemeSettingDefaults, ThemeSettings } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/themes/common/workbenchThemeService';
import { ConfigurationTarget } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration';
import { isWeb } from '@codingame/monaco-vscode-api/vscode/vs/base/common/platform';
import { ColorScheme } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/theme';

const configurationRegistry = ( Registry.as(Extensions.Configuration));
const colorThemeSettingEnum = [];
const colorThemeSettingEnumItemLabels = [];
const colorThemeSettingEnumDescriptions = [];
function formatSettingAsLink(str) {
    return `\`#${str}#\``;
}
const COLOR_THEME_CONFIGURATION_SETTINGS_TAG = 'colorThemeConfiguration';
const colorThemeSettingSchema = {
    type: 'string',
    markdownDescription: ( localize(
        14434,
        "Specifies the color theme used in the workbench when {0} is not enabled.",
        formatSettingAsLink(ThemeSettings.DETECT_COLOR_SCHEME)
    )),
    default: isWeb ? ThemeSettingDefaults.COLOR_THEME_LIGHT : ThemeSettingDefaults.COLOR_THEME_DARK,
    tags: [COLOR_THEME_CONFIGURATION_SETTINGS_TAG],
    enum: colorThemeSettingEnum,
    enumDescriptions: colorThemeSettingEnumDescriptions,
    enumItemLabels: colorThemeSettingEnumItemLabels,
    errorMessage: ( localize(14435, "Theme is unknown or not installed.")),
};
const preferredDarkThemeSettingSchema = {
    type: 'string',
    markdownDescription: ( localize(
        14436,
        'Specifies the color theme when system color mode is dark and {0} is enabled.',
        formatSettingAsLink(ThemeSettings.DETECT_COLOR_SCHEME)
    )),
    default: ThemeSettingDefaults.COLOR_THEME_DARK,
    tags: [COLOR_THEME_CONFIGURATION_SETTINGS_TAG],
    enum: colorThemeSettingEnum,
    enumDescriptions: colorThemeSettingEnumDescriptions,
    enumItemLabels: colorThemeSettingEnumItemLabels,
    errorMessage: ( localize(14435, "Theme is unknown or not installed.")),
};
const preferredLightThemeSettingSchema = {
    type: 'string',
    markdownDescription: ( localize(
        14437,
        'Specifies the color theme when system color mode is light and {0} is enabled.',
        formatSettingAsLink(ThemeSettings.DETECT_COLOR_SCHEME)
    )),
    default: ThemeSettingDefaults.COLOR_THEME_LIGHT,
    tags: [COLOR_THEME_CONFIGURATION_SETTINGS_TAG],
    enum: colorThemeSettingEnum,
    enumDescriptions: colorThemeSettingEnumDescriptions,
    enumItemLabels: colorThemeSettingEnumItemLabels,
    errorMessage: ( localize(14435, "Theme is unknown or not installed.")),
};
const preferredHCDarkThemeSettingSchema = {
    type: 'string',
    markdownDescription: ( localize(
        14438,
        'Specifies the color theme when in high contrast dark mode and {0} is enabled.',
        formatSettingAsLink(ThemeSettings.DETECT_HC)
    )),
    default: ThemeSettingDefaults.COLOR_THEME_HC_DARK,
    tags: [COLOR_THEME_CONFIGURATION_SETTINGS_TAG],
    enum: colorThemeSettingEnum,
    enumDescriptions: colorThemeSettingEnumDescriptions,
    enumItemLabels: colorThemeSettingEnumItemLabels,
    errorMessage: ( localize(14435, "Theme is unknown or not installed.")),
};
const preferredHCLightThemeSettingSchema = {
    type: 'string',
    markdownDescription: ( localize(
        14439,
        'Specifies the color theme when in high contrast light mode and {0} is enabled.',
        formatSettingAsLink(ThemeSettings.DETECT_HC)
    )),
    default: ThemeSettingDefaults.COLOR_THEME_HC_LIGHT,
    tags: [COLOR_THEME_CONFIGURATION_SETTINGS_TAG],
    enum: colorThemeSettingEnum,
    enumDescriptions: colorThemeSettingEnumDescriptions,
    enumItemLabels: colorThemeSettingEnumItemLabels,
    errorMessage: ( localize(14435, "Theme is unknown or not installed.")),
};
const detectColorSchemeSettingSchema = {
    type: 'boolean',
    markdownDescription: ( localize(
        14440,
        'If enabled, will automatically select a color theme based on the system color mode. If the system color mode is dark, {0} is used, else {1}.',
        formatSettingAsLink(ThemeSettings.PREFERRED_DARK_THEME),
        formatSettingAsLink(ThemeSettings.PREFERRED_LIGHT_THEME)
    )),
    default: false,
    tags: [COLOR_THEME_CONFIGURATION_SETTINGS_TAG],
};
const colorCustomizationsSchema = {
    type: 'object',
    description: ( localize(14441, "Overrides colors from the currently selected color theme.")),
    allOf: [{ $ref: workbenchColorsSchemaId }],
    default: {},
    defaultSnippets: [{
            body: {}
        }]
};
const fileIconThemeSettingSchema = {
    type: ['string', 'null'],
    default: ThemeSettingDefaults.FILE_ICON_THEME,
    description: ( localize(
        14442,
        "Specifies the file icon theme used in the workbench or 'null' to not show any file icons."
    )),
    enum: [null],
    enumItemLabels: [( localize(14443, 'None'))],
    enumDescriptions: [( localize(14444, 'No file icons'))],
    errorMessage: ( localize(14445, "File icon theme is unknown or not installed."))
};
const productIconThemeSettingSchema = {
    type: ['string', 'null'],
    default: ThemeSettingDefaults.PRODUCT_ICON_THEME,
    description: ( localize(14446, "Specifies the product icon theme used.")),
    enum: [ThemeSettingDefaults.PRODUCT_ICON_THEME],
    enumItemLabels: [( localize(14447, 'Default'))],
    enumDescriptions: [( localize(14448, 'Default'))],
    errorMessage: ( localize(14449, "Product icon theme is unknown or not installed."))
};
const detectHCSchemeSettingSchema = {
    type: 'boolean',
    default: true,
    markdownDescription: ( localize(
        14450,
        "If enabled, will automatically change to high contrast theme if the OS is using a high contrast theme. The high contrast theme to use is specified by {0} and {1}.",
        formatSettingAsLink(ThemeSettings.PREFERRED_HC_DARK_THEME),
        formatSettingAsLink(ThemeSettings.PREFERRED_HC_LIGHT_THEME)
    )),
    scope: ConfigurationScope.APPLICATION,
    tags: [COLOR_THEME_CONFIGURATION_SETTINGS_TAG],
};
const themeSettingsConfiguration = {
    id: 'workbench',
    order: 7.1,
    type: 'object',
    properties: {
        [ThemeSettings.COLOR_THEME]: colorThemeSettingSchema,
        [ThemeSettings.PREFERRED_DARK_THEME]: preferredDarkThemeSettingSchema,
        [ThemeSettings.PREFERRED_LIGHT_THEME]: preferredLightThemeSettingSchema,
        [ThemeSettings.PREFERRED_HC_DARK_THEME]: preferredHCDarkThemeSettingSchema,
        [ThemeSettings.PREFERRED_HC_LIGHT_THEME]: preferredHCLightThemeSettingSchema,
        [ThemeSettings.FILE_ICON_THEME]: fileIconThemeSettingSchema,
        [ThemeSettings.COLOR_CUSTOMIZATIONS]: colorCustomizationsSchema,
        [ThemeSettings.PRODUCT_ICON_THEME]: productIconThemeSettingSchema
    }
};
configurationRegistry.registerConfiguration(themeSettingsConfiguration);
const themeSettingsWindowConfiguration = {
    id: 'window',
    order: 8.1,
    type: 'object',
    properties: {
        [ThemeSettings.DETECT_HC]: detectHCSchemeSettingSchema,
        [ThemeSettings.DETECT_COLOR_SCHEME]: detectColorSchemeSettingSchema,
    }
};
configurationRegistry.registerConfiguration(themeSettingsWindowConfiguration);
function tokenGroupSettings(description) {
    return {
        description,
        $ref: textmateColorGroupSchemaId
    };
}
const themeSpecificSettingKey = '^\\[[^\\]]*(\\]\\s*\\[[^\\]]*)*\\]$';
const tokenColorSchema = {
    type: 'object',
    properties: {
        comments: tokenGroupSettings(( localize(14451, "Sets the colors and styles for comments"))),
        strings: tokenGroupSettings(( localize(14452, "Sets the colors and styles for strings literals."))),
        keywords: tokenGroupSettings(( localize(14453, "Sets the colors and styles for keywords."))),
        numbers: tokenGroupSettings(( localize(14454, "Sets the colors and styles for number literals."))),
        types: tokenGroupSettings(( localize(14455, "Sets the colors and styles for type declarations and references."))),
        functions: tokenGroupSettings(( localize(
            14456,
            "Sets the colors and styles for functions declarations and references."
        ))),
        variables: tokenGroupSettings(( localize(
            14457,
            "Sets the colors and styles for variables declarations and references."
        ))),
        textMateRules: {
            description: ( localize(14458, 'Sets colors and styles using textmate theming rules (advanced).')),
            $ref: textmateColorsSchemaId
        },
        semanticHighlighting: {
            description: ( localize(14459, 'Whether semantic highlighting should be enabled for this theme.')),
            deprecationMessage: ( localize(
                14460,
                'Use `enabled` in `editor.semanticTokenColorCustomizations` setting instead.'
            )),
            markdownDeprecationMessage: ( localize(
                14461,
                'Use `enabled` in {0} setting instead.',
                formatSettingAsLink('editor.semanticTokenColorCustomizations')
            )),
            type: 'boolean'
        }
    },
    additionalProperties: false
};
const tokenColorCustomizationSchema = {
    description: ( localize(
        14462,
        "Overrides editor syntax colors and font style from the currently selected color theme."
    )),
    default: {},
    allOf: [{ ...tokenColorSchema, patternProperties: { '^\\[': {} } }]
};
const semanticTokenColorSchema = {
    type: 'object',
    properties: {
        enabled: {
            type: 'boolean',
            description: ( localize(
                14463,
                'Whether semantic highlighting is enabled or disabled for this theme'
            )),
            suggestSortText: '0_enabled'
        },
        rules: {
            $ref: tokenStylingSchemaId,
            description: ( localize(14464, 'Semantic token styling rules for this theme.')),
            suggestSortText: '0_rules'
        }
    },
    additionalProperties: false
};
const semanticTokenColorCustomizationSchema = {
    description: ( localize(
        14465,
        "Overrides editor semantic token color and styles from the currently selected color theme."
    )),
    default: {},
    allOf: [{ ...semanticTokenColorSchema, patternProperties: { '^\\[': {} } }]
};
const tokenColorCustomizationConfiguration = {
    id: 'editor',
    order: 7.2,
    type: 'object',
    properties: {
        [ThemeSettings.TOKEN_COLOR_CUSTOMIZATIONS]: tokenColorCustomizationSchema,
        [ThemeSettings.SEMANTIC_TOKEN_COLOR_CUSTOMIZATIONS]: semanticTokenColorCustomizationSchema
    }
};
configurationRegistry.registerConfiguration(tokenColorCustomizationConfiguration);
function updateColorThemeConfigurationSchemas(themes) {
    themes.sort((a, b) => a.label.localeCompare(b.label));
    colorThemeSettingEnum.splice(0, colorThemeSettingEnum.length, ...( themes.map(t => t.settingsId)));
    colorThemeSettingEnumDescriptions.splice(0, colorThemeSettingEnumDescriptions.length, ...( themes.map(t => t.description || '')));
    colorThemeSettingEnumItemLabels.splice(0, colorThemeSettingEnumItemLabels.length, ...( themes.map(t => t.label || '')));
    const themeSpecificWorkbenchColors = { properties: {} };
    const themeSpecificTokenColors = { properties: {} };
    const themeSpecificSemanticTokenColors = { properties: {} };
    const workbenchColors = { $ref: workbenchColorsSchemaId, additionalProperties: false };
    const tokenColors = { properties: tokenColorSchema.properties, additionalProperties: false };
    for (const t of themes) {
        const themeId = `[${t.settingsId}]`;
        themeSpecificWorkbenchColors.properties[themeId] = workbenchColors;
        themeSpecificTokenColors.properties[themeId] = tokenColors;
        themeSpecificSemanticTokenColors.properties[themeId] = semanticTokenColorSchema;
    }
    themeSpecificWorkbenchColors.patternProperties = { [themeSpecificSettingKey]: workbenchColors };
    themeSpecificTokenColors.patternProperties = { [themeSpecificSettingKey]: tokenColors };
    themeSpecificSemanticTokenColors.patternProperties = { [themeSpecificSettingKey]: semanticTokenColorSchema };
    colorCustomizationsSchema.allOf[1] = themeSpecificWorkbenchColors;
    tokenColorCustomizationSchema.allOf[1] = themeSpecificTokenColors;
    semanticTokenColorCustomizationSchema.allOf[1] = themeSpecificSemanticTokenColors;
    configurationRegistry.notifyConfigurationSchemaUpdated(themeSettingsConfiguration, tokenColorCustomizationConfiguration);
}
function updateFileIconThemeConfigurationSchemas(themes) {
    fileIconThemeSettingSchema.enum.splice(1, Number.MAX_VALUE, ...( themes.map(t => t.settingsId)));
    fileIconThemeSettingSchema.enumItemLabels.splice(1, Number.MAX_VALUE, ...( themes.map(t => t.label)));
    fileIconThemeSettingSchema.enumDescriptions.splice(1, Number.MAX_VALUE, ...( themes.map(t => t.description || '')));
    configurationRegistry.notifyConfigurationSchemaUpdated(themeSettingsConfiguration);
}
function updateProductIconThemeConfigurationSchemas(themes) {
    productIconThemeSettingSchema.enum.splice(1, Number.MAX_VALUE, ...( themes.map(t => t.settingsId)));
    productIconThemeSettingSchema.enumItemLabels.splice(1, Number.MAX_VALUE, ...( themes.map(t => t.label)));
    productIconThemeSettingSchema.enumDescriptions.splice(1, Number.MAX_VALUE, ...( themes.map(t => t.description || '')));
    configurationRegistry.notifyConfigurationSchemaUpdated(themeSettingsConfiguration);
}
const colorSchemeToPreferred = {
    [ColorScheme.DARK]: ThemeSettings.PREFERRED_DARK_THEME,
    [ColorScheme.LIGHT]: ThemeSettings.PREFERRED_LIGHT_THEME,
    [ColorScheme.HIGH_CONTRAST_DARK]: ThemeSettings.PREFERRED_HC_DARK_THEME,
    [ColorScheme.HIGH_CONTRAST_LIGHT]: ThemeSettings.PREFERRED_HC_LIGHT_THEME
};
class ThemeConfiguration {
    constructor(configurationService, hostColorService) {
        this.configurationService = configurationService;
        this.hostColorService = hostColorService;
    }
    get colorTheme() {
        return this.configurationService.getValue(this.getColorThemeSettingId());
    }
    get fileIconTheme() {
        return this.configurationService.getValue(ThemeSettings.FILE_ICON_THEME);
    }
    get productIconTheme() {
        return this.configurationService.getValue(ThemeSettings.PRODUCT_ICON_THEME);
    }
    get colorCustomizations() {
        return this.configurationService.getValue(ThemeSettings.COLOR_CUSTOMIZATIONS) || {};
    }
    get tokenColorCustomizations() {
        return this.configurationService.getValue(ThemeSettings.TOKEN_COLOR_CUSTOMIZATIONS) || {};
    }
    get semanticTokenColorCustomizations() {
        return this.configurationService.getValue(ThemeSettings.SEMANTIC_TOKEN_COLOR_CUSTOMIZATIONS);
    }
    getPreferredColorScheme() {
        if (this.configurationService.getValue(ThemeSettings.DETECT_HC) && this.hostColorService.highContrast) {
            return this.hostColorService.dark ? ColorScheme.HIGH_CONTRAST_DARK : ColorScheme.HIGH_CONTRAST_LIGHT;
        }
        if (this.configurationService.getValue(ThemeSettings.DETECT_COLOR_SCHEME)) {
            return this.hostColorService.dark ? ColorScheme.DARK : ColorScheme.LIGHT;
        }
        return undefined;
    }
    isDetectingColorScheme() {
        return this.configurationService.getValue(ThemeSettings.DETECT_COLOR_SCHEME);
    }
    getColorThemeSettingId() {
        const preferredScheme = this.getPreferredColorScheme();
        return preferredScheme ? colorSchemeToPreferred[preferredScheme] : ThemeSettings.COLOR_THEME;
    }
    async setColorTheme(theme, settingsTarget) {
        await this.writeConfiguration(this.getColorThemeSettingId(), theme.settingsId, settingsTarget);
        return theme;
    }
    async setFileIconTheme(theme, settingsTarget) {
        await this.writeConfiguration(ThemeSettings.FILE_ICON_THEME, theme.settingsId, settingsTarget);
        return theme;
    }
    async setProductIconTheme(theme, settingsTarget) {
        await this.writeConfiguration(ThemeSettings.PRODUCT_ICON_THEME, theme.settingsId, settingsTarget);
        return theme;
    }
    isDefaultColorTheme() {
        const settings = this.configurationService.inspect(this.getColorThemeSettingId());
        return settings && settings.default?.value === settings.value;
    }
    findAutoConfigurationTarget(key) {
        const settings = this.configurationService.inspect(key);
        if (!isUndefined(settings.workspaceFolderValue)) {
            return ConfigurationTarget.WORKSPACE_FOLDER;
        }
        else if (!isUndefined(settings.workspaceValue)) {
            return ConfigurationTarget.WORKSPACE;
        }
        else if (!isUndefined(settings.userRemote)) {
            return ConfigurationTarget.USER_REMOTE;
        }
        return ConfigurationTarget.USER;
    }
    async writeConfiguration(key, value, settingsTarget) {
        if (settingsTarget === undefined || settingsTarget === 'preview') {
            return;
        }
        const settings = this.configurationService.inspect(key);
        if (settingsTarget === 'auto') {
            return this.configurationService.updateValue(key, value);
        }
        if (settingsTarget === ConfigurationTarget.USER) {
            if (value === settings.userValue) {
                return Promise.resolve(undefined);
            }
            else if (value === settings.defaultValue) {
                if (isUndefined(settings.userValue)) {
                    return Promise.resolve(undefined);
                }
                value = undefined;
            }
        }
        else if (settingsTarget === ConfigurationTarget.WORKSPACE || settingsTarget === ConfigurationTarget.WORKSPACE_FOLDER || settingsTarget === ConfigurationTarget.USER_REMOTE) {
            if (value === settings.value) {
                return Promise.resolve(undefined);
            }
        }
        return this.configurationService.updateValue(key, value, settingsTarget);
    }
}

export { COLOR_THEME_CONFIGURATION_SETTINGS_TAG, ThemeConfiguration, formatSettingAsLink, updateColorThemeConfigurationSchemas, updateFileIconThemeConfigurationSchemas, updateProductIconThemeConfigurationSchemas };
