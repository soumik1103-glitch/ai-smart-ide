
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { coalesce } from '@codingame/monaco-vscode-api/vscode/vs/base/common/arrays';
import { Promises } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { mark } from '@codingame/monaco-vscode-api/vscode/vs/base/common/performance';
import { isWeb } from '@codingame/monaco-vscode-api/vscode/vs/base/common/platform';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { StandaloneServices } from '@codingame/monaco-vscode-api/vscode/vs/editor/standalone/browser/standaloneServices';
import { IConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/configuration/common/configuration.service';
import { IEnvironmentService } from '@codingame/monaco-vscode-api/vscode/vs/platform/environment/common/environment.service';
import { IFileService } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service';
import { SyncDescriptor } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/descriptors';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { ILayoutService } from '@codingame/monaco-vscode-api/vscode/vs/platform/layout/browser/layoutService.service';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { StorageScope } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { isTemporaryWorkspace, WorkbenchState } from '@codingame/monaco-vscode-api/vscode/vs/platform/workspace/common/workspace';
import { IWorkspaceContextService } from '@codingame/monaco-vscode-api/vscode/vs/platform/workspace/common/workspace.service';
import '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/part';
export { ActivitybarPart } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/activitybar/activitybarPart';
import { AuxiliaryBarPart } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/auxiliarybar/auxiliaryBarPart';
import '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/editor/editorPart';
import { EditorParts } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/editor/editorParts';
import { PanelPart } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/panel/panelPart';
export { PanelPart } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/panel/panelPart';
import { SidebarPart } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/sidebar/sidebarPart';
export { SidebarPart } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/sidebar/sidebarPart';
import { pathsToEditors, isResourceEditorInput } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor';
export { EditorInputCapabilities } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor';
import { ViewContainerLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/views';
export { ViewContainerLocation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/views';
import { IViewDescriptorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/views.service';
export { ActivityService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/activity/browser/activityService';
import { GroupsOrder } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorGroupsService';
export { GroupOrientation } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorGroupsService';
import { IEditorGroupsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorGroupsService.service';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { IExtensionService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions.service';
import { Parts, Position, positionToString } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/layout/browser/layoutService';
export { Parts, Position } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/layout/browser/layoutService';
import { StartupKind } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/lifecycle/common/lifecycle';
import { ILifecycleService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/lifecycle/common/lifecycle.service';
import { IPaneCompositePartService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/panecomposite/browser/panecomposite.service';
import { onRenderWorkbench } from '@codingame/monaco-vscode-api/lifecycle';
import '@codingame/monaco-vscode-api/monaco';
import getServiceOverride$1 from '@codingame/monaco-vscode-keybindings-service-override';
import '@codingame/monaco-vscode-layout-service-override';
import getServiceOverride$2 from '@codingame/monaco-vscode-quickaccess-service-override';
import { MonacoDelegateEditorGroupsService, MonacoEditorService } from '@codingame/monaco-vscode-api/service-override/tools/editor';
import getServiceOverride$3 from '@codingame/monaco-vscode-view-common-service-override';
export { EditorPane, SimpleEditorInput, SimpleEditorPane, getPanelPosition, getSideBarPosition, isPartVisibile, onDidChangePanelPosition, onDidChangeSideBarPosition, registerCustomView, registerEditor, registerEditorPane, registerEditorSerializer, setPartVisibility, viewContainerRegistry, viewRegistry } from '@codingame/monaco-vscode-api/service-override/tools/views';
export { AbstractResourceEditorInput } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor/resourceEditorInput';
export { AbstractTextResourceEditorInput } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor/textResourceEditorInput';
export { ConfirmResult } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs';
export { DomScrollableElement } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/scrollbar/scrollableElement';
export { EditorInput } from '@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor/editorInput';
export { RegisteredEditorPriority } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorResolverService';
export { SplitView } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/splitview/splitview';
export { ViewPaneContainer } from '@codingame/monaco-vscode-api/vscode/vs/workbench/browser/parts/views/viewPaneContainer';

function createPart(id, role, classes) {
    const part = document.createElement(role === 'status' ? 'footer'  : 'div');
    part.classList.add('part', 'monaco-workbench-part', ...classes);
    part.id = id;
    part.setAttribute('role', role);
    if (role === 'status') {
        part.setAttribute('aria-live', 'off');
    }
    return part;
}
function layoutPart(part) {
    const parent = part.getContainer()?.parentNode;
    if (parent == null) {
        return;
    }
    part.layout(Math.max(part.minimumWidth, Math.min(part.maximumWidth, parent.offsetWidth)), Math.max(part.minimumHeight, Math.min(part.maximumHeight, parent.offsetHeight)), parent.offsetTop, parent.offsetLeft);
}
function renderPart(partContainer, part) {
    partContainer.oncontextmenu = () => false;
    function layout() {
        layoutPart(part);
    }
    part.onDidVisibilityChange((visible) => {
        if (visible) {
            layout();
        }
    });
    layout();
}
function getPart(part) {
    return StandaloneServices.get(ILayoutService).getPart(part);
}
function _attachPart(part, container) {
    container.append(part.getContainer());
    const observer = new ResizeObserver(() => layoutPart(part));
    observer.observe(container);
    return {
        dispose() {
            return observer.disconnect();
        }
    };
}
function attachPart(part, container) {
    const _part = getPart(part);
    if (_part == null) {
        throw new Error('Part not found');
    }
    return _attachPart(_part, container);
}
function onPartVisibilityChange(part, listener) {
    const _part = getPart(part);
    if (_part == null) {
        throw new Error('Part not found');
    }
    return _part.onDidVisibilityChange(listener);
}
function renderActivitybarPar(container) {
    return attachPart(Parts.ACTIVITYBAR_PART, container);
}
function renderSidebarPart(container) {
    return attachPart(Parts.SIDEBAR_PART, container);
}
function renderPanelPart(container) {
    return attachPart(Parts.PANEL_PART, container);
}
function renderAuxiliaryPart(container) {
    return attachPart(Parts.AUXILIARYBAR_PART, container);
}
function renderEditorPart(container) {
    return attachPart(Parts.EDITOR_PART, container);
}
function renderStatusBarPart(container) {
    return attachPart(Parts.STATUSBAR_PART, container);
}
function isElementVisible(el) {
    if (!el.isConnected) {
        return false;
    }
    if (el.checkVisibility != null) {
        return el.checkVisibility({
            checkOpacity: true,
            checkVisibilityCSS: true
        });
    }
    return el.offsetHeight > 0 && el.offsetWidth > 0;
}
function isEditorPartVisible() {
    const container = StandaloneServices.get(IEditorGroupsService).mainPart.getContainer();
    return container != null && isElementVisible(container);
}
let MonacoEditorParts = class MonacoEditorParts extends MonacoDelegateEditorGroupsService {
    constructor(openEditorFallback, instantiationService) {
        super(instantiationService.createInstance(EditorParts), false, openEditorFallback, instantiationService);
        this.restoreGroup = (...args) => {
            return this.delegate.restoreGroup(...args);
        };
    }
    getId() {
        return 'standalone';
    }
    updateStyles() { }
    registerPart(part) {
        return this.delegate.registerPart(part);
    }
    bind(contextKey, group) {
        return this.delegate.bind(contextKey, group);
    }
    get activePart() {
        return this.delegate.activePart;
    }
};
MonacoEditorParts = __decorate([
    __param(1, IInstantiationService)
], MonacoEditorParts);
let transformInitializationState = (state) => state;
onRenderWorkbench(async (accessor) => {
    const paneCompositePartService = accessor.get(IPaneCompositePartService);
    const viewDescriptorService = accessor.get(IViewDescriptorService);
    const lifecycleService = accessor.get(ILifecycleService);
    const storageService = accessor.get(IStorageService);
    const editorGroupService = accessor.get(IEditorGroupsService);
    const editorService = accessor.get(IEditorService);
    const logService = accessor.get(ILogService);
    const extensionService = accessor.get(IExtensionService);
    const environmentService = accessor.get(IEnvironmentService);
    const contextService = accessor.get(IWorkspaceContextService);
    const configurationService = accessor.get(IConfigurationService);
    const fileService = accessor.get(IFileService);
    const layoutService = accessor.get(ILayoutService);
    function getInitialEditorsState() {
        const defaultLayout = environmentService.options?.defaultLayout;
        if (((defaultLayout?.editors != null && defaultLayout.editors.length > 0) ||
            defaultLayout?.layout?.editors != null) &&
            ((defaultLayout.force ?? false) || storageService.isNew(StorageScope.WORKSPACE))) {
            return {
                layout: defaultLayout.layout?.editors,
                filesToOpenOrCreate: defaultLayout.editors?.map((editor) => {
                    return {
                        viewColumn: editor.viewColumn,
                        fileUri: URI.revive(editor.uri),
                        openOnlyIfExists: editor.openOnlyIfExists,
                        options: editor.options
                    };
                })
            };
        }
        const { filesToOpenOrCreate, filesToDiff, filesToMerge } = environmentService;
        if (filesToOpenOrCreate != null || filesToDiff != null || filesToMerge != null) {
            return { filesToOpenOrCreate, filesToDiff, filesToMerge };
        }
        return undefined;
    }
    function getDefaultLayoutViews(environmentService, storageService) {
        const defaultLayout = environmentService.options?.defaultLayout;
        if (defaultLayout == null) {
            return undefined;
        }
        if (!(defaultLayout.force ?? false) && !storageService.isNew(StorageScope.WORKSPACE)) {
            return undefined;
        }
        const { views } = defaultLayout;
        if (views != null && views.length > 0) {
            return views.map((view) => view.id);
        }
        return undefined;
    }
    function shouldRestoreEditors(contextService, initialEditorsState) {
        if (isTemporaryWorkspace(contextService.getWorkspace())) {
            return false;
        }
        const forceRestoreEditors = configurationService.getValue('window.restoreWindows') === 'preserve';
        return !!forceRestoreEditors || initialEditorsState === undefined;
    }
    async function resolveEditorsToOpen(fileService, initialEditorsState) {
        if (initialEditorsState != null) {
            const filesToMerge = coalesce(await pathsToEditors(initialEditorsState.filesToMerge, fileService, logService));
            if (filesToMerge.length === 4 &&
                isResourceEditorInput(filesToMerge[0]) &&
                isResourceEditorInput(filesToMerge[1]) &&
                isResourceEditorInput(filesToMerge[2]) &&
                isResourceEditorInput(filesToMerge[3])) {
                return [
                    {
                        editor: {
                            input1: { resource: filesToMerge[0].resource },
                            input2: { resource: filesToMerge[1].resource },
                            base: { resource: filesToMerge[2].resource },
                            result: { resource: filesToMerge[3].resource },
                            options: { pinned: true }
                        }
                    }
                ];
            }
            const filesToDiff = coalesce(await pathsToEditors(initialEditorsState.filesToDiff, fileService, logService));
            if (filesToDiff.length === 2) {
                return [
                    {
                        editor: {
                            original: { resource: filesToDiff[0].resource },
                            modified: { resource: filesToDiff[1].resource },
                            options: { pinned: true }
                        }
                    }
                ];
            }
            const filesToOpenOrCreate = [];
            const resolvedFilesToOpenOrCreate = await pathsToEditors(initialEditorsState.filesToOpenOrCreate, fileService, logService);
            for (let i = 0; i < resolvedFilesToOpenOrCreate.length; i++) {
                const resolvedFileToOpenOrCreate = resolvedFilesToOpenOrCreate[i];
                if (resolvedFileToOpenOrCreate != null) {
                    filesToOpenOrCreate.push({
                        editor: resolvedFileToOpenOrCreate,
                        viewColumn: initialEditorsState.filesToOpenOrCreate?.[i].viewColumn
                    });
                }
            }
            return filesToOpenOrCreate;
        }
        else if (contextService.getWorkbenchState() === WorkbenchState.EMPTY &&
            configurationService.getValue('workbench.startupEditor') === 'newUntitledFile') {
            if (editorGroupService.mainPart.hasRestorableState) {
                return [];
            }
            return [
                {
                    editor: { resource: undefined }
                }
            ];
        }
        return [];
    }
    const initialEditorsState = getInitialEditorsState();
    if (initialEditorsState != null) {
        logService.info('Initial editor state', initialEditorsState);
    }
    let initialLayoutState = {
        layout: {
            editors: initialEditorsState?.layout
        },
        editor: {
            restoreEditors: shouldRestoreEditors(contextService, initialEditorsState),
            editorsToOpen: resolveEditorsToOpen(fileService, initialEditorsState)
        },
        views: {
            defaults: getDefaultLayoutViews(environmentService, storageService),
            containerToRestore: {}
        }
    };
    function getDefaultViewContainer(location) {
        return (viewDescriptorService.getDefaultViewContainer(location) ??
            viewDescriptorService.getViewContainersByLocation(location)[0]);
    }
    function initLayoutState() {
        if (layoutService.isVisible(Parts.SIDEBAR_PART)) {
            let viewContainerToRestore;
            if (!environmentService.isBuilt ||
                lifecycleService.startupKind === StartupKind.ReloadedWindow ||
                isWeb) {
                viewContainerToRestore = storageService.get(SidebarPart.activeViewletSettingsKey, StorageScope.WORKSPACE, getDefaultViewContainer(ViewContainerLocation.Sidebar)?.id);
            }
            else {
                viewContainerToRestore = getDefaultViewContainer(ViewContainerLocation.Sidebar)?.id;
            }
            initialLayoutState.views.containerToRestore.sideBar = viewContainerToRestore;
        }
        if (layoutService.isVisible(Parts.PANEL_PART)) {
            const viewContainerToRestore = storageService.get(PanelPart.activePanelSettingsKey, StorageScope.WORKSPACE, getDefaultViewContainer(ViewContainerLocation.Panel)?.id);
            initialLayoutState.views.containerToRestore.panel = viewContainerToRestore;
        }
        if (layoutService.isVisible(Parts.AUXILIARYBAR_PART)) {
            const viewContainerToRestore = storageService.get(AuxiliaryBarPart.activeViewSettingsKey, StorageScope.WORKSPACE, getDefaultViewContainer(ViewContainerLocation.AuxiliaryBar)?.id);
            initialLayoutState.views.containerToRestore.auxiliaryBar = viewContainerToRestore;
        }
    }
    initLayoutState();
    initialLayoutState = transformInitializationState(initialLayoutState);
    if (initialLayoutState.views.containerToRestore.sideBar == null) {
        layoutService.setPartHidden(true, Parts.SIDEBAR_PART);
    }
    if (initialLayoutState.views.containerToRestore.panel == null) {
        layoutService.setPartHidden(true, Parts.PANEL_PART);
    }
    if (initialLayoutState.views.containerToRestore.auxiliaryBar == null) {
        layoutService.setPartHidden(true, Parts.AUXILIARYBAR_PART);
    }
    const invisibleContainer = document.createElement('div');
    invisibleContainer.style.display = 'none';
    document.body.append(invisibleContainer);
    for (const { id, role, classes, options, getPosition, onDidChangePosition } of [
        { id: Parts.TITLEBAR_PART, role: 'none', classes: ['titlebar'] },
        { id: Parts.BANNER_PART, role: 'banner', classes: ['banner'] },
        {
            id: Parts.ACTIVITYBAR_PART,
            role: 'none',
            classes: ['activitybar'],
            getPosition: () => layoutService.getSideBarPosition(),
            onDidChangePosition: layoutService.onDidChangeSideBarPosition
        },
        {
            id: Parts.SIDEBAR_PART,
            role: 'none',
            classes: ['sidebar'],
            getPosition: () => layoutService.getSideBarPosition(),
            onDidChangePosition: layoutService.onDidChangeSideBarPosition
        },
        {
            id: Parts.EDITOR_PART,
            role: 'main',
            classes: ['editor'],
            options: { restorePreviousState: initialLayoutState.editor.restoreEditors }
        },
        {
            id: Parts.PANEL_PART,
            role: 'none',
            classes: ['panel', 'basepanel'],
            getPosition: () => layoutService.getPanelPosition(),
            onDidChangePosition: layoutService.onDidChangePanelPosition
        },
        {
            id: Parts.AUXILIARYBAR_PART,
            role: 'none',
            classes: ['auxiliarybar', 'basepanel'],
            getPosition: () => layoutService.getSideBarPosition() === Position.LEFT ? Position.RIGHT : Position.LEFT,
            onDidChangePosition: layoutService.onDidChangeSideBarPosition
        },
        { id: Parts.STATUSBAR_PART, role: 'status', classes: ['statusbar'] }
    ]) {
        const part = layoutService.getPart(id);
        if (part != null) {
            const partContainer = createPart(id, role, classes);
            part.create(partContainer, options);
            renderPart(partContainer, part);
            part.layout(9999, 9999, 0, 0);
            invisibleContainer.append(partContainer);
            if (getPosition != null) {
                let position = getPosition();
                part.element.classList.add(positionToString(position));
                onDidChangePosition?.(() => {
                    part.element.classList.remove(positionToString(position));
                    position = getPosition();
                    part.element.classList.add(positionToString(position));
                });
            }
        }
    }
    const layoutReadyPromises = [];
    const layoutRestoredPromises = [];
    layoutReadyPromises.push((async () => {
        mark('code/willRestoreEditors');
        await editorGroupService.mainPart.whenReady;
        mark('code/restoreEditors/editorGroupsReady');
        if (initialLayoutState.layout?.editors != null) {
            editorGroupService.applyLayout(initialLayoutState.layout.editors);
        }
        const editors = await initialLayoutState.editor.editorsToOpen;
        mark('code/restoreEditors/editorsToOpenResolved');
        let openEditorsPromise;
        if (editors.length > 0) {
            const editorGroupsInVisualOrder = editorGroupService.getGroups(GroupsOrder.GRID_APPEARANCE);
            const mapEditorsToGroup = new Map();
            for (const editor of editors) {
                const group = editorGroupsInVisualOrder[(editor.viewColumn ?? 1) - 1];
                let editorsByGroup = mapEditorsToGroup.get(group.id);
                if (editorsByGroup == null) {
                    editorsByGroup = new Set();
                    mapEditorsToGroup.set(group.id, editorsByGroup);
                }
                editorsByGroup.add(editor.editor);
            }
            openEditorsPromise = Promise.all(Array.from(mapEditorsToGroup).map(async ([groupId, editors]) => {
                try {
                    await editorService.openEditors(Array.from(editors), groupId, { validateTrust: true });
                }
                catch (error) {
                    logService.error(error);
                }
            }));
        }
        layoutRestoredPromises.push(Promise.all([
            openEditorsPromise?.finally(() => mark('code/restoreEditors/editorsOpened')),
            editorGroupService.mainPart.whenRestored.finally(() => mark('code/restoreEditors/editorGroupsRestored'))
        ]).finally(() => {
            mark('code/didRestoreEditors');
        }));
    })());
    const restoreDefaultViewsPromise = (async () => {
        if (initialLayoutState.views.defaults != null && initialLayoutState.views.defaults.length > 0) {
            mark('code/willOpenDefaultViews');
            const locationsRestored = [];
            const tryOpenView = (view) => {
                const location = viewDescriptorService.getViewLocationById(view.id);
                if (location !== null) {
                    const container = viewDescriptorService.getViewContainerByViewId(view.id);
                    if (container != null) {
                        if (view.order >= (locationsRestored[location]?.order ?? 0)) {
                            locationsRestored[location] = { id: container.id, order: view.order };
                        }
                        const containerModel = viewDescriptorService.getViewContainerModel(container);
                        containerModel.setCollapsed(view.id, false);
                        containerModel.setVisible(view.id, true);
                        return true;
                    }
                }
                return false;
            };
            const defaultViews = [...initialLayoutState.views.defaults]
                .reverse()
                .map((v, index) => ({ id: v, order: index }));
            let i = defaultViews.length;
            while (i > 0) {
                i--;
                if (tryOpenView(defaultViews[i])) {
                    defaultViews.splice(i, 1);
                }
            }
            if (defaultViews.length > 0) {
                await extensionService.whenInstalledExtensionsRegistered();
                let i = defaultViews.length;
                while (i > 0) {
                    i--;
                    if (tryOpenView(defaultViews[i])) {
                        defaultViews.splice(i, 1);
                    }
                }
            }
            if (locationsRestored[ViewContainerLocation.Sidebar] != null) {
                initialLayoutState.views.containerToRestore.sideBar =
                    locationsRestored[ViewContainerLocation.Sidebar].id;
            }
            if (locationsRestored[ViewContainerLocation.Panel] != null) {
                initialLayoutState.views.containerToRestore.panel =
                    locationsRestored[ViewContainerLocation.Panel].id;
            }
            if (locationsRestored[ViewContainerLocation.AuxiliaryBar] != null) {
                initialLayoutState.views.containerToRestore.auxiliaryBar =
                    locationsRestored[ViewContainerLocation.AuxiliaryBar].id;
            }
            mark('code/didOpenDefaultViews');
        }
    })();
    layoutReadyPromises.push(restoreDefaultViewsPromise);
    layoutReadyPromises.push((async () => {
        await restoreDefaultViewsPromise;
        if (initialLayoutState.views.containerToRestore.sideBar == null) {
            return;
        }
        mark('code/willRestoreViewlet');
        const viewlet = await paneCompositePartService.openPaneComposite(initialLayoutState.views.containerToRestore.sideBar, ViewContainerLocation.Sidebar);
        if (viewlet == null) {
            await paneCompositePartService.openPaneComposite(getDefaultViewContainer(ViewContainerLocation.Sidebar)?.id, ViewContainerLocation.Sidebar);
        }
        mark('code/didRestoreViewlet');
    })());
    layoutReadyPromises.push((async () => {
        await restoreDefaultViewsPromise;
        if (initialLayoutState.views.containerToRestore.panel == null) {
            return;
        }
        mark('code/willRestorePanel');
        const panel = await paneCompositePartService.openPaneComposite(initialLayoutState.views.containerToRestore.panel, ViewContainerLocation.Panel);
        if (panel == null) {
            await paneCompositePartService.openPaneComposite(getDefaultViewContainer(ViewContainerLocation.Panel)?.id, ViewContainerLocation.Panel);
        }
        mark('code/didRestorePanel');
    })());
    layoutReadyPromises.push((async () => {
        await restoreDefaultViewsPromise;
        if (initialLayoutState.views.containerToRestore.auxiliaryBar == null) {
            return;
        }
        mark('code/willRestoreAuxiliaryBar');
        const panel = await paneCompositePartService.openPaneComposite(initialLayoutState.views.containerToRestore.auxiliaryBar, ViewContainerLocation.AuxiliaryBar);
        if (panel == null) {
            await paneCompositePartService.openPaneComposite(getDefaultViewContainer(ViewContainerLocation.AuxiliaryBar)?.id, ViewContainerLocation.AuxiliaryBar);
        }
        mark('code/didRestoreAuxiliaryBar');
    })());
    await Promises.settled(layoutReadyPromises);
    await Promises.settled(layoutRestoredPromises);
});
function getServiceOverride(openEditorFallback, _webviewIframeAlternateDomains, initializationStateOrRestoreEditors) {
    if (initializationStateOrRestoreEditors != null) {
        transformInitializationState =
            typeof initializationStateOrRestoreEditors === 'boolean'
                ? (state) => ({
                    ...state,
                    editor: {
                        ...state.editor,
                        restoreEditors: initializationStateOrRestoreEditors
                    }
                })
                : initializationStateOrRestoreEditors;
    }
    return {
        ...getServiceOverride$3(_webviewIframeAlternateDomains),
        ...getServiceOverride$2({
            isKeybindingConfigurationVisible: isEditorPartVisible,
            shouldUseGlobalPicker: isEditorPartVisible
        }),
        ...getServiceOverride$1({
            shouldUseGlobalKeybindings: isEditorPartVisible
        }),
        [IEditorGroupsService.toString()]: new SyncDescriptor(MonacoEditorParts, [openEditorFallback], false),
        [IEditorService.toString()]: new SyncDescriptor(MonacoEditorService, [openEditorFallback, isEditorPartVisible], false)
    };
}

export { attachPart, getServiceOverride as default, isEditorPartVisible, onPartVisibilityChange, renderActivitybarPar, renderAuxiliaryPart, renderEditorPart, renderPanelPart, renderPart, renderSidebarPart, renderStatusBarPart };
