
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { ITextModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/resolverService.service';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { ILanguageService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages/language.service';
import { IModelService } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/services/model.service';
import { createTextBufferFactoryFromSnapshot } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/model/textModel';
import { DisposableStore } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { coalesceInPlace } from '@codingame/monaco-vscode-api/vscode/vs/base/common/arrays';
import { Range } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/range';
import { EditOperation } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/editOperation';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { IFileService } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service';
import { Emitter, Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { ConflictDetector } from '../conflicts.js';
import { ResourceMap } from '@codingame/monaco-vscode-api/vscode/vs/base/common/map';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { extUri } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { ResourceTextEdit, ResourceFileEdit } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/services/bulkEditService';
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { generateUuid } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uuid';
import { SnippetParser } from '@codingame/monaco-vscode-api/vscode/vs/editor/contrib/snippet/browser/snippetParser';
import { MicrotaskDelay } from '@codingame/monaco-vscode-api/vscode/vs/base/common/symbols';
import { Schemas } from '@codingame/monaco-vscode-api/vscode/vs/base/common/network';

var BulkFileOperations_1, BulkEditPreviewProvider_1;
class CheckedStates {
    constructor() {
        this._states = ( new WeakMap());
        this._checkedCount = 0;
        this._onDidChange = ( new Emitter());
        this.onDidChange = this._onDidChange.event;
    }
    dispose() {
        this._onDidChange.dispose();
    }
    get checkedCount() {
        return this._checkedCount;
    }
    isChecked(obj) {
        return this._states.get(obj) ?? false;
    }
    updateChecked(obj, value) {
        const valueNow = this._states.get(obj);
        if (valueNow === value) {
            return;
        }
        if (valueNow === undefined) {
            if (value) {
                this._checkedCount += 1;
            }
        }
        else {
            if (value) {
                this._checkedCount += 1;
            }
            else {
                this._checkedCount -= 1;
            }
        }
        this._states.set(obj, value);
        this._onDidChange.fire(obj);
    }
}
class BulkTextEdit {
    constructor(parent, textEdit) {
        this.parent = parent;
        this.textEdit = textEdit;
    }
}
var BulkFileOperationType;
(function (BulkFileOperationType) {
    BulkFileOperationType[BulkFileOperationType["TextEdit"] = 1] = "TextEdit";
    BulkFileOperationType[BulkFileOperationType["Create"] = 2] = "Create";
    BulkFileOperationType[BulkFileOperationType["Delete"] = 4] = "Delete";
    BulkFileOperationType[BulkFileOperationType["Rename"] = 8] = "Rename";
})(BulkFileOperationType || (BulkFileOperationType = {}));
class BulkFileOperation {
    constructor(uri, parent) {
        this.uri = uri;
        this.parent = parent;
        this.type = 0;
        this.textEdits = [];
        this.originalEdits = ( new Map());
    }
    addEdit(index, type, edit) {
        this.type |= type;
        this.originalEdits.set(index, edit);
        if (edit instanceof ResourceTextEdit) {
            this.textEdits.push(( new BulkTextEdit(this, edit)));
        }
        else if (type === BulkFileOperationType.Rename) {
            this.newUri = edit.newResource;
        }
    }
    needsConfirmation() {
        for (const [, edit] of this.originalEdits) {
            if (!this.parent.checked.isChecked(edit)) {
                return true;
            }
        }
        return false;
    }
}
class BulkCategory {
    static { this._defaultMetadata = ( Object.freeze({
        label: ( localize(4536, "Other")),
        icon: Codicon.symbolFile,
        needsConfirmation: false
    })); }
    static keyOf(metadata) {
        return metadata?.label || '<default>';
    }
    constructor(metadata = BulkCategory._defaultMetadata) {
        this.metadata = metadata;
        this.operationByResource = ( new Map());
    }
    get fileOperations() {
        return ( this.operationByResource.values());
    }
}
let BulkFileOperations = BulkFileOperations_1 = class BulkFileOperations {
    static async create(accessor, bulkEdit) {
        const result = accessor.get(IInstantiationService).createInstance(BulkFileOperations_1, bulkEdit);
        return await result._init();
    }
    constructor(_bulkEdit, _fileService, instaService) {
        this._bulkEdit = _bulkEdit;
        this._fileService = _fileService;
        this.checked = ( new CheckedStates());
        this.fileOperations = [];
        this.categories = [];
        this.conflicts = instaService.createInstance(ConflictDetector, _bulkEdit);
    }
    dispose() {
        this.checked.dispose();
        this.conflicts.dispose();
    }
    async _init() {
        const operationByResource = ( new Map());
        const operationByCategory = ( new Map());
        const newToOldUri = ( new ResourceMap());
        for (let idx = 0; idx < this._bulkEdit.length; idx++) {
            const edit = this._bulkEdit[idx];
            let uri;
            let type;
            this.checked.updateChecked(edit, !edit.metadata?.needsConfirmation);
            if (edit instanceof ResourceTextEdit) {
                type = BulkFileOperationType.TextEdit;
                uri = edit.resource;
            }
            else if (edit instanceof ResourceFileEdit) {
                if (edit.newResource && edit.oldResource) {
                    type = BulkFileOperationType.Rename;
                    uri = edit.oldResource;
                    if (edit.options?.overwrite === undefined && edit.options?.ignoreIfExists && (await this._fileService.exists(uri))) {
                        continue;
                    }
                    newToOldUri.set(edit.newResource, uri);
                }
                else if (edit.oldResource) {
                    type = BulkFileOperationType.Delete;
                    uri = edit.oldResource;
                    if (edit.options?.ignoreIfNotExists && !(await this._fileService.exists(uri))) {
                        continue;
                    }
                }
                else if (edit.newResource) {
                    type = BulkFileOperationType.Create;
                    uri = edit.newResource;
                    if (edit.options?.overwrite === undefined && edit.options?.ignoreIfExists && (await this._fileService.exists(uri))) {
                        continue;
                    }
                }
                else {
                    continue;
                }
            }
            else {
                continue;
            }
            const insert = (uri, map) => {
                let key = extUri.getComparisonKey(uri, true);
                let operation = map.get(key);
                if (!operation && ( newToOldUri.has(uri))) {
                    uri = newToOldUri.get(uri);
                    key = extUri.getComparisonKey(uri, true);
                    operation = map.get(key);
                }
                if (!operation) {
                    operation = ( new BulkFileOperation(uri, this));
                    map.set(key, operation);
                }
                operation.addEdit(idx, type, edit);
            };
            insert(uri, operationByResource);
            const key = BulkCategory.keyOf(edit.metadata);
            let category = operationByCategory.get(key);
            if (!category) {
                category = ( new BulkCategory(edit.metadata));
                operationByCategory.set(key, category);
            }
            insert(uri, category.operationByResource);
        }
        operationByResource.forEach(value => this.fileOperations.push(value));
        operationByCategory.forEach(value => this.categories.push(value));
        for (const file of this.fileOperations) {
            if (file.type !== BulkFileOperationType.TextEdit) {
                let checked = true;
                for (const edit of ( file.originalEdits.values())) {
                    if (edit instanceof ResourceFileEdit) {
                        checked = checked && this.checked.isChecked(edit);
                    }
                }
                if (!checked) {
                    for (const edit of ( file.originalEdits.values())) {
                        this.checked.updateChecked(edit, checked);
                    }
                }
            }
        }
        this.categories.sort((a, b) => {
            if (a.metadata.needsConfirmation === b.metadata.needsConfirmation) {
                return a.metadata.label.localeCompare(b.metadata.label);
            }
            else if (a.metadata.needsConfirmation) {
                return -1;
            }
            else {
                return 1;
            }
        });
        return this;
    }
    getWorkspaceEdit() {
        const result = [];
        let allAccepted = true;
        for (let i = 0; i < this._bulkEdit.length; i++) {
            const edit = this._bulkEdit[i];
            if (this.checked.isChecked(edit)) {
                result[i] = edit;
                continue;
            }
            allAccepted = false;
        }
        if (allAccepted) {
            return this._bulkEdit;
        }
        coalesceInPlace(result);
        return result;
    }
    async getFileEditOperation(edit) {
        const content = await edit.options.contents;
        if (!content) {
            return undefined;
        }
        return EditOperation.replaceMove(Range.lift({ startLineNumber: 0, startColumn: 0, endLineNumber: Number.MAX_VALUE, endColumn: 0 }), ( content.toString()));
    }
    async getFileEdits(uri) {
        for (const file of this.fileOperations) {
            if (( file.uri.toString()) === ( uri.toString())) {
                const result = [];
                let ignoreAll = false;
                for (const edit of ( file.originalEdits.values())) {
                    if (edit instanceof ResourceFileEdit) {
                        result.push(this.getFileEditOperation(edit));
                    }
                    else if (edit instanceof ResourceTextEdit) {
                        if (this.checked.isChecked(edit)) {
                            result.push(Promise.resolve(EditOperation.replaceMove(Range.lift(edit.textEdit.range), !edit.textEdit.insertAsSnippet ? edit.textEdit.text : SnippetParser.asInsertText(edit.textEdit.text))));
                        }
                    }
                    else if (!this.checked.isChecked(edit)) {
                        ignoreAll = true;
                    }
                }
                if (ignoreAll) {
                    return [];
                }
                return (await Promise.all(result)).filter(r => r !== undefined).sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
            }
        }
        return [];
    }
    getUriOfEdit(edit) {
        for (const file of this.fileOperations) {
            for (const value of ( file.originalEdits.values())) {
                if (value === edit) {
                    return file.uri;
                }
            }
        }
        throw ( new Error('invalid edit'));
    }
};
BulkFileOperations = BulkFileOperations_1 = ( __decorate([
    ( __param(1, IFileService)),
    ( __param(2, IInstantiationService))
], BulkFileOperations));
let BulkEditPreviewProvider = class BulkEditPreviewProvider {
    static { BulkEditPreviewProvider_1 = this; }
    static { this.Schema = 'vscode-bulkeditpreview-editor'; }
    static { this.emptyPreview = ( URI.from({ scheme: this.Schema, fragment: 'empty' })); }
    static fromPreviewUri(uri) {
        return ( URI.parse(uri.query));
    }
    constructor(_operations, _languageService, _modelService, _textModelResolverService) {
        this._operations = _operations;
        this._languageService = _languageService;
        this._modelService = _modelService;
        this._textModelResolverService = _textModelResolverService;
        this._disposables = ( new DisposableStore());
        this._modelPreviewEdits = ( new Map());
        this._instanceId = generateUuid();
        this._disposables.add(this._textModelResolverService.registerTextModelContentProvider(BulkEditPreviewProvider_1.Schema, this));
        this._ready = this._init();
    }
    dispose() {
        this._disposables.dispose();
    }
    asPreviewUri(uri) {
        const path = uri.scheme === Schemas.untitled ? `/${uri.path}` : uri.path;
        return ( URI.from(
            { scheme: BulkEditPreviewProvider_1.Schema, authority: this._instanceId, path, query: ( uri.toString()) }
        ));
    }
    async _init() {
        for (const operation of this._operations.fileOperations) {
            await this._applyTextEditsToPreviewModel(operation.uri);
        }
        this._disposables.add(Event.debounce(this._operations.checked.onDidChange, (_last, e) => e, MicrotaskDelay)(e => {
            const uri = this._operations.getUriOfEdit(e);
            this._applyTextEditsToPreviewModel(uri);
        }));
    }
    async _applyTextEditsToPreviewModel(uri) {
        const model = await this._getOrCreatePreviewModel(uri);
        const undoEdits = this._modelPreviewEdits.get(model.id);
        if (undoEdits) {
            model.applyEdits(undoEdits);
        }
        const newEdits = await this._operations.getFileEdits(uri);
        const newUndoEdits = model.applyEdits(newEdits, true);
        this._modelPreviewEdits.set(model.id, newUndoEdits);
    }
    async _getOrCreatePreviewModel(uri) {
        const previewUri = this.asPreviewUri(uri);
        let model = this._modelService.getModel(previewUri);
        if (!model) {
            try {
                const ref = await this._textModelResolverService.createModelReference(uri);
                const sourceModel = ref.object.textEditorModel;
                model = this._modelService.createModel(createTextBufferFactoryFromSnapshot(sourceModel.createSnapshot()), this._languageService.createById(sourceModel.getLanguageId()), previewUri);
                ref.dispose();
            }
            catch {
                model = this._modelService.createModel('', this._languageService.createByFilepathOrFirstLine(previewUri), previewUri);
            }
            queueMicrotask(async () => {
                this._disposables.add(await this._textModelResolverService.createModelReference(model.uri));
            });
        }
        return model;
    }
    async provideTextContent(previewUri) {
        if (( previewUri.toString()) === ( BulkEditPreviewProvider_1.emptyPreview.toString())) {
            return this._modelService.createModel('', null, previewUri);
        }
        await this._ready;
        return this._modelService.getModel(previewUri);
    }
};
BulkEditPreviewProvider = BulkEditPreviewProvider_1 = ( __decorate([
    ( __param(1, ILanguageService)),
    ( __param(2, IModelService)),
    ( __param(3, ITextModelService))
], BulkEditPreviewProvider));

export { BulkCategory, BulkEditPreviewProvider, BulkFileOperation, BulkFileOperationType, BulkFileOperations, BulkTextEdit, CheckedStates };
