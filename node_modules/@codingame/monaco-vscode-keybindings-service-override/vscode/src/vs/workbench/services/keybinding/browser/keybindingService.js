
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { onDidChangeFullscreen, isFullscreen } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/browser';
import { BrowserFeatures, KeyboardSupport } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/canIUse';
import { onDidRegisterWindow, addDisposableListener, EventType, trackFocus, getWindow } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';
import { StandardKeyboardEvent, printKeyboardEvent, printStandardKeyboardEvent } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/keyboardEvent';
import { mainWindow } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/window';
import { DeferredPromise, RunOnceScheduler } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { Event, Emitter } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { parse } from '@codingame/monaco-vscode-api/vscode/vs/base/common/json';
import { UserSettingsLabelProvider } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keybindingLabels';
import { KeybindingParser } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keybindingParser';
import { KeyCodeChord, ScanCodeChord } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keybindings';
import { ScanCode, KeyCode, KeyCodeUtils, ScanCodeUtils, KeyMod, IMMUTABLE_CODE_TO_KEY_CODE } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keyCodes';
import { DisposableStore, toDisposable, Disposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { equals } from '@codingame/monaco-vscode-api/vscode/vs/base/common/objects';
import { OS, OperatingSystem, isMacintosh } from '@codingame/monaco-vscode-api/vscode/vs/base/common/platform';
import { dirname } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { isLocalizedString } from '@codingame/monaco-vscode-api/vscode/vs/platform/action/common/action';
import { MenuRegistry } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { CommandsRegistry } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands';
import { ICommandService } from '@codingame/monaco-vscode-api/vscode/vs/platform/commands/common/commands.service';
import { ContextKeyExpr } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { IContextKeyService } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey.service';
import { FileOperation } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files';
import { IFileService } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service';
import '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/extensions';
import { Extensions } from '@codingame/monaco-vscode-api/vscode/vs/platform/jsonschemas/common/jsonContributionRegistry';
import { AbstractKeybindingService } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/abstractKeybindingService';
import '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { KeybindingResolver } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybindingResolver';
import { KeybindingsRegistry, KeybindingWeight } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybindingsRegistry';
import { ResolvedKeybindingItem } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/resolvedKeybindingItem';
import { IKeyboardLayoutService } from '@codingame/monaco-vscode-api/vscode/vs/platform/keyboardLayout/common/keyboardLayout.service';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { INotificationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/notification/common/notification.service';
import { Registry } from '@codingame/monaco-vscode-api/vscode/vs/platform/registry/common/platform';
import { ITelemetryService } from '@codingame/monaco-vscode-api/vscode/vs/platform/telemetry/common/telemetry.service';
import { IUriIdentityService } from '@codingame/monaco-vscode-api/vscode/vs/platform/uriIdentity/common/uriIdentity.service';
import { remove } from '@codingame/monaco-vscode-api/vscode/vs/base/common/arrays';
import { commandsExtensionPoint } from '../../actions/common/menusExtensionPoint.js';
import { IExtensionService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensions.service';
import { ExtensionsRegistry } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensionsRegistry';
import { IHostService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/host/browser/host.service';
import { IUserDataProfileService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/userDataProfile/common/userDataProfile.service';
import { OutputBuilder, KeybindingIO } from '../common/keybindingIO.js';
import { getAllUnboundCommands } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/keybinding/browser/unboundCommands';

var WorkbenchKeybindingService_1;
function isValidContributedKeyBinding(keyBinding, rejects) {
    if (!keyBinding) {
        rejects.push(( localize(14116, "expected non-empty value.")));
        return false;
    }
    if (typeof keyBinding.command !== 'string') {
        rejects.push(( localize(
            14117,
            "property `{0}` is mandatory and must be of type `string`",
            'command'
        )));
        return false;
    }
    if (keyBinding.key && typeof keyBinding.key !== 'string') {
        rejects.push(( localize(14118, "property `{0}` can be omitted or must be of type `string`", 'key')));
        return false;
    }
    if (keyBinding.when && typeof keyBinding.when !== 'string') {
        rejects.push(( localize(14118, "property `{0}` can be omitted or must be of type `string`", 'when')));
        return false;
    }
    if (keyBinding.mac && typeof keyBinding.mac !== 'string') {
        rejects.push(( localize(14118, "property `{0}` can be omitted or must be of type `string`", 'mac')));
        return false;
    }
    if (keyBinding.linux && typeof keyBinding.linux !== 'string') {
        rejects.push(( localize(
            14118,
            "property `{0}` can be omitted or must be of type `string`",
            'linux'
        )));
        return false;
    }
    if (keyBinding.win && typeof keyBinding.win !== 'string') {
        rejects.push(( localize(14118, "property `{0}` can be omitted or must be of type `string`", 'win')));
        return false;
    }
    return true;
}
const keybindingType = {
    type: 'object',
    default: { command: '', key: '' },
    required: ['command', 'key'],
    properties: {
        command: {
            description: ( localize(14119, 'Identifier of the command to run when keybinding is triggered.')),
            type: 'string'
        },
        args: {
            description: ( localize(14120, "Arguments to pass to the command to execute."))
        },
        key: {
            description: ( localize(
                14121,
                'Key or key sequence (separate keys with plus-sign and sequences with space, e.g. Ctrl+O and Ctrl+L L for a chord).'
            )),
            type: 'string'
        },
        mac: {
            description: ( localize(14122, 'Mac specific key or key sequence.')),
            type: 'string'
        },
        linux: {
            description: ( localize(14123, 'Linux specific key or key sequence.')),
            type: 'string'
        },
        win: {
            description: ( localize(14124, 'Windows specific key or key sequence.')),
            type: 'string'
        },
        when: {
            description: ( localize(14125, 'Condition when the key is active.')),
            type: 'string'
        },
    }
};
const keybindingsExtPoint = ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'keybindings',
    deps: [commandsExtensionPoint],
    jsonSchema: {
        description: ( localize(14126, "Contributes keybindings.")),
        oneOf: [
            keybindingType,
            {
                type: 'array',
                items: keybindingType
            }
        ]
    }
});
const NUMPAD_PRINTABLE_SCANCODES = [
    ScanCode.NumpadDivide,
    ScanCode.NumpadMultiply,
    ScanCode.NumpadSubtract,
    ScanCode.NumpadAdd,
    ScanCode.Numpad1,
    ScanCode.Numpad2,
    ScanCode.Numpad3,
    ScanCode.Numpad4,
    ScanCode.Numpad5,
    ScanCode.Numpad6,
    ScanCode.Numpad7,
    ScanCode.Numpad8,
    ScanCode.Numpad9,
    ScanCode.Numpad0,
    ScanCode.NumpadDecimal
];
const otherMacNumpadMapping = ( new Map());
otherMacNumpadMapping.set(ScanCode.Numpad1, KeyCode.Digit1);
otherMacNumpadMapping.set(ScanCode.Numpad2, KeyCode.Digit2);
otherMacNumpadMapping.set(ScanCode.Numpad3, KeyCode.Digit3);
otherMacNumpadMapping.set(ScanCode.Numpad4, KeyCode.Digit4);
otherMacNumpadMapping.set(ScanCode.Numpad5, KeyCode.Digit5);
otherMacNumpadMapping.set(ScanCode.Numpad6, KeyCode.Digit6);
otherMacNumpadMapping.set(ScanCode.Numpad7, KeyCode.Digit7);
otherMacNumpadMapping.set(ScanCode.Numpad8, KeyCode.Digit8);
otherMacNumpadMapping.set(ScanCode.Numpad9, KeyCode.Digit9);
otherMacNumpadMapping.set(ScanCode.Numpad0, KeyCode.Digit0);
let WorkbenchKeybindingService = WorkbenchKeybindingService_1 = class WorkbenchKeybindingService extends AbstractKeybindingService {
    constructor(contextKeyService, commandService, telemetryService, notificationService, userDataProfileService, hostService, extensionService, fileService, uriIdentityService, logService, keyboardLayoutService) {
        super(contextKeyService, commandService, telemetryService, notificationService, logService);
        this.hostService = hostService;
        this.keyboardLayoutService = keyboardLayoutService;
        this._contributions = [];
        this.isComposingGlobalContextKey = contextKeyService.createKey('isComposing', false);
        this.kbsJsonSchema = ( new KeybindingsJsonSchema());
        this.updateKeybindingsJsonSchema();
        this._keyboardMapper = this.keyboardLayoutService.getKeyboardMapper();
        this._register(this.keyboardLayoutService.onDidChangeKeyboardLayout(() => {
            this._keyboardMapper = this.keyboardLayoutService.getKeyboardMapper();
            this.updateResolver();
        }));
        this._keybindingHoldMode = null;
        this._cachedResolver = null;
        this.userKeybindings = this._register(( new UserKeybindings(userDataProfileService, uriIdentityService, fileService, logService)));
        this.userKeybindings.initialize().then(() => {
            if (this.userKeybindings.keybindings.length) {
                this.updateResolver();
            }
        });
        this._register(this.userKeybindings.onDidChange(() => {
            logService.debug('User keybindings changed');
            this.updateResolver();
        }));
        keybindingsExtPoint.setHandler((extensions) => {
            const keybindings = [];
            for (const extension of extensions) {
                this._handleKeybindingsExtensionPointUser(extension.description.identifier, extension.description.isBuiltin, extension.value, extension.collector, keybindings);
            }
            KeybindingsRegistry.setExtensionKeybindings(keybindings);
            this.updateResolver();
        });
        this.updateKeybindingsJsonSchema();
        this._register(extensionService.onDidRegisterExtensions(() => this.updateKeybindingsJsonSchema()));
        this._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => disposables.add(this._registerKeyListeners(window)), { window: mainWindow, disposables: this._store }));
        this._register(onDidChangeFullscreen(windowId => {
            if (windowId !== mainWindow.vscodeWindowId) {
                return;
            }
            if (BrowserFeatures.keyboard === KeyboardSupport.None) {
                return;
            }
            this.lockKeyCodes(isFullscreen(mainWindow) ? ['Escape'] : []);
            this._cachedResolver = null;
            this._onDidUpdateKeybindings.fire();
        }));
    }
    lockKeyCodes(keyCodes) {
        const keyboard = mainWindow.navigator.keyboard;
        if (keyCodes.length > 0) {
            keyboard?.lock(keyCodes);
        }
        else {
            keyboard?.unlock();
        }
    }
    dispose() {
        this._contributions.forEach(c => c.listener?.dispose());
        this._contributions.length = 0;
        super.dispose();
    }
    _registerKeyListeners(window) {
        const disposables = ( new DisposableStore());
        disposables.add(addDisposableListener(window, EventType.KEY_DOWN, (e) => {
            if (this._keybindingHoldMode) {
                return;
            }
            this.isComposingGlobalContextKey.set(e.isComposing);
            const keyEvent = ( new StandardKeyboardEvent(e));
            this._log(`/ Received  keydown event - ${printKeyboardEvent(e)}`);
            this._log(`| Converted keydown event - ${printStandardKeyboardEvent(keyEvent)}`);
            const shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);
            if (shouldPreventDefault) {
                keyEvent.preventDefault();
            }
            this.isComposingGlobalContextKey.set(false);
        }));
        disposables.add(addDisposableListener(window, EventType.KEY_UP, (e) => {
            this._resetKeybindingHoldMode();
            this.isComposingGlobalContextKey.set(e.isComposing);
            const keyEvent = ( new StandardKeyboardEvent(e));
            const shouldPreventDefault = this._singleModifierDispatch(keyEvent, keyEvent.target);
            if (shouldPreventDefault) {
                keyEvent.preventDefault();
            }
            this.isComposingGlobalContextKey.set(false);
        }));
        return disposables;
    }
    registerSchemaContribution(contribution) {
        const listener = contribution.onDidChange?.(() => this.updateKeybindingsJsonSchema());
        const entry = { listener, contribution };
        this._contributions.push(entry);
        this.updateKeybindingsJsonSchema();
        return toDisposable(() => {
            listener?.dispose();
            remove(this._contributions, entry);
            this.updateKeybindingsJsonSchema();
        });
    }
    updateKeybindingsJsonSchema() {
        this.kbsJsonSchema.updateSchema(this._contributions.flatMap(x => x.contribution.getSchemaAdditions()));
    }
    _printKeybinding(keybinding) {
        return UserSettingsLabelProvider.toLabel(OS, keybinding.chords, (chord) => {
            if (chord instanceof KeyCodeChord) {
                return ( KeyCodeUtils.toString(chord.keyCode));
            }
            return ( ScanCodeUtils.toString(chord.scanCode));
        }) || '[null]';
    }
    _printResolvedKeybinding(resolvedKeybinding) {
        return ( resolvedKeybinding.getDispatchChords().map(x => x || '[null]')).join(' ');
    }
    _printResolvedKeybindings(output, input, resolvedKeybindings) {
        const padLength = 35;
        const firstRow = `${input.padStart(padLength, ' ')} => `;
        if (resolvedKeybindings.length === 0) {
            output.push(`${firstRow}${'[NO BINDING]'.padStart(padLength, ' ')}`);
            return;
        }
        for (const resolvedKeybinding of resolvedKeybindings) {
            {
                output.push(`${firstRow}${this._printResolvedKeybinding(resolvedKeybinding).padStart(padLength, ' ')}`);
            }
        }
    }
    _dumpResolveKeybindingDebugInfo() {
        const seenBindings = ( new Set());
        const result = [];
        result.push(`Default Resolved Keybindings (unique only):`);
        for (const item of KeybindingsRegistry.getDefaultKeybindings()) {
            if (!item.keybinding) {
                continue;
            }
            const input = this._printKeybinding(item.keybinding);
            if (( seenBindings.has(input))) {
                continue;
            }
            seenBindings.add(input);
            const resolvedKeybindings = this._keyboardMapper.resolveKeybinding(item.keybinding);
            this._printResolvedKeybindings(result, input, resolvedKeybindings);
        }
        result.push(`User Resolved Keybindings (unique only):`);
        for (const item of this.userKeybindings.keybindings) {
            if (!item.keybinding) {
                continue;
            }
            const input = item._sourceKey ?? 'Impossible: missing source key, but has keybinding';
            if (( seenBindings.has(input))) {
                continue;
            }
            seenBindings.add(input);
            const resolvedKeybindings = this._keyboardMapper.resolveKeybinding(item.keybinding);
            this._printResolvedKeybindings(result, input, resolvedKeybindings);
        }
        return result.join('\n');
    }
    _dumpDebugInfo() {
        const layoutInfo = JSON.stringify(this.keyboardLayoutService.getCurrentKeyboardLayout(), null, '\t');
        const mapperInfo = this._keyboardMapper.dumpDebugInfo();
        const resolvedKeybindings = this._dumpResolveKeybindingDebugInfo();
        const rawMapping = JSON.stringify(this.keyboardLayoutService.getRawKeyboardMapping(), null, '\t');
        return `Layout info:\n${layoutInfo}\n\n${resolvedKeybindings}\n\n${mapperInfo}\n\nRaw mapping:\n${rawMapping}`;
    }
    _dumpDebugInfoJSON() {
        const info = {
            layout: this.keyboardLayoutService.getCurrentKeyboardLayout(),
            rawMapping: this.keyboardLayoutService.getRawKeyboardMapping()
        };
        return JSON.stringify(info, null, '\t');
    }
    enableKeybindingHoldMode(commandId) {
        if (this._currentlyDispatchingCommandId !== commandId) {
            return undefined;
        }
        this._keybindingHoldMode = ( new DeferredPromise());
        const focusTracker = trackFocus(getWindow(undefined));
        const listener = focusTracker.onDidBlur(() => this._resetKeybindingHoldMode());
        this._keybindingHoldMode.p.finally(() => {
            listener.dispose();
            focusTracker.dispose();
        });
        this._log(`+ Enabled hold-mode for ${commandId}.`);
        return this._keybindingHoldMode.p;
    }
    _resetKeybindingHoldMode() {
        if (this._keybindingHoldMode) {
            this._keybindingHoldMode?.complete();
            this._keybindingHoldMode = null;
        }
    }
    customKeybindingsCount() {
        return this.userKeybindings.keybindings.length;
    }
    updateResolver() {
        this._cachedResolver = null;
        this._onDidUpdateKeybindings.fire();
    }
    getUserKeybindingItems() {
        return this._resolveUserKeybindingItems(this.userKeybindings.keybindings, false);
    }
    _getResolver() {
        if (!this._cachedResolver) {
            const defaults = this._resolveKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);
            const overrides = this.getUserKeybindingItems();
            this._cachedResolver = ( new KeybindingResolver(defaults, overrides, (str) => this._log(str)));
        }
        return this._cachedResolver;
    }
    _documentHasFocus() {
        return this.hostService.hasFocus;
    }
    _resolveKeybindingItems(items, isDefault) {
        const result = [];
        let resultLen = 0;
        for (const item of items) {
            const when = item.when || undefined;
            const keybinding = item.keybinding;
            if (!keybinding) {
                result[resultLen++] = ( new ResolvedKeybindingItem(
                    undefined,
                    item.command,
                    item.commandArgs,
                    when,
                    isDefault,
                    item.extensionId,
                    item.isBuiltinExtension
                ));
            }
            else {
                if (this._assertBrowserConflicts(keybinding)) {
                    continue;
                }
                const resolvedKeybindings = this._keyboardMapper.resolveKeybinding(keybinding);
                for (let i = resolvedKeybindings.length - 1; i >= 0; i--) {
                    const resolvedKeybinding = resolvedKeybindings[i];
                    result[resultLen++] = ( new ResolvedKeybindingItem(
                        resolvedKeybinding,
                        item.command,
                        item.commandArgs,
                        when,
                        isDefault,
                        item.extensionId,
                        item.isBuiltinExtension
                    ));
                }
            }
        }
        return result;
    }
    _resolveUserKeybindingItems(items, isDefault) {
        const result = [];
        let resultLen = 0;
        for (const item of items) {
            const when = item.when || undefined;
            if (!item.keybinding) {
                result[resultLen++] = ( new ResolvedKeybindingItem(undefined, item.command, item.commandArgs, when, isDefault, null, false));
            }
            else {
                const resolvedKeybindings = this._keyboardMapper.resolveKeybinding(item.keybinding);
                for (const resolvedKeybinding of resolvedKeybindings) {
                    result[resultLen++] = ( new ResolvedKeybindingItem(
                        resolvedKeybinding,
                        item.command,
                        item.commandArgs,
                        when,
                        isDefault,
                        null,
                        false
                    ));
                }
            }
        }
        return result;
    }
    _assertBrowserConflicts(keybinding) {
        if (BrowserFeatures.keyboard === KeyboardSupport.Always) {
            return false;
        }
        if (BrowserFeatures.keyboard === KeyboardSupport.FullScreen && isFullscreen(mainWindow)) {
            return false;
        }
        for (const chord of keybinding.chords) {
            if (!chord.metaKey && !chord.altKey && !chord.ctrlKey && !chord.shiftKey) {
                continue;
            }
            const modifiersMask = KeyMod.CtrlCmd | KeyMod.Alt | KeyMod.Shift;
            let partModifiersMask = 0;
            if (chord.metaKey) {
                partModifiersMask |= KeyMod.CtrlCmd;
            }
            if (chord.shiftKey) {
                partModifiersMask |= KeyMod.Shift;
            }
            if (chord.altKey) {
                partModifiersMask |= KeyMod.Alt;
            }
            if (chord.ctrlKey && OS === OperatingSystem.Macintosh) {
                partModifiersMask |= KeyMod.WinCtrl;
            }
            if ((partModifiersMask & modifiersMask) === (KeyMod.CtrlCmd | KeyMod.Alt)) {
                if (chord instanceof ScanCodeChord && (chord.scanCode === ScanCode.ArrowLeft || chord.scanCode === ScanCode.ArrowRight)) {
                    return true;
                }
                if (chord instanceof KeyCodeChord && (chord.keyCode === KeyCode.LeftArrow || chord.keyCode === KeyCode.RightArrow)) {
                    return true;
                }
            }
            if ((partModifiersMask & modifiersMask) === KeyMod.CtrlCmd) {
                if (chord instanceof ScanCodeChord && (chord.scanCode >= ScanCode.Digit1 && chord.scanCode <= ScanCode.Digit0)) {
                    return true;
                }
                if (chord instanceof KeyCodeChord && (chord.keyCode >= KeyCode.Digit0 && chord.keyCode <= KeyCode.Digit9)) {
                    return true;
                }
            }
        }
        return false;
    }
    resolveKeybinding(kb) {
        return this._keyboardMapper.resolveKeybinding(kb);
    }
    resolveKeyboardEvent(keyboardEvent) {
        this.keyboardLayoutService.validateCurrentKeyboardMapping(keyboardEvent);
        return this._keyboardMapper.resolveKeyboardEvent(keyboardEvent);
    }
    resolveUserBinding(userBinding) {
        const keybinding = KeybindingParser.parseKeybinding(userBinding);
        return (keybinding ? this._keyboardMapper.resolveKeybinding(keybinding) : []);
    }
    _handleKeybindingsExtensionPointUser(extensionId, isBuiltin, keybindings, collector, result) {
        if (Array.isArray(keybindings)) {
            for (let i = 0, len = keybindings.length; i < len; i++) {
                this._handleKeybinding(extensionId, isBuiltin, i + 1, keybindings[i], collector, result);
            }
        }
        else {
            this._handleKeybinding(extensionId, isBuiltin, 1, keybindings, collector, result);
        }
    }
    _handleKeybinding(extensionId, isBuiltin, idx, keybindings, collector, result) {
        const rejects = [];
        if (isValidContributedKeyBinding(keybindings, rejects)) {
            const rule = this._asCommandRule(extensionId, isBuiltin, idx++, keybindings);
            if (rule) {
                result.push(rule);
            }
        }
        if (rejects.length > 0) {
            collector.error(( localize(
                14127,
                "Invalid `contributes.{0}`: {1}",
                keybindingsExtPoint.name,
                rejects.join('\n')
            )));
        }
    }
    static bindToCurrentPlatform(key, mac, linux, win) {
        if (OS === OperatingSystem.Windows && win) {
            if (win) {
                return win;
            }
        }
        else if (OS === OperatingSystem.Macintosh) {
            if (mac) {
                return mac;
            }
        }
        else {
            if (linux) {
                return linux;
            }
        }
        return key;
    }
    _asCommandRule(extensionId, isBuiltin, idx, binding) {
        const { command, args, when, key, mac, linux, win } = binding;
        const keybinding = WorkbenchKeybindingService_1.bindToCurrentPlatform(key, mac, linux, win);
        if (!keybinding) {
            return undefined;
        }
        let weight;
        if (isBuiltin) {
            weight = KeybindingWeight.BuiltinExtension + idx;
        }
        else {
            weight = KeybindingWeight.ExternalExtension + idx;
        }
        const commandAction = MenuRegistry.getCommand(command);
        const precondition = commandAction && commandAction.precondition;
        let fullWhen;
        if (when && precondition) {
            fullWhen = ( ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(when)));
        }
        else if (when) {
            fullWhen = ContextKeyExpr.deserialize(when);
        }
        else if (precondition) {
            fullWhen = precondition;
        }
        const desc = {
            id: command,
            args,
            when: fullWhen,
            weight: weight,
            keybinding: KeybindingParser.parseKeybinding(keybinding),
            extensionId: extensionId.value,
            isBuiltinExtension: isBuiltin
        };
        return desc;
    }
    getDefaultKeybindingsContent() {
        const resolver = this._getResolver();
        const defaultKeybindings = resolver.getDefaultKeybindings();
        const boundCommands = resolver.getDefaultBoundCommands();
        return (WorkbenchKeybindingService_1._getDefaultKeybindings(defaultKeybindings)
            + '\n\n'
            + WorkbenchKeybindingService_1._getAllCommandsAsComment(boundCommands));
    }
    static _getDefaultKeybindings(defaultKeybindings) {
        const out = ( new OutputBuilder());
        out.writeLine('[');
        const lastIndex = defaultKeybindings.length - 1;
        defaultKeybindings.forEach((k, index) => {
            KeybindingIO.writeKeybindingItem(out, k);
            if (index !== lastIndex) {
                out.writeLine(',');
            }
            else {
                out.writeLine();
            }
        });
        out.writeLine(']');
        return ( out.toString());
    }
    static _getAllCommandsAsComment(boundCommands) {
        const unboundCommands = getAllUnboundCommands(boundCommands);
        const pretty = unboundCommands.sort().join('\n// - ');
        return '// ' + ( localize(14128, "Here are other available commands: ")) + '\n// - ' + pretty;
    }
    mightProducePrintableCharacter(event) {
        if (event.ctrlKey || event.metaKey || event.altKey) {
            return false;
        }
        const code = ScanCodeUtils.toEnum(event.code);
        if (NUMPAD_PRINTABLE_SCANCODES.indexOf(code) !== -1) {
            if (event.keyCode === IMMUTABLE_CODE_TO_KEY_CODE[code]) {
                return true;
            }
            if (isMacintosh && event.keyCode === otherMacNumpadMapping.get(code)) {
                return true;
            }
            return false;
        }
        const keycode = IMMUTABLE_CODE_TO_KEY_CODE[code];
        if (keycode !== -1) {
            return false;
        }
        const mapping = this.keyboardLayoutService.getRawKeyboardMapping();
        if (!mapping) {
            return false;
        }
        const keyInfo = mapping[event.code];
        if (!keyInfo) {
            return false;
        }
        if (!keyInfo.value || /\s/.test(keyInfo.value)) {
            return false;
        }
        return true;
    }
};
WorkbenchKeybindingService = WorkbenchKeybindingService_1 = ( __decorate([
    ( __param(0, IContextKeyService)),
    ( __param(1, ICommandService)),
    ( __param(2, ITelemetryService)),
    ( __param(3, INotificationService)),
    ( __param(4, IUserDataProfileService)),
    ( __param(5, IHostService)),
    ( __param(6, IExtensionService)),
    ( __param(7, IFileService)),
    ( __param(8, IUriIdentityService)),
    ( __param(9, ILogService)),
    ( __param(10, IKeyboardLayoutService))
], WorkbenchKeybindingService));
class UserKeybindings extends Disposable {
    get keybindings() { return this._keybindings; }
    constructor(userDataProfileService, uriIdentityService, fileService, logService) {
        super();
        this.userDataProfileService = userDataProfileService;
        this.uriIdentityService = uriIdentityService;
        this.fileService = fileService;
        this._rawKeybindings = [];
        this._keybindings = [];
        this.watchDisposables = this._register(( new DisposableStore()));
        this._onDidChange = this._register(( new Emitter()));
        this.onDidChange = this._onDidChange.event;
        this.watch();
        this.reloadConfigurationScheduler = this._register(( new RunOnceScheduler(() => this.reload().then(changed => {
            if (changed) {
                this._onDidChange.fire();
            }
        }), 50)));
        this._register(Event.filter(this.fileService.onDidFilesChange, e => e.contains(this.userDataProfileService.currentProfile.keybindingsResource))(() => {
            logService.debug('Keybindings file changed');
            this.reloadConfigurationScheduler.schedule();
        }));
        this._register(this.fileService.onDidRunOperation((e) => {
            if (e.operation === FileOperation.WRITE && ( e.resource.toString()) === ( this.userDataProfileService.currentProfile.keybindingsResource.toString())) {
                logService.debug('Keybindings file written');
                this.reloadConfigurationScheduler.schedule();
            }
        }));
        this._register(userDataProfileService.onDidChangeCurrentProfile(e => {
            if (!this.uriIdentityService.extUri.isEqual(e.previous.keybindingsResource, e.profile.keybindingsResource)) {
                e.join(this.whenCurrentProfileChanged());
            }
        }));
    }
    async whenCurrentProfileChanged() {
        this.watch();
        this.reloadConfigurationScheduler.schedule();
    }
    watch() {
        this.watchDisposables.clear();
        this.watchDisposables.add(this.fileService.watch(dirname(this.userDataProfileService.currentProfile.keybindingsResource)));
        this.watchDisposables.add(this.fileService.watch(this.userDataProfileService.currentProfile.keybindingsResource));
    }
    async initialize() {
        await this.reload();
    }
    async reload() {
        const newKeybindings = await this.readUserKeybindings();
        if (equals(this._rawKeybindings, newKeybindings)) {
            return false;
        }
        this._rawKeybindings = newKeybindings;
        this._keybindings = ( this._rawKeybindings.map((k) => KeybindingIO.readUserKeybindingItem(k)));
        return true;
    }
    async readUserKeybindings() {
        try {
            const content = await this.fileService.readFile(this.userDataProfileService.currentProfile.keybindingsResource);
            const value = parse(( content.value.toString()));
            return Array.isArray(value)
                ? value.filter(v => v && typeof v === 'object' )
                : [];
        }
        catch (e) {
            return [];
        }
    }
}
class KeybindingsJsonSchema {
    static { this.schemaId = 'vscode://schemas/keybindings'; }
    constructor() {
        this.commandsSchemas = [];
        this.commandsEnum = [];
        this.removalCommandsEnum = [];
        this.commandsEnumDescriptions = [];
        this.schema = {
            id: KeybindingsJsonSchema.schemaId,
            type: 'array',
            title: ( localize(14129, "Keybindings configuration")),
            allowTrailingCommas: true,
            allowComments: true,
            definitions: {
                'editorGroupsSchema': {
                    'type': 'array',
                    'items': {
                        'type': 'object',
                        'properties': {
                            'groups': {
                                '$ref': '#/definitions/editorGroupsSchema',
                                'default': [{}, {}]
                            },
                            'size': {
                                'type': 'number',
                                'default': 0.5
                            }
                        }
                    }
                },
                'commandNames': {
                    'type': 'string',
                    'enum': this.commandsEnum,
                    'enumDescriptions': this.commandsEnumDescriptions,
                    'description': ( localize(14130, "Name of the command to execute")),
                },
                'commandType': {
                    'anyOf': [
                        {
                            $ref: '#/definitions/commandNames'
                        },
                        {
                            'type': 'string',
                            'enum': this.removalCommandsEnum,
                            'enumDescriptions': this.commandsEnumDescriptions,
                            'description': ( localize(14131, "Name of the command to remove keyboard shortcut for")),
                        },
                        {
                            'type': 'string'
                        },
                    ]
                },
                'commandsSchemas': {
                    'allOf': this.commandsSchemas
                }
            },
            items: {
                'required': ['key'],
                'type': 'object',
                'defaultSnippets': [{ 'body': { 'key': '$1', 'command': '$2', 'when': '$3' } }],
                'properties': {
                    'key': {
                        'type': 'string',
                        'description': ( localize(14132, "Key or key sequence (separated by space)")),
                    },
                    'command': {
                        'anyOf': [
                            {
                                'if': {
                                    'type': 'array'
                                },
                                'then': {
                                    'not': {
                                        'type': 'array'
                                    },
                                    'errorMessage': ( localize(
                                        14133,
                                        "Incorrect type. Expected \"{0}\". The field 'command' does not support running multiple commands. Use command 'runCommands' to pass it multiple commands to run.",
                                        'string'
                                    ))
                                },
                                'else': {
                                    '$ref': '#/definitions/commandType'
                                }
                            },
                            {
                                '$ref': '#/definitions/commandType'
                            }
                        ]
                    },
                    'when': {
                        'type': 'string',
                        'description': ( localize(14134, "Condition when the key is active."))
                    },
                    'args': {
                        'description': ( localize(14135, "Arguments to pass to the command to execute."))
                    }
                },
                '$ref': '#/definitions/commandsSchemas'
            }
        };
        this.schemaRegistry = ( Registry.as(Extensions.JSONContribution));
        this.schemaRegistry.registerSchema(KeybindingsJsonSchema.schemaId, this.schema);
    }
    updateSchema(additionalContributions) {
        this.commandsSchemas.length = 0;
        this.commandsEnum.length = 0;
        this.removalCommandsEnum.length = 0;
        this.commandsEnumDescriptions.length = 0;
        const knownCommands = ( new Set());
        const addKnownCommand = (commandId, description) => {
            if (!/^_/.test(commandId)) {
                if (!( knownCommands.has(commandId))) {
                    knownCommands.add(commandId);
                    this.commandsEnum.push(commandId);
                    this.commandsEnumDescriptions.push(description === undefined
                        ? ''
                        : (isLocalizedString(description) ? description.value : description));
                    this.removalCommandsEnum.push(`-${commandId}`);
                }
            }
        };
        const allCommands = CommandsRegistry.getCommands();
        for (const [commandId, command] of allCommands) {
            const commandMetadata = command.metadata;
            addKnownCommand(commandId, commandMetadata?.description ?? MenuRegistry.getCommand(commandId)?.title);
            if (!commandMetadata || !commandMetadata.args || commandMetadata.args.length !== 1 || !commandMetadata.args[0].schema) {
                continue;
            }
            const argsSchema = commandMetadata.args[0].schema;
            const argsRequired = ((typeof commandMetadata.args[0].isOptional !== 'undefined')
                ? (!commandMetadata.args[0].isOptional)
                : (Array.isArray(argsSchema.required) && argsSchema.required.length > 0));
            const addition = {
                'if': {
                    'required': ['command'],
                    'properties': {
                        'command': { 'const': commandId }
                    }
                },
                'then': {
                    'required': [].concat(argsRequired ? ['args'] : []),
                    'properties': {
                        'args': argsSchema
                    }
                }
            };
            this.commandsSchemas.push(addition);
        }
        const menuCommands = MenuRegistry.getCommands();
        for (const commandId of ( menuCommands.keys())) {
            addKnownCommand(commandId);
        }
        this.commandsSchemas.push(...additionalContributions);
        this.schemaRegistry.notifySchemaChanged(KeybindingsJsonSchema.schemaId);
    }
}

export { WorkbenchKeybindingService };
