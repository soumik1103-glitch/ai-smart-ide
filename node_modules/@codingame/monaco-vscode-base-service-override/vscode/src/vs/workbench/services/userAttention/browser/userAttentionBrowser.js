
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { onDidRegisterWindow, addDisposableListener } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';
import { mainWindow } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/window';
import { Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { Disposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/index';
import { wasTrueRecently, TotalTrueTimeObservable } from '../../../../base/common/observableInternal/experimental/time.js';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/extensions';
import { LogLevel } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { IHostService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/host/browser/host.service';
import { observableFromEvent } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/observables/observableFromEvent';
import { derived } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/observables/derived';
import { autorun } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/reactions/autorun';
import { observableValue } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/observables/observableValue';

const USER_ATTENTION_TIMEOUT_MS = 60_000;
let UserAttentionService = class UserAttentionService extends Disposable {
    constructor(instantiationService, _logService) {
        super();
        this._logService = _logService;
        const hostAdapter = this._register(instantiationService.createInstance(UserAttentionServiceEnv));
        this.isVsCodeFocused = hostAdapter.isVsCodeFocused;
        this.isUserActive = hostAdapter.isUserActive;
        this._isTracingEnabled = observableFromEvent(this, this._logService.onDidChangeLogLevel, () => this._logService.getLevel() === LogLevel.Trace);
        const hadRecentActivity = wasTrueRecently(this.isUserActive, USER_ATTENTION_TIMEOUT_MS, this._store);
        this.hasUserAttention = derived(this, reader => {
            return hadRecentActivity.read(reader);
        });
        this._timeKeeper = this._register(( new TotalTrueTimeObservable(this.hasUserAttention)));
        this._register(autorun(reader => {
            if (!this._isTracingEnabled.read(reader)) {
                return;
            }
            reader.store.add(autorun(innerReader => {
                const focused = this.isVsCodeFocused.read(innerReader);
                this._logService.trace(`[UserAttentionService] VS Code focus changed: ${focused}`);
            }));
            reader.store.add(autorun(innerReader => {
                const hasAttention = this.hasUserAttention.read(innerReader);
                this._logService.trace(`[UserAttentionService] User attention changed: ${hasAttention}`);
            }));
        }));
    }
    fireAfterGivenFocusTimePassed(focusTimeMs, callback) {
        return this._timeKeeper.fireWhenTimeIncreasedBy(focusTimeMs, callback);
    }
    get totalFocusTimeMs() {
        return this._timeKeeper.totalTimeMs();
    }
};
UserAttentionService = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, ILogService))
], UserAttentionService));
let UserAttentionServiceEnv = class UserAttentionServiceEnv extends Disposable {
    constructor(_hostService, _logService) {
        super();
        this._hostService = _hostService;
        this._logService = _logService;
        this._isUserActive = observableValue(this, false);
        this.isVsCodeFocused = observableFromEvent(this, this._hostService.onDidChangeFocus, () => this._hostService.hasFocus);
        this.isUserActive = this._isUserActive;
        const onActivity = () => {
            this._markUserActivity();
        };
        this._register(Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => {
            disposables.add(addDisposableListener(window.document, 'keydown', onActivity, eventListenerOptions));
            disposables.add(addDisposableListener(window.document, 'mousemove', onActivity, eventListenerOptions));
            disposables.add(addDisposableListener(window.document, 'mousedown', onActivity, eventListenerOptions));
            disposables.add(addDisposableListener(window.document, 'touchstart', onActivity, eventListenerOptions));
        }, { window: mainWindow, disposables: this._store }));
        if (this._hostService.hasFocus) {
            this._markUserActivity();
        }
    }
    _markUserActivity() {
        if (this._activityDebounceTimeout !== undefined) {
            clearTimeout(this._activityDebounceTimeout);
        }
        else {
            this._logService.trace('[UserAttentionService] User activity detected');
            this._isUserActive.set(true, undefined);
        }
        this._activityDebounceTimeout = setTimeout(() => {
            this._isUserActive.set(false, undefined);
            this._activityDebounceTimeout = undefined;
        }, 500);
    }
};
UserAttentionServiceEnv = ( __decorate([
    ( __param(0, IHostService)),
    ( __param(1, ILogService))
], UserAttentionServiceEnv));
const eventListenerOptions = {
    passive: true,
    capture: true,
};

export { UserAttentionService, UserAttentionServiceEnv };
