import { IInstantiationService } from "@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation";
import { IWaitUntil } from "@codingame/monaco-vscode-api/vscode/vs/base/common/event";
import { URI } from "@codingame/monaco-vscode-api/vscode/vs/base/common/uri";
import { Disposable, IDisposable } from "@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle";
import { FileOperation, IFileStatWithMetadata } from "@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files";
import { IFileService } from "@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service";
import { CancellationToken } from "@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation";
import { IWorkingCopyService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/workingCopy/common/workingCopyService.service";
import { IWorkingCopy } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/workingCopy/common/workingCopy";
import { IUriIdentityService } from "@codingame/monaco-vscode-api/vscode/vs/platform/uriIdentity/common/uriIdentity.service";
import { VSBuffer, VSBufferReadable, VSBufferReadableStream } from "@codingame/monaco-vscode-api/vscode/vs/base/common/buffer";
import { SaveReason } from "@codingame/monaco-vscode-api/vscode/vs/workbench/common/editor";
import { IProgress, IProgressStep } from "@codingame/monaco-vscode-api/vscode/vs/platform/progress/common/progress";
import { IStoredFileWorkingCopy, IStoredFileWorkingCopyModel } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/workingCopy/common/storedFileWorkingCopy";
import { IWorkingCopyFileService } from "@codingame/monaco-vscode-api/vscode/vs/workbench/services/workingCopy/common/workingCopyFileService.service";
export interface SourceTargetPair {
    /**
     * The source resource that is defined for move operations.
     */
    readonly source?: URI;
    /**
     * The target resource the event is about.
     */
    readonly target: URI;
}
export interface IFileOperationUndoRedoInfo {
    /**
     * Id of the undo group that the file operation belongs to.
     */
    undoRedoGroupId?: number;
    /**
     * Flag indicates if the operation is an undo.
     */
    isUndoing?: boolean;
}
export interface WorkingCopyFileEvent extends IWaitUntil {
    /**
     * An identifier to correlate the operation through the
     * different event types (before, after, error).
     */
    readonly correlationId: number;
    /**
     * The file operation that is taking place.
     */
    readonly operation: FileOperation;
    /**
     * The array of source/target pair of files involved in given operation.
     */
    readonly files: readonly SourceTargetPair[];
}
export interface IWorkingCopyFileOperationParticipant {
    /**
     * Participate in a file operation of working copies. Allows to
     * change the working copies before they are being saved to disk.
     */
    participate(files: SourceTargetPair[], operation: FileOperation, undoInfo: IFileOperationUndoRedoInfo | undefined, timeout: number, token: CancellationToken): Promise<void>;
}
export interface IStoredFileWorkingCopySaveParticipantContext {
    /**
     * The reason why the save was triggered.
     */
    readonly reason: SaveReason;
    /**
     * Only applies to when a text file was saved as, for
     * example when starting with untitled and saving. This
     * provides access to the initial resource the text
     * file had before.
     */
    readonly savedFrom?: URI;
}
export interface IStoredFileWorkingCopySaveParticipant {
    /**
     * The ordinal number which determines the order of participation.
     * Lower values mean to participant sooner
     */
    readonly ordinal?: number;
    /**
     * Participate in a save operation of file stored working copies.
     * Allows to make changes before content is being saved to disk.
     */
    participate(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;
}
export interface ICreateOperation {
    resource: URI;
    overwrite?: boolean;
}
export interface ICreateFileOperation extends ICreateOperation {
    contents?: VSBuffer | VSBufferReadable | VSBufferReadableStream;
}
export interface IDeleteOperation {
    resource: URI;
    useTrash?: boolean;
    recursive?: boolean;
}
export interface IMoveOperation {
    file: Required<SourceTargetPair>;
    overwrite?: boolean;
}
export interface ICopyOperation extends IMoveOperation {
}
/**
 * Returns the working copies for a given resource.
 */
export type WorkingCopyProvider = (resourceOrFolder: URI) => IWorkingCopy[];
export declare class WorkingCopyFileService extends Disposable implements IWorkingCopyFileService {
    private readonly fileService;
    private readonly workingCopyService;
    private readonly uriIdentityService;
    readonly _serviceBrand: undefined;
    private readonly _onWillRunWorkingCopyFileOperation;
    readonly onWillRunWorkingCopyFileOperation: import("@codingame/monaco-vscode-api/vscode/vs/base/common/event").Event<WorkingCopyFileEvent>;
    private readonly _onDidFailWorkingCopyFileOperation;
    readonly onDidFailWorkingCopyFileOperation: import("@codingame/monaco-vscode-api/vscode/vs/base/common/event").Event<WorkingCopyFileEvent>;
    private readonly _onDidRunWorkingCopyFileOperation;
    readonly onDidRunWorkingCopyFileOperation: import("@codingame/monaco-vscode-api/vscode/vs/base/common/event").Event<WorkingCopyFileEvent>;
    private correlationIds;
    constructor(fileService: IFileService, workingCopyService: IWorkingCopyService, instantiationService: IInstantiationService, uriIdentityService: IUriIdentityService);
    create(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]>;
    createFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]>;
    doCreateFileOrFolder(operations: (ICreateFileOperation | ICreateOperation)[], isFile: boolean, token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]>;
    move(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]>;
    copy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<IFileStatWithMetadata[]>;
    private doMoveOrCopy;
    delete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void>;
    private readonly fileOperationParticipants;
    addFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable;
    private runFileOperationParticipants;
    private readonly saveParticipants;
    get hasSaveParticipants(): boolean;
    addSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable;
    runSaveParticipants(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: IStoredFileWorkingCopySaveParticipantContext, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;
    private readonly workingCopyProviders;
    registerWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable;
    getDirty(resource: URI): IWorkingCopy[];
}
