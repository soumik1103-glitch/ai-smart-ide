
import { Disposable, DisposableStore, toDisposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import '@codingame/monaco-vscode-api/vscode/vs/base/common/errors';
import '@codingame/monaco-vscode-api/vscode/vs/base/common/equals';
import '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { observableValue } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/observables/observableValue';
import { autorun } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/reactions/autorun';

class TotalTrueTimeObservable extends Disposable {
    constructor(value) {
        super();
        this.value = value;
        this._totalTime = 0;
        this._startTime = undefined;
        this._register(autorun(reader => {
            const isTrue = this.value.read(reader);
            if (isTrue) {
                this._startTime = Date.now();
            }
            else {
                if (this._startTime !== undefined) {
                    const delta = Date.now() - this._startTime;
                    this._totalTime += delta;
                    this._startTime = undefined;
                }
            }
        }));
    }
    totalTimeMs() {
        if (this._startTime !== undefined) {
            return this._totalTime + (Date.now() - this._startTime);
        }
        return this._totalTime;
    }
    fireWhenTimeIncreasedBy(deltaTimeMs, callback) {
        const store = ( new DisposableStore());
        let accumulatedTime = 0;
        let startTime = undefined;
        store.add(autorun(reader => {
            const isTrue = this.value.read(reader);
            if (isTrue) {
                startTime = Date.now();
                const remainingTime = deltaTimeMs - accumulatedTime;
                if (remainingTime <= 0) {
                    callback();
                    store.dispose();
                    return;
                }
                const handle = setTimeout(() => {
                    accumulatedTime += (Date.now() - startTime);
                    startTime = undefined;
                    callback();
                    store.dispose();
                }, remainingTime);
                reader.store.add(toDisposable(() => {
                    clearTimeout(handle);
                    if (startTime !== undefined) {
                        accumulatedTime += (Date.now() - startTime);
                        startTime = undefined;
                    }
                }));
            }
        }));
        return store;
    }
}
function wasTrueRecently(obs, timeMs, store) {
    const result = observableValue('wasTrueRecently', false);
    let timeout;
    store.add(autorun(reader => {
        const value = obs.read(reader);
        if (value) {
            result.set(true, undefined);
            if (timeout !== undefined) {
                clearTimeout(timeout);
                timeout = undefined;
            }
        }
        else {
            timeout = setTimeout(() => {
                result.set(false, undefined);
                timeout = undefined;
            }, timeMs);
        }
    }));
    store.add(toDisposable(() => {
        if (timeout !== undefined) {
            clearTimeout(timeout);
        }
    }));
    return result;
}

export { TotalTrueTimeObservable, wasTrueRecently };
