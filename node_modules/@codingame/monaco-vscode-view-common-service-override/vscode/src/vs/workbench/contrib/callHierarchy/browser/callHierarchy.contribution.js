
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import { localize, localize2 } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { CallHierarchyDirection, CallHierarchyProviderRegistry, CallHierarchyModel } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/callHierarchy/common/callHierarchy';
import { CancellationTokenSource } from '@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation';
import { IInstantiationService } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/instantiation';
import { CallHierarchyTreePeekWidget } from './callHierarchyPeek.js';
import { Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { registerEditorContribution, EditorContributionInstantiation, EditorAction2 } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/editorExtensions';
import { RawContextKey, ContextKeyExpr } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { IContextKeyService } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey.service';
import { DisposableStore } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { KeybindingWeight } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybindingsRegistry';
import { KeyMod, KeyCode } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keyCodes';
import { EditorContextKeys } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/editorContextKeys';
import { PeekContext } from '@codingame/monaco-vscode-api/vscode/vs/editor/contrib/peekView/browser/peekView';
import { StorageScope, StorageTarget } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { ICodeEditorService } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/services/codeEditorService.service';
import { Range } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/range';
import { registerAction2, MenuId } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { registerIcon } from '@codingame/monaco-vscode-api/vscode/vs/platform/theme/common/iconRegistry';
import { isCancellationError } from '@codingame/monaco-vscode-api/vscode/vs/base/common/errors';

var CallHierarchyController_1;
const _ctxHasCallHierarchyProvider = ( new RawContextKey('editorHasCallHierarchyProvider', false, ( localize(4553, 'Whether a call hierarchy provider is available'))));
const _ctxCallHierarchyVisible = ( new RawContextKey('callHierarchyVisible', false, ( localize(4554, 'Whether call hierarchy peek is currently showing'))));
const _ctxCallHierarchyDirection = ( new RawContextKey(
    'callHierarchyDirection',
    undefined,
    { type: 'string', description: ( localize(4555, 'Whether call hierarchy shows incoming or outgoing calls')) }
));
function sanitizedDirection(candidate) {
    return candidate === CallHierarchyDirection.CallsFrom || candidate === CallHierarchyDirection.CallsTo
        ? candidate
        : CallHierarchyDirection.CallsTo;
}
let CallHierarchyController = class CallHierarchyController {
    static { CallHierarchyController_1 = this; }
    static { this.Id = 'callHierarchy'; }
    static get(editor) {
        return editor.getContribution(CallHierarchyController_1.Id);
    }
    static { this._StorageDirection = 'callHierarchy/defaultDirection'; }
    constructor(_editor, _contextKeyService, _storageService, _editorService, _instantiationService) {
        this._editor = _editor;
        this._contextKeyService = _contextKeyService;
        this._storageService = _storageService;
        this._editorService = _editorService;
        this._instantiationService = _instantiationService;
        this._dispoables = ( new DisposableStore());
        this._sessionDisposables = ( new DisposableStore());
        this._ctxIsVisible = _ctxCallHierarchyVisible.bindTo(this._contextKeyService);
        this._ctxHasProvider = _ctxHasCallHierarchyProvider.bindTo(this._contextKeyService);
        this._ctxDirection = _ctxCallHierarchyDirection.bindTo(this._contextKeyService);
        this._dispoables.add(Event.any(_editor.onDidChangeModel, _editor.onDidChangeModelLanguage, CallHierarchyProviderRegistry.onDidChange)(() => {
            this._ctxHasProvider.set(_editor.hasModel() && ( CallHierarchyProviderRegistry.has(_editor.getModel())));
        }));
        this._dispoables.add(this._sessionDisposables);
    }
    dispose() {
        this._ctxHasProvider.reset();
        this._ctxIsVisible.reset();
        this._dispoables.dispose();
    }
    async startCallHierarchyFromEditor() {
        this._sessionDisposables.clear();
        if (!this._editor.hasModel()) {
            return;
        }
        const document = this._editor.getModel();
        const position = this._editor.getPosition();
        if (!( CallHierarchyProviderRegistry.has(document))) {
            return;
        }
        const cts = ( new CancellationTokenSource());
        const model = CallHierarchyModel.create(document, position, cts.token);
        const direction = sanitizedDirection(this._storageService.get(CallHierarchyController_1._StorageDirection, StorageScope.PROFILE, CallHierarchyDirection.CallsTo));
        this._showCallHierarchyWidget(position, direction, model, cts);
    }
    async startCallHierarchyFromCallHierarchy() {
        if (!this._widget) {
            return;
        }
        const model = this._widget.getModel();
        const call = this._widget.getFocused();
        if (!call || !model) {
            return;
        }
        const newEditor = await this._editorService.openCodeEditor({ resource: call.item.uri }, this._editor);
        if (!newEditor) {
            return;
        }
        const newModel = model.fork(call.item);
        this._sessionDisposables.clear();
        CallHierarchyController_1.get(newEditor)?._showCallHierarchyWidget(Range.lift(newModel.root.selectionRange).getStartPosition(), this._widget.direction, Promise.resolve(newModel), ( new CancellationTokenSource()));
    }
    _showCallHierarchyWidget(position, direction, model, cts) {
        this._ctxIsVisible.set(true);
        this._ctxDirection.set(direction);
        Event.any(this._editor.onDidChangeModel, this._editor.onDidChangeModelLanguage)(this.endCallHierarchy, this, this._sessionDisposables);
        this._widget = this._instantiationService.createInstance(CallHierarchyTreePeekWidget, this._editor, position, direction);
        this._widget.showLoading();
        this._sessionDisposables.add(this._widget.onDidClose(() => {
            this.endCallHierarchy();
            this._storageService.store(CallHierarchyController_1._StorageDirection, this._widget.direction, StorageScope.PROFILE, StorageTarget.USER);
        }));
        this._sessionDisposables.add({ dispose() { cts.dispose(true); } });
        this._sessionDisposables.add(this._widget);
        model.then(model => {
            if (cts.token.isCancellationRequested) {
                return;
            }
            if (model) {
                this._sessionDisposables.add(model);
                this._widget.showModel(model);
            }
            else {
                this._widget.showMessage(( localize(4556, "No results")));
            }
        }).catch(err => {
            if (isCancellationError(err)) {
                this.endCallHierarchy();
                return;
            }
            this._widget.showMessage(( localize(4557, "Failed to show call hierarchy")));
        });
    }
    showOutgoingCalls() {
        this._widget?.updateDirection(CallHierarchyDirection.CallsFrom);
        this._ctxDirection.set(CallHierarchyDirection.CallsFrom);
    }
    showIncomingCalls() {
        this._widget?.updateDirection(CallHierarchyDirection.CallsTo);
        this._ctxDirection.set(CallHierarchyDirection.CallsTo);
    }
    endCallHierarchy() {
        this._sessionDisposables.clear();
        this._ctxIsVisible.set(false);
        this._editor.focus();
    }
};
CallHierarchyController = CallHierarchyController_1 = ( __decorate([
    ( __param(1, IContextKeyService)),
    ( __param(2, IStorageService)),
    ( __param(3, ICodeEditorService)),
    ( __param(4, IInstantiationService))
], CallHierarchyController));
registerEditorContribution(CallHierarchyController.Id, CallHierarchyController, EditorContributionInstantiation.Eager);
registerAction2(class PeekCallHierarchyAction extends EditorAction2 {
    constructor() {
        super({
            id: 'editor.showCallHierarchy',
            title: ( localize2(4558, 'Peek Call Hierarchy')),
            menu: {
                id: MenuId.EditorContextPeek,
                group: 'navigation',
                order: 1000,
                when: ( ContextKeyExpr.and(_ctxHasCallHierarchyProvider, PeekContext.notInPeekEditor, ( EditorContextKeys.isInEmbeddedEditor.toNegated()))),
            },
            keybinding: {
                when: EditorContextKeys.editorTextFocus,
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod.Shift + KeyMod.Alt + KeyCode.KeyH
            },
            precondition: ( ContextKeyExpr.and(_ctxHasCallHierarchyProvider, PeekContext.notInPeekEditor)),
            f1: true
        });
    }
    async runEditorCommand(_accessor, editor) {
        return CallHierarchyController.get(editor)?.startCallHierarchyFromEditor();
    }
});
registerAction2(class extends EditorAction2 {
    constructor() {
        super({
            id: 'editor.showIncomingCalls',
            title: ( localize2(4559, 'Show Incoming Calls')),
            icon: registerIcon('callhierarchy-incoming', Codicon.callIncoming, ( localize(4560, 'Icon for incoming calls in the call hierarchy view.'))),
            precondition: ( ContextKeyExpr.and(_ctxCallHierarchyVisible, ( _ctxCallHierarchyDirection.isEqualTo(CallHierarchyDirection.CallsFrom)))),
            keybinding: {
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod.Shift + KeyMod.Alt + KeyCode.KeyH,
            },
            menu: {
                id: CallHierarchyTreePeekWidget.TitleMenu,
                when: ( _ctxCallHierarchyDirection.isEqualTo(CallHierarchyDirection.CallsFrom)),
                order: 1,
            }
        });
    }
    runEditorCommand(_accessor, editor) {
        return CallHierarchyController.get(editor)?.showIncomingCalls();
    }
});
registerAction2(class extends EditorAction2 {
    constructor() {
        super({
            id: 'editor.showOutgoingCalls',
            title: ( localize2(4561, 'Show Outgoing Calls')),
            icon: registerIcon('callhierarchy-outgoing', Codicon.callOutgoing, ( localize(4562, 'Icon for outgoing calls in the call hierarchy view.'))),
            precondition: ( ContextKeyExpr.and(_ctxCallHierarchyVisible, ( _ctxCallHierarchyDirection.isEqualTo(CallHierarchyDirection.CallsTo)))),
            keybinding: {
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod.Shift + KeyMod.Alt + KeyCode.KeyH,
            },
            menu: {
                id: CallHierarchyTreePeekWidget.TitleMenu,
                when: ( _ctxCallHierarchyDirection.isEqualTo(CallHierarchyDirection.CallsTo)),
                order: 1
            }
        });
    }
    runEditorCommand(_accessor, editor) {
        return CallHierarchyController.get(editor)?.showOutgoingCalls();
    }
});
registerAction2(class extends EditorAction2 {
    constructor() {
        super({
            id: 'editor.refocusCallHierarchy',
            title: ( localize2(4563, 'Refocus Call Hierarchy')),
            precondition: _ctxCallHierarchyVisible,
            keybinding: {
                weight: KeybindingWeight.WorkbenchContrib,
                primary: KeyMod.Shift + KeyCode.Enter
            }
        });
    }
    async runEditorCommand(_accessor, editor) {
        return CallHierarchyController.get(editor)?.startCallHierarchyFromCallHierarchy();
    }
});
registerAction2(class extends EditorAction2 {
    constructor() {
        super({
            id: 'editor.closeCallHierarchy',
            title: ( localize(4564, 'Close')),
            icon: Codicon.close,
            precondition: _ctxCallHierarchyVisible,
            keybinding: {
                weight: KeybindingWeight.WorkbenchContrib + 10,
                primary: KeyCode.Escape,
                when: ContextKeyExpr.not('config.editor.stablePeek')
            },
            menu: {
                id: CallHierarchyTreePeekWidget.TitleMenu,
                order: 1000
            }
        });
    }
    runEditorCommand(_accessor, editor) {
        return CallHierarchyController.get(editor)?.endCallHierarchy();
    }
});
