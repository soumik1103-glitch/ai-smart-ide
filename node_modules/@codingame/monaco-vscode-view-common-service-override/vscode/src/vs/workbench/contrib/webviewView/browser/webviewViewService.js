
import { promiseWithResolvers } from '@codingame/monaco-vscode-api/vscode/vs/base/common/async';
import { CancellationToken } from '@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation';
import { Emitter } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { Disposable, toDisposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';

class WebviewViewService extends Disposable {
    constructor() {
        super(...arguments);
        this._resolvers = ( new Map());
        this._awaitingRevival = ( new Map());
        this._onNewResolverRegistered = this._register(( new Emitter()));
        this.onNewResolverRegistered = this._onNewResolverRegistered.event;
    }
    register(viewType, resolver) {
        if (( this._resolvers.has(viewType))) {
            throw ( new Error(`View resolver already registered for ${viewType}`));
        }
        this._resolvers.set(viewType, resolver);
        this._onNewResolverRegistered.fire({ viewType: viewType });
        const pending = this._awaitingRevival.get(viewType);
        if (pending) {
            resolver.resolve(pending.webview, CancellationToken.None).then(() => {
                this._awaitingRevival.delete(viewType);
                pending.resolve();
            });
        }
        return toDisposable(() => {
            this._resolvers.delete(viewType);
        });
    }
    resolve(viewType, webview, cancellation) {
        const resolver = this._resolvers.get(viewType);
        if (!resolver) {
            if (( this._awaitingRevival.has(viewType))) {
                throw ( new Error('View already awaiting revival'));
            }
            const { promise, resolve } = promiseWithResolvers();
            this._awaitingRevival.set(viewType, { webview, resolve });
            return promise;
        }
        return resolver.resolve(webview, cancellation);
    }
}

export { WebviewViewService };
