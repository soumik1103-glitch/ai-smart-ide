
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { basename } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { localize2, localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { Action2, MenuId } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { ContextKeyExpr } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { IDialogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/dialogs/common/dialogs.service';
import { IOpenerService } from '@codingame/monaco-vscode-api/vscode/vs/platform/opener/common/opener.service';
import { StorageScope } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { MergeEditorInputData } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/mergeEditor/browser/mergeEditorInput';
import { MergeEditor } from '../view/mergeEditor.js';
import { ctxIsMergeEditor, ctxMergeEditorLayout, ctxMergeEditorShowNonConflictingChanges, ctxMergeEditorShowBase, ctxMergeEditorShowBaseAtTop, StorageCloseWithConflicts } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/mergeEditor/common/mergeEditor';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/index';
import { ModifiedBaseRangeStateKind } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/mergeEditor/browser/model/modifiedBaseRange';
import { KeyMod, KeyCode } from '@codingame/monaco-vscode-api/vscode/vs/base/common/keyCodes';
import { KeybindingWeight } from '@codingame/monaco-vscode-api/vscode/vs/platform/keybinding/common/keybindingsRegistry';
import { transaction } from '@codingame/monaco-vscode-api/vscode/vs/base/common/observableInternal/transaction';

class MergeEditorAction extends Action2 {
    constructor(desc) {
        super(desc);
    }
    run(accessor) {
        const { activeEditorPane } = accessor.get(IEditorService);
        if (activeEditorPane instanceof MergeEditor) {
            const vm = activeEditorPane.viewModel.get();
            if (!vm) {
                return;
            }
            this.runWithViewModel(vm, accessor);
        }
    }
}
class MergeEditorAction2 extends Action2 {
    constructor(desc) {
        super(desc);
    }
    run(accessor, ...args) {
        const { activeEditorPane } = accessor.get(IEditorService);
        if (activeEditorPane instanceof MergeEditor) {
            const vm = activeEditorPane.viewModel.get();
            if (!vm) {
                return;
            }
            return this.runWithMergeEditor({
                viewModel: vm,
                inputModel: activeEditorPane.inputModel.get(),
                input: activeEditorPane.input,
                editorIdentifier: {
                    editor: activeEditorPane.input,
                    groupId: activeEditorPane.group.id,
                }
            }, accessor, ...args);
        }
    }
}
class OpenMergeEditor extends Action2 {
    constructor() {
        super({
            id: '_open.mergeEditor',
            title: ( localize2(9068, 'Open Merge Editor')),
        });
    }
    run(accessor, ...args) {
        const validatedArgs = IRelaxedOpenArgs.validate(args[0]);
        const input = {
            base: { resource: validatedArgs.base },
            input1: { resource: validatedArgs.input1.uri, label: validatedArgs.input1.title, description: validatedArgs.input1.description, detail: validatedArgs.input1.detail },
            input2: { resource: validatedArgs.input2.uri, label: validatedArgs.input2.title, description: validatedArgs.input2.description, detail: validatedArgs.input2.detail },
            result: { resource: validatedArgs.output },
            options: { preserveFocus: true }
        };
        accessor.get(IEditorService).openEditor(input);
    }
}
var IRelaxedOpenArgs;
(function (IRelaxedOpenArgs) {
    function validate(obj) {
        if (!obj || typeof obj !== 'object') {
            throw ( new TypeError('invalid argument'));
        }
        const o = obj;
        const base = toUri(o.base);
        const output = toUri(o.output);
        const input1 = toInputData(o.input1);
        const input2 = toInputData(o.input2);
        return { base, input1, input2, output };
    }
    IRelaxedOpenArgs.validate = validate;
    function toInputData(obj) {
        if (typeof obj === 'string') {
            return ( new MergeEditorInputData(( URI.parse(obj, true)), undefined, undefined, undefined));
        }
        if (!obj || typeof obj !== 'object') {
            throw ( new TypeError('invalid argument'));
        }
        if (isUriComponents(obj)) {
            return ( new MergeEditorInputData(URI.revive(obj), undefined, undefined, undefined));
        }
        const o = obj;
        const title = o.title;
        const uri = toUri(o.uri);
        const detail = o.detail;
        const description = o.description;
        return ( new MergeEditorInputData(uri, title, detail, description));
    }
    function toUri(obj) {
        if (typeof obj === 'string') {
            return ( URI.parse(obj, true));
        }
        else if (obj && typeof obj === 'object') {
            return URI.revive(obj);
        }
        throw ( new TypeError('invalid argument'));
    }
    function isUriComponents(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        const o = obj;
        return typeof o.scheme === 'string'
            && typeof o.authority === 'string'
            && typeof o.path === 'string'
            && typeof o.query === 'string'
            && typeof o.fragment === 'string';
    }
})(IRelaxedOpenArgs || (IRelaxedOpenArgs = {}));
class SetMixedLayout extends Action2 {
    constructor() {
        super({
            id: 'merge.mixedLayout',
            title: ( localize2(9069, "Mixed Layout")),
            toggled: ( ctxMergeEditorLayout.isEqualTo('mixed')),
            menu: [
                {
                    id: MenuId.EditorTitle,
                    when: ctxIsMergeEditor,
                    group: '1_merge',
                    order: 9,
                },
            ],
            precondition: ctxIsMergeEditor,
        });
    }
    run(accessor) {
        const { activeEditorPane } = accessor.get(IEditorService);
        if (activeEditorPane instanceof MergeEditor) {
            activeEditorPane.setLayoutKind('mixed');
        }
    }
}
class SetColumnLayout extends Action2 {
    constructor() {
        super({
            id: 'merge.columnLayout',
            title: ( localize2(9070, 'Column Layout')),
            toggled: ( ctxMergeEditorLayout.isEqualTo('columns')),
            menu: [{
                    id: MenuId.EditorTitle,
                    when: ctxIsMergeEditor,
                    group: '1_merge',
                    order: 10,
                }],
            precondition: ctxIsMergeEditor,
        });
    }
    run(accessor) {
        const { activeEditorPane } = accessor.get(IEditorService);
        if (activeEditorPane instanceof MergeEditor) {
            activeEditorPane.setLayoutKind('columns');
        }
    }
}
class ShowNonConflictingChanges extends Action2 {
    constructor() {
        super({
            id: 'merge.showNonConflictingChanges',
            title: ( localize2(9071, "Show Non-Conflicting Changes")),
            toggled: ( ctxMergeEditorShowNonConflictingChanges.isEqualTo(true)),
            menu: [
                {
                    id: MenuId.EditorTitle,
                    when: ctxIsMergeEditor,
                    group: '3_merge',
                    order: 9,
                },
            ],
            precondition: ctxIsMergeEditor,
        });
    }
    run(accessor) {
        const { activeEditorPane } = accessor.get(IEditorService);
        if (activeEditorPane instanceof MergeEditor) {
            activeEditorPane.toggleShowNonConflictingChanges();
        }
    }
}
class ShowHideBase extends Action2 {
    constructor() {
        super({
            id: 'merge.showBase',
            title: ( localize2(9072, "Show Base")),
            toggled: ( ctxMergeEditorShowBase.isEqualTo(true)),
            menu: [
                {
                    id: MenuId.EditorTitle,
                    when: ( ContextKeyExpr.and(ctxIsMergeEditor, ( ctxMergeEditorLayout.isEqualTo('columns')))),
                    group: '2_merge',
                    order: 9,
                },
            ]
        });
    }
    run(accessor) {
        const { activeEditorPane } = accessor.get(IEditorService);
        if (activeEditorPane instanceof MergeEditor) {
            activeEditorPane.toggleBase();
        }
    }
}
class ShowHideTopBase extends Action2 {
    constructor() {
        super({
            id: 'merge.showBaseTop',
            title: ( localize2(9073, "Show Base Top")),
            toggled: ( ContextKeyExpr.and(ctxMergeEditorShowBase, ctxMergeEditorShowBaseAtTop)),
            menu: [
                {
                    id: MenuId.EditorTitle,
                    when: ( ContextKeyExpr.and(ctxIsMergeEditor, ( ctxMergeEditorLayout.isEqualTo('mixed')))),
                    group: '2_merge',
                    order: 10,
                },
            ],
        });
    }
    run(accessor) {
        const { activeEditorPane } = accessor.get(IEditorService);
        if (activeEditorPane instanceof MergeEditor) {
            activeEditorPane.toggleShowBaseTop();
        }
    }
}
class ShowHideCenterBase extends Action2 {
    constructor() {
        super({
            id: 'merge.showBaseCenter',
            title: ( localize2(9074, "Show Base Center")),
            toggled: ( ContextKeyExpr.and(ctxMergeEditorShowBase, ( ctxMergeEditorShowBaseAtTop.negate()))),
            menu: [
                {
                    id: MenuId.EditorTitle,
                    when: ( ContextKeyExpr.and(ctxIsMergeEditor, ( ctxMergeEditorLayout.isEqualTo('mixed')))),
                    group: '2_merge',
                    order: 11,
                },
            ],
        });
    }
    run(accessor) {
        const { activeEditorPane } = accessor.get(IEditorService);
        if (activeEditorPane instanceof MergeEditor) {
            activeEditorPane.toggleShowBaseCenter();
        }
    }
}
const mergeEditorCategory = ( localize2(9075, "Merge Editor"));
class OpenResultResource extends MergeEditorAction {
    constructor() {
        super({
            id: 'merge.openResult',
            icon: Codicon.goToFile,
            title: ( localize2(9076, "Open File")),
            category: mergeEditorCategory,
            menu: [{
                    id: MenuId.EditorTitle,
                    when: ctxIsMergeEditor,
                    group: 'navigation',
                    order: 1,
                }],
            precondition: ctxIsMergeEditor,
        });
    }
    runWithViewModel(viewModel, accessor) {
        const editorService = accessor.get(IEditorService);
        editorService.openEditor({ resource: viewModel.model.resultTextModel.uri });
    }
}
class GoToNextUnhandledConflict extends MergeEditorAction {
    constructor() {
        super({
            id: 'merge.goToNextUnhandledConflict',
            category: mergeEditorCategory,
            title: ( localize2(9077, "Go to Next Unhandled Conflict")),
            icon: Codicon.arrowDown,
            menu: [
                {
                    id: MenuId.EditorTitle,
                    when: ctxIsMergeEditor,
                    group: 'navigation',
                    order: 3
                },
            ],
            f1: true,
            precondition: ctxIsMergeEditor,
        });
    }
    runWithViewModel(viewModel) {
        viewModel.model.telemetry.reportNavigationToNextConflict();
        viewModel.goToNextModifiedBaseRange(r => !viewModel.model.isHandled(r).get());
    }
}
class GoToPreviousUnhandledConflict extends MergeEditorAction {
    constructor() {
        super({
            id: 'merge.goToPreviousUnhandledConflict',
            category: mergeEditorCategory,
            title: ( localize2(9078, "Go to Previous Unhandled Conflict")),
            icon: Codicon.arrowUp,
            menu: [
                {
                    id: MenuId.EditorTitle,
                    when: ctxIsMergeEditor,
                    group: 'navigation',
                    order: 2
                },
            ],
            f1: true,
            precondition: ctxIsMergeEditor,
        });
    }
    runWithViewModel(viewModel) {
        viewModel.model.telemetry.reportNavigationToPreviousConflict();
        viewModel.goToPreviousModifiedBaseRange(r => !viewModel.model.isHandled(r).get());
    }
}
class ToggleActiveConflictInput1 extends MergeEditorAction {
    constructor() {
        super({
            id: 'merge.toggleActiveConflictInput1',
            category: mergeEditorCategory,
            title: ( localize2(9079, "Toggle Current Conflict from Left")),
            f1: true,
            precondition: ctxIsMergeEditor,
        });
    }
    runWithViewModel(viewModel) {
        viewModel.toggleActiveConflict(1);
    }
}
class ToggleActiveConflictInput2 extends MergeEditorAction {
    constructor() {
        super({
            id: 'merge.toggleActiveConflictInput2',
            category: mergeEditorCategory,
            title: ( localize2(9080, "Toggle Current Conflict from Right")),
            f1: true,
            precondition: ctxIsMergeEditor,
        });
    }
    runWithViewModel(viewModel) {
        viewModel.toggleActiveConflict(2);
    }
}
class CompareInput1WithBaseCommand extends MergeEditorAction {
    constructor() {
        super({
            id: 'mergeEditor.compareInput1WithBase',
            category: mergeEditorCategory,
            title: ( localize2(9081, "Compare Input 1 With Base")),
            shortTitle: ( localize(9082, 'Compare With Base')),
            f1: true,
            precondition: ctxIsMergeEditor,
            menu: { id: MenuId.MergeInput1Toolbar, group: 'primary' },
            icon: Codicon.compareChanges,
        });
    }
    runWithViewModel(viewModel, accessor) {
        const editorService = accessor.get(IEditorService);
        mergeEditorCompare(viewModel, editorService, 1);
    }
}
class CompareInput2WithBaseCommand extends MergeEditorAction {
    constructor() {
        super({
            id: 'mergeEditor.compareInput2WithBase',
            category: mergeEditorCategory,
            title: ( localize2(9083, "Compare Input 2 With Base")),
            shortTitle: ( localize(9082, 'Compare With Base')),
            f1: true,
            precondition: ctxIsMergeEditor,
            menu: { id: MenuId.MergeInput2Toolbar, group: 'primary' },
            icon: Codicon.compareChanges,
        });
    }
    runWithViewModel(viewModel, accessor) {
        const editorService = accessor.get(IEditorService);
        mergeEditorCompare(viewModel, editorService, 2);
    }
}
async function mergeEditorCompare(viewModel, editorService, inputNumber) {
    editorService.openEditor(editorService.activeEditor, { pinned: true });
    const model = viewModel.model;
    const base = model.base;
    const input = inputNumber === 1 ? viewModel.inputCodeEditorView1.editor : viewModel.inputCodeEditorView2.editor;
    const lineNumber = input.getPosition().lineNumber;
    await editorService.openEditor({
        original: { resource: base.uri },
        modified: { resource: input.getModel().uri },
        options: {
            selection: {
                startLineNumber: lineNumber,
                startColumn: 1,
            },
            revealIfOpened: true,
            revealIfVisible: true,
        }
    });
}
class OpenBaseFile extends MergeEditorAction {
    constructor() {
        super({
            id: 'merge.openBaseEditor',
            category: mergeEditorCategory,
            title: ( localize2(9084, "Open Base File")),
            f1: true,
            precondition: ctxIsMergeEditor,
        });
    }
    runWithViewModel(viewModel, accessor) {
        const openerService = accessor.get(IOpenerService);
        openerService.open(viewModel.model.base.uri);
    }
}
class AcceptAllInput1 extends MergeEditorAction {
    constructor() {
        super({
            id: 'merge.acceptAllInput1',
            category: mergeEditorCategory,
            title: ( localize2(9085, "Accept All Incoming Changes from Left")),
            f1: true,
            precondition: ctxIsMergeEditor,
            menu: { id: MenuId.MergeInput1Toolbar, group: 'primary' },
            icon: Codicon.checkAll,
        });
    }
    runWithViewModel(viewModel) {
        viewModel.acceptAll(1);
    }
}
class AcceptAllInput2 extends MergeEditorAction {
    constructor() {
        super({
            id: 'merge.acceptAllInput2',
            category: mergeEditorCategory,
            title: ( localize2(9086, "Accept All Current Changes from Right")),
            f1: true,
            precondition: ctxIsMergeEditor,
            menu: { id: MenuId.MergeInput2Toolbar, group: 'primary' },
            icon: Codicon.checkAll,
        });
    }
    runWithViewModel(viewModel) {
        viewModel.acceptAll(2);
    }
}
class ResetToBaseAndAutoMergeCommand extends MergeEditorAction {
    constructor() {
        super({
            id: 'mergeEditor.resetResultToBaseAndAutoMerge',
            category: mergeEditorCategory,
            title: ( localize2(9087, "Reset Result")),
            shortTitle: ( localize(9088, 'Reset')),
            f1: true,
            precondition: ctxIsMergeEditor,
            menu: { id: MenuId.MergeInputResultToolbar, group: 'primary' },
            icon: Codicon.discard,
        });
    }
    runWithViewModel(viewModel, accessor) {
        viewModel.model.reset();
    }
}
class ResetCloseWithConflictsChoice extends Action2 {
    constructor() {
        super({
            id: 'mergeEditor.resetCloseWithConflictsChoice',
            category: mergeEditorCategory,
            title: ( localize2(9089, "Reset Choice for \'Close with Conflicts\'")),
            f1: true,
        });
    }
    run(accessor) {
        accessor.get(IStorageService).remove(StorageCloseWithConflicts, StorageScope.PROFILE);
    }
}
class AcceptAllCombination extends MergeEditorAction2 {
    constructor() {
        super({
            id: 'mergeEditor.acceptAllCombination',
            category: mergeEditorCategory,
            title: ( localize2(9090, "Accept All Combination")),
            f1: true,
        });
    }
    runWithMergeEditor(context, accessor, ...args) {
        const { viewModel } = context;
        const modifiedBaseRanges = viewModel.model.modifiedBaseRanges.get();
        const model = viewModel.model;
        transaction((tx) => {
            for (const m of modifiedBaseRanges) {
                const state = model.getState(m).get();
                if (state.kind !== ModifiedBaseRangeStateKind.unrecognized && !state.isInputIncluded(1) && (!state.isInputIncluded(2) || !viewModel.shouldUseAppendInsteadOfAccept.get()) && m.canBeCombined) {
                    model.setState(m, state
                        .withInputValue(1, true)
                        .withInputValue(2, true, true), true, tx);
                    model.telemetry.reportSmartCombinationInvoked(state.includesInput(2));
                }
            }
        });
        return { success: true };
    }
}
class AcceptMerge extends MergeEditorAction2 {
    constructor() {
        super({
            id: 'mergeEditor.acceptMerge',
            category: mergeEditorCategory,
            title: ( localize2(9091, "Complete Merge")),
            f1: true,
            precondition: ctxIsMergeEditor,
            keybinding: [
                {
                    primary: KeyMod.CtrlCmd | KeyCode.Enter,
                    weight: KeybindingWeight.EditorContrib,
                    when: ctxIsMergeEditor,
                }
            ]
        });
    }
    async runWithMergeEditor({ inputModel, editorIdentifier, viewModel }, accessor) {
        const dialogService = accessor.get(IDialogService);
        const editorService = accessor.get(IEditorService);
        if (viewModel.model.unhandledConflictsCount.get() > 0) {
            const { confirmed } = await dialogService.confirm({
                message: ( localize(
                    9092,
                    "Do you want to complete the merge of {0}?",
                    basename(inputModel.resultUri)
                )),
                detail: ( localize(9093, "The file contains unhandled conflicts.")),
                primaryButton: ( localize(9094, "&&Complete with Conflicts"))
            });
            if (!confirmed) {
                return {
                    successful: false
                };
            }
        }
        await inputModel.accept();
        await editorService.closeEditor(editorIdentifier);
        return {
            successful: true
        };
    }
}
class ToggleBetweenInputs extends MergeEditorAction2 {
    constructor() {
        super({
            id: 'mergeEditor.toggleBetweenInputs',
            category: mergeEditorCategory,
            title: ( localize2(9095, "Toggle Between Merge Editor Inputs")),
            f1: true,
            precondition: ctxIsMergeEditor,
            keybinding: [
                {
                    primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KeyT,
                    weight: KeybindingWeight.WorkbenchContrib + 10,
                    when: ctxIsMergeEditor,
                }
            ]
        });
    }
    runWithMergeEditor({ viewModel }, accessor) {
        const input1IsFocused = viewModel.inputCodeEditorView1.editor.hasWidgetFocus();
        if (input1IsFocused) {
            viewModel.inputCodeEditorView2.editor.focus();
        }
        else {
            viewModel.inputCodeEditorView1.editor.focus();
        }
    }
}

export { AcceptAllCombination, AcceptAllInput1, AcceptAllInput2, AcceptMerge, CompareInput1WithBaseCommand, CompareInput2WithBaseCommand, GoToNextUnhandledConflict, GoToPreviousUnhandledConflict, OpenBaseFile, OpenMergeEditor, OpenResultResource, ResetCloseWithConflictsChoice, ResetToBaseAndAutoMergeCommand, SetColumnLayout, SetMixedLayout, ShowHideBase, ShowHideCenterBase, ShowHideTopBase, ShowNonConflictingChanges, ToggleActiveConflictInput1, ToggleActiveConflictInput2, ToggleBetweenInputs };
