
import { distinct } from '@codingame/monaco-vscode-api/vscode/vs/base/common/arrays';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { RawContextKey } from '@codingame/monaco-vscode-api/vscode/vs/platform/contextkey/common/contextkey';
import { globMatchesResource, RegisteredEditorPriority, priorityToRank } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorResolverService';

const CONTEXT_ACTIVE_CUSTOM_EDITOR_ID = ( new RawContextKey('activeCustomEditorId', '', {
    type: 'string',
    description: ( localize(6430, "The viewType of the currently active custom editor.")),
}));
const CONTEXT_FOCUSED_CUSTOM_EDITOR_IS_EDITABLE = ( new RawContextKey('focusedCustomEditorIsEditable', false));
var CustomEditorPriority;
(function (CustomEditorPriority) {
    CustomEditorPriority["default"] = "default";
    CustomEditorPriority["builtin"] = "builtin";
    CustomEditorPriority["option"] = "option";
})(CustomEditorPriority || (CustomEditorPriority = {}));
class CustomEditorInfo {
    constructor(descriptor) {
        this.id = descriptor.id;
        this.displayName = descriptor.displayName;
        this.providerDisplayName = descriptor.providerDisplayName;
        this.priority = descriptor.priority;
        this.selector = descriptor.selector;
    }
    matches(resource) {
        return ( this.selector.some(
            selector => selector.filenamePattern && globMatchesResource(selector.filenamePattern, resource)
        ));
    }
}
class CustomEditorInfoCollection {
    constructor(editors) {
        this.allEditors = distinct(editors, editor => editor.id);
    }
    get length() { return this.allEditors.length; }
    get defaultEditor() {
        return this.allEditors.find(editor => {
            switch (editor.priority) {
                case RegisteredEditorPriority.default:
                case RegisteredEditorPriority.builtin:
                    return this.allEditors.every(otherEditor => otherEditor === editor || isLowerPriority(otherEditor, editor));
                default:
                    return false;
            }
        });
    }
    get bestAvailableEditor() {
        const editors = Array.from(this.allEditors).sort((a, b) => {
            return priorityToRank(a.priority) - priorityToRank(b.priority);
        });
        return editors[0];
    }
}
function isLowerPriority(otherEditor, editor) {
    return priorityToRank(otherEditor.priority) < priorityToRank(editor.priority);
}

export { CONTEXT_ACTIVE_CUSTOM_EDITOR_ID, CONTEXT_FOCUSED_CUSTOM_EDITOR_IS_EDITABLE, CustomEditorInfo, CustomEditorInfoCollection, CustomEditorPriority };
