
import { registerCss } from '@codingame/monaco-vscode-api/css';
import { __decorate, __param } from '@codingame/monaco-vscode-api/external/tslib/tslib.es6';
import * as languageStatus from './media/languageStatus.css';
import { createElement, getWindow, isHTMLElement, addDisposableListener, append, $ } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';
import { renderLabelWithIcons } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/iconLabel/iconLabels';
import { Disposable, DisposableStore, dispose, toDisposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import Severity from '@codingame/monaco-vscode-api/vscode/vs/base/common/severity';
import { getCodeEditor } from '@codingame/monaco-vscode-api/vscode/vs/editor/browser/editorBrowser';
import { localize, localize2 } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { ThemeIcon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/themables';
import { IEditorService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorService.service';
import { ILanguageStatusService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/languageStatus/common/languageStatusService.service';
import { ShowTooltipCommand, StatusbarAlignment } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/statusbar/browser/statusbar';
import { IStatusbarService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/statusbar/browser/statusbar.service';
import { parseLinkedText } from '@codingame/monaco-vscode-api/vscode/vs/base/common/linkedText';
import { Link } from '@codingame/monaco-vscode-api/vscode/vs/platform/opener/browser/link';
import { IOpenerService } from '@codingame/monaco-vscode-api/vscode/vs/platform/opener/common/opener.service';
import { MarkdownString } from '@codingame/monaco-vscode-api/vscode/vs/base/common/htmlContent';
import { ActionBar } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/actionbar/actionbar';
import { Action } from '@codingame/monaco-vscode-api/vscode/vs/base/common/actions';
import { Codicon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/codicons';
import { StorageScope, StorageTarget } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage';
import { IStorageService } from '@codingame/monaco-vscode-api/vscode/vs/platform/storage/common/storage.service';
import { equals } from '@codingame/monaco-vscode-api/vscode/vs/base/common/arrays';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { Action2 } from '@codingame/monaco-vscode-api/vscode/vs/platform/actions/common/actions';
import { Categories } from '@codingame/monaco-vscode-api/vscode/vs/platform/action/common/actionCommonCategories';
import { IEditorGroupsService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/editor/common/editorGroupsService.service';
import { nativeHoverDelegate } from '@codingame/monaco-vscode-api/vscode/vs/platform/hover/browser/hover';
import { IHoverService } from '@codingame/monaco-vscode-api/vscode/vs/platform/hover/browser/hover.service';
import { Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { joinStrings } from '@codingame/monaco-vscode-api/vscode/vs/base/common/strings';

var LanguageStatus_1;
registerCss(languageStatus);
class LanguageStatusViewModel {
    constructor(combined, dedicated) {
        this.combined = combined;
        this.dedicated = dedicated;
    }
    isEqual(other) {
        return equals(this.combined, other.combined) && equals(this.dedicated, other.dedicated);
    }
}
let StoredCounter = class StoredCounter {
    constructor(_storageService, _key) {
        this._storageService = _storageService;
        this._key = _key;
    }
    get value() {
        return this._storageService.getNumber(this._key, StorageScope.PROFILE, 0);
    }
    increment() {
        const n = this.value + 1;
        this._storageService.store(this._key, n, StorageScope.PROFILE, StorageTarget.MACHINE);
        return n;
    }
};
StoredCounter = ( __decorate([
    ( __param(0, IStorageService))
], StoredCounter));
let LanguageStatusContribution = class LanguageStatusContribution extends Disposable {
    static { this.Id = 'status.languageStatus'; }
    constructor(editorGroupService) {
        super();
        this.editorGroupService = editorGroupService;
        for (const part of editorGroupService.parts) {
            this.createLanguageStatus(part);
        }
        this._register(editorGroupService.onDidCreateAuxiliaryEditorPart(part => this.createLanguageStatus(part)));
    }
    createLanguageStatus(part) {
        const disposables = ( new DisposableStore());
        Event.once(part.onWillDispose)(() => disposables.dispose());
        const scopedInstantiationService = this.editorGroupService.getScopedInstantiationService(part);
        disposables.add(scopedInstantiationService.createInstance(LanguageStatus));
    }
};
LanguageStatusContribution = ( __decorate([
    ( __param(0, IEditorGroupsService))
], LanguageStatusContribution));
let LanguageStatus = class LanguageStatus {
    static { LanguageStatus_1 = this; }
    static { this._id = 'status.languageStatus'; }
    static { this._keyDedicatedItems = 'languageStatus.dedicated'; }
    constructor(_languageStatusService, _statusBarService, _editorService, _hoverService, _openerService, _storageService) {
        this._languageStatusService = _languageStatusService;
        this._statusBarService = _statusBarService;
        this._editorService = _editorService;
        this._hoverService = _hoverService;
        this._openerService = _openerService;
        this._storageService = _storageService;
        this._disposables = ( new DisposableStore());
        this._dedicated = ( new Set());
        this._dedicatedEntries = ( new Map());
        this._renderDisposables = ( new DisposableStore());
        this._combinedEntryTooltip = createElement('div');
        _storageService.onDidChangeValue(StorageScope.PROFILE, LanguageStatus_1._keyDedicatedItems, this._disposables)(this._handleStorageChange, this, this._disposables);
        this._restoreState();
        this._interactionCounter = ( new StoredCounter(_storageService, 'languageStatus.interactCount'));
        _languageStatusService.onDidChange(this._update, this, this._disposables);
        _editorService.onDidActiveEditorChange(this._update, this, this._disposables);
        this._update();
        _statusBarService.onDidChangeEntryVisibility(e => {
            if (!e.visible && ( this._dedicated.has(e.id))) {
                this._dedicated.delete(e.id);
                this._update();
                this._storeState();
            }
        }, undefined, this._disposables);
    }
    dispose() {
        this._disposables.dispose();
        this._combinedEntry?.dispose();
        dispose(( this._dedicatedEntries.values()));
        this._renderDisposables.dispose();
    }
    _handleStorageChange() {
        this._restoreState();
        this._update();
    }
    _restoreState() {
        const raw = this._storageService.get(LanguageStatus_1._keyDedicatedItems, StorageScope.PROFILE, '[]');
        try {
            const ids = JSON.parse(raw);
            this._dedicated = ( new Set(ids));
        }
        catch {
            this._dedicated.clear();
        }
    }
    _storeState() {
        if (this._dedicated.size === 0) {
            this._storageService.remove(LanguageStatus_1._keyDedicatedItems, StorageScope.PROFILE);
        }
        else {
            const raw = JSON.stringify(Array.from(( this._dedicated.keys())));
            this._storageService.store(LanguageStatus_1._keyDedicatedItems, raw, StorageScope.PROFILE, StorageTarget.USER);
        }
    }
    _createViewModel(editor) {
        if (!editor?.hasModel()) {
            return ( new LanguageStatusViewModel([], []));
        }
        const all = this._languageStatusService.getLanguageStatus(editor.getModel());
        const combined = [];
        const dedicated = [];
        for (const item of all) {
            if (( this._dedicated.has(item.id))) {
                dedicated.push(item);
            }
            combined.push(item);
        }
        return ( new LanguageStatusViewModel(combined, dedicated));
    }
    _update() {
        const editor = getCodeEditor(this._editorService.activeTextEditorControl);
        const model = this._createViewModel(editor);
        if (this._model?.isEqual(model)) {
            return;
        }
        this._renderDisposables.clear();
        this._model = model;
        editor?.onDidChangeModelLanguage(this._update, this, this._renderDisposables);
        if (model.combined.length === 0) {
            this._combinedEntry?.dispose();
            this._combinedEntry = undefined;
        }
        else {
            const [first] = model.combined;
            const showSeverity = first.severity >= Severity.Warning;
            const text = LanguageStatus_1._severityToComboCodicon(first.severity);
            let isOneBusy = false;
            const ariaLabels = [];
            for (const status of model.combined) {
                const isPinned = model.dedicated.includes(status);
                this._renderStatus(this._combinedEntryTooltip, status, showSeverity, isPinned, this._renderDisposables);
                ariaLabels.push(LanguageStatus_1._accessibilityInformation(status).label);
                isOneBusy = isOneBusy || (!isPinned && status.busy);
            }
            const props = {
                name: ( localize(8508, "Editor Language Status")),
                ariaLabel: ( localize(8509, "Editor Language Status: {0}", ariaLabels.join(', next: '))),
                tooltip: this._combinedEntryTooltip,
                command: ShowTooltipCommand,
                text: isOneBusy ? '$(loading~spin)' : text,
            };
            if (!this._combinedEntry) {
                this._combinedEntry = this._statusBarService.addEntry(props, LanguageStatus_1._id, StatusbarAlignment.RIGHT, { location: { id: 'status.editor.mode', priority: 100.1 }, alignment: StatusbarAlignment.LEFT, compact: true });
            }
            else {
                this._combinedEntry.update(props);
            }
            const userHasInteractedWithStatus = this._interactionCounter.value >= 3;
            const targetWindow = getWindow(editor?.getContainerDomNode());
            const node = targetWindow.document.querySelector('.monaco-workbench .statusbar DIV#status\\.languageStatus A>SPAN.codicon');
            const container = targetWindow.document.querySelector('.monaco-workbench .statusbar DIV#status\\.languageStatus');
            if (isHTMLElement(node) && container) {
                const _wiggle = 'wiggle';
                const _flash = 'flash';
                if (!isOneBusy) {
                    node.classList.toggle(_wiggle, showSeverity || !userHasInteractedWithStatus);
                    this._renderDisposables.add(addDisposableListener(node, 'animationend', _e => node.classList.remove(_wiggle)));
                    container.classList.toggle(_flash, showSeverity);
                    this._renderDisposables.add(addDisposableListener(container, 'animationend', _e => container.classList.remove(_flash)));
                }
                else {
                    node.classList.remove(_wiggle);
                    container.classList.remove(_flash);
                }
            }
            if (!userHasInteractedWithStatus) {
                const hoverTarget = targetWindow.document.querySelector('.monaco-workbench .context-view');
                if (isHTMLElement(hoverTarget)) {
                    const observer = ( new MutationObserver(() => {
                        if (targetWindow.document.contains(this._combinedEntryTooltip)) {
                            this._interactionCounter.increment();
                            observer.disconnect();
                        }
                    }));
                    observer.observe(hoverTarget, { childList: true, subtree: true });
                    this._renderDisposables.add(toDisposable(() => observer.disconnect()));
                }
            }
        }
        const newDedicatedEntries = ( new Map());
        for (const status of model.dedicated) {
            const props = LanguageStatus_1._asStatusbarEntry(status);
            let entry = this._dedicatedEntries.get(status.id);
            if (!entry) {
                entry = this._statusBarService.addEntry(props, status.id, StatusbarAlignment.RIGHT, { location: { id: 'status.editor.mode', priority: 100.1 }, alignment: StatusbarAlignment.RIGHT });
            }
            else {
                entry.update(props);
                this._dedicatedEntries.delete(status.id);
            }
            newDedicatedEntries.set(status.id, entry);
        }
        dispose(( this._dedicatedEntries.values()));
        this._dedicatedEntries = newDedicatedEntries;
    }
    _renderStatus(container, status, showSeverity, isPinned, store) {
        const parent = createElement('div');
        parent.classList.add('hover-language-status');
        container.appendChild(parent);
        store.add(toDisposable(() => parent.remove()));
        const severity = createElement('div');
        severity.classList.add('severity', `sev${status.severity}`);
        severity.classList.toggle('show', showSeverity);
        const severityText = LanguageStatus_1._severityToSingleCodicon(status.severity);
        append(severity, ...renderLabelWithIcons(severityText));
        parent.appendChild(severity);
        const element = createElement('div');
        element.classList.add('element');
        parent.appendChild(element);
        const left = createElement('div');
        left.classList.add('left');
        element.appendChild(left);
        const label = typeof status.label === 'string' ? status.label : status.label.value;
        append(left, ...renderLabelWithIcons(computeText(label, status.busy)));
        this._renderTextPlus(left, status.detail, store);
        const right = createElement('div');
        right.classList.add('right');
        element.appendChild(right);
        const { command } = status;
        if (command) {
            store.add(( new Link(right, {
                label: command.title,
                title: command.tooltip,
                href: ( ( URI.from({
                    scheme: 'command', path: command.id, query: command.arguments && JSON.stringify(command.arguments)
                })).toString())
            }, { hoverDelegate: nativeHoverDelegate }, this._hoverService, this._openerService)));
        }
        const actionBar = ( new ActionBar(right, { hoverDelegate: nativeHoverDelegate }));
        const actionLabel = isPinned ? ( localize(8510, "Remove from Status Bar")) : ( localize(8511, "Add to Status Bar"));
        actionBar.setAriaLabel(actionLabel);
        store.add(actionBar);
        let action;
        if (!isPinned) {
            action = ( new Action('pin', actionLabel, ThemeIcon.asClassName(Codicon.pin), true, () => {
                this._dedicated.add(status.id);
                this._statusBarService.updateEntryVisibility(status.id, true);
                this._update();
                this._storeState();
            }));
        }
        else {
            action = ( new Action('unpin', actionLabel, ThemeIcon.asClassName(Codicon.pinned), true, () => {
                this._dedicated.delete(status.id);
                this._statusBarService.updateEntryVisibility(status.id, false);
                this._update();
                this._storeState();
            }));
        }
        actionBar.push(action, { icon: true, label: false });
        store.add(action);
        return parent;
    }
    static _severityToComboCodicon(sev) {
        switch (sev) {
            case Severity.Error: return '$(bracket-error)';
            case Severity.Warning: return '$(bracket-dot)';
            default: return '$(bracket)';
        }
    }
    static _severityToSingleCodicon(sev) {
        switch (sev) {
            case Severity.Error: return '$(error)';
            case Severity.Warning: return '$(info)';
            default: return '$(check)';
        }
    }
    _renderTextPlus(target, text, store) {
        let didRenderSeparator = false;
        for (const node of parseLinkedText(text).nodes) {
            if (!didRenderSeparator) {
                append(target, $('span.separator'));
                didRenderSeparator = true;
            }
            if (typeof node === 'string') {
                const parts = renderLabelWithIcons(node);
                append(target, ...parts);
            }
            else {
                store.add(( new Link(target, node, undefined, this._hoverService, this._openerService)));
            }
        }
    }
    static _accessibilityInformation(status) {
        if (status.accessibilityInfo) {
            return status.accessibilityInfo;
        }
        const textValue = typeof status.label === 'string' ? status.label : status.label.value;
        if (status.detail) {
            return { label: ( localize(8512, '{0}, {1}', textValue, status.detail)) };
        }
        else {
            return { label: ( localize(8513, '{0}', textValue)) };
        }
    }
    static _asStatusbarEntry(item) {
        let kind;
        if (item.severity === Severity.Warning) {
            kind = 'warning';
        }
        else if (item.severity === Severity.Error) {
            kind = 'error';
        }
        const textValue = typeof item.label === 'string' ? item.label : item.label.shortValue;
        return {
            name: ( localize(8514, '{0} (Language Status)', item.name)),
            text: computeText(textValue, item.busy),
            ariaLabel: LanguageStatus_1._accessibilityInformation(item).label,
            role: item.accessibilityInfo?.role,
            tooltip: item.command?.tooltip || ( new MarkdownString(item.detail, { isTrusted: true, supportThemeIcons: true })),
            kind,
            command: item.command
        };
    }
};
LanguageStatus = LanguageStatus_1 = ( __decorate([
    ( __param(0, ILanguageStatusService)),
    ( __param(1, IStatusbarService)),
    ( __param(2, IEditorService)),
    ( __param(3, IHoverService)),
    ( __param(4, IOpenerService)),
    ( __param(5, IStorageService))
], LanguageStatus));
class ResetAction extends Action2 {
    constructor() {
        super({
            id: 'editor.inlayHints.Reset',
            title: ( localize2(8515, "Reset Language Status Interaction Counter")),
            category: Categories.View,
            f1: true
        });
    }
    run(accessor) {
        accessor.get(IStorageService).remove('languageStatus.interactCount', StorageScope.PROFILE);
    }
}
function computeText(text, loading) {
    return joinStrings([text !== '' && text, loading && '$(loading~spin)'], '\u00A0\u00A0');
}

export { LanguageStatusContribution, ResetAction };
