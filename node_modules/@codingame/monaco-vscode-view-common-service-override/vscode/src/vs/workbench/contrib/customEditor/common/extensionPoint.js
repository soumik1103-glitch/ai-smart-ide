
import { coalesce } from '@codingame/monaco-vscode-api/vscode/vs/base/common/arrays';
import { Disposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { SyncDescriptor } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/descriptors';
import { Registry } from '@codingame/monaco-vscode-api/vscode/vs/platform/registry/common/platform';
import { CustomEditorPriority } from './customEditor.js';
import { Extensions } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensionManagement/common/extensionFeatures';
import { ExtensionsRegistry } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/extensions/common/extensionsRegistry';
import { languagesExtPoint } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/language/common/languageService';

const Fields = ( Object.freeze({
    viewType: 'viewType',
    displayName: 'displayName',
    selector: 'selector',
    priority: 'priority',
}));
const customEditorsContributionSchema = {
    type: 'object',
    required: [
        Fields.viewType,
        Fields.displayName,
        Fields.selector,
    ],
    additionalProperties: false,
    properties: {
        [Fields.viewType]: {
            type: 'string',
            markdownDescription: ( localize(
                6432,
                'Identifier for the custom editor. This must be unique across all custom editors, so we recommend including your extension id as part of `viewType`. The `viewType` is used when registering custom editors with `vscode.registerCustomEditorProvider` and in the `onCustomEditor:${id}` [activation event](https://code.visualstudio.com/api/references/activation-events).'
            )),
        },
        [Fields.displayName]: {
            type: 'string',
            description: ( localize(
                6433,
                'Human readable name of the custom editor. This is displayed to users when selecting which editor to use.'
            )),
        },
        [Fields.selector]: {
            type: 'array',
            description: ( localize(6434, 'Set of globs that the custom editor is enabled for.')),
            items: {
                type: 'object',
                defaultSnippets: [{
                        body: {
                            filenamePattern: '$1',
                        }
                    }],
                additionalProperties: false,
                properties: {
                    filenamePattern: {
                        type: 'string',
                        description: ( localize(6435, 'Glob that the custom editor is enabled for.')),
                    },
                }
            }
        },
        [Fields.priority]: {
            type: 'string',
            markdownDeprecationMessage: ( localize(
                6436,
                'Controls if the custom editor is enabled automatically when the user opens a file. This may be overridden by users using the `workbench.editorAssociations` setting.'
            )),
            enum: [
                CustomEditorPriority.default,
                CustomEditorPriority.option,
            ],
            markdownEnumDescriptions: [
                ( localize(
                6437,
                'The editor is automatically used when the user opens a resource, provided that no other default custom editors are registered for that resource.'
            )),
                ( localize(
                6438,
                'The editor is not automatically used when the user opens a resource, but a user can switch to the editor using the `Reopen With` command.'
            )),
            ],
            default: CustomEditorPriority.default
        }
    }
};
const customEditorsExtensionPoint = ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'customEditors',
    deps: [languagesExtPoint],
    jsonSchema: {
        description: ( localize(6439, 'Contributed custom editors.')),
        type: 'array',
        defaultSnippets: [{
                body: [{
                        [Fields.viewType]: '$1',
                        [Fields.displayName]: '$2',
                        [Fields.selector]: [{
                                filenamePattern: '$3'
                            }],
                    }]
            }],
        items: customEditorsContributionSchema
    },
    activationEventsGenerator: function* (contribs) {
        for (const contrib of contribs) {
            const viewType = contrib[Fields.viewType];
            if (viewType) {
                yield `onCustomEditor:${viewType}`;
            }
        }
    },
});
class CustomEditorsDataRenderer extends Disposable {
    constructor() {
        super(...arguments);
        this.type = 'table';
    }
    shouldRender(manifest) {
        return !!manifest.contributes?.customEditors;
    }
    render(manifest) {
        const customEditors = manifest.contributes?.customEditors || [];
        if (!customEditors.length) {
            return { data: { headers: [], rows: [] }, dispose: () => { } };
        }
        const headers = [
            ( localize(6440, "View Type")),
            ( localize(6441, "Priority")),
            ( localize(6442, "Filename Pattern")),
        ];
        const rows = ( customEditors
            .map(customEditor => {
            return [
                customEditor.viewType,
                customEditor.priority ?? '',
                coalesce(( customEditor.selector.map(x => x.filenamePattern))).join(', ')
            ];
        }));
        return {
            data: {
                headers,
                rows
            },
            dispose: () => { }
        };
    }
}
( Registry.as(Extensions.ExtensionFeaturesRegistry)).registerExtensionFeature({
    id: 'customEditors',
    label: ( localize(6443, "Custom Editors")),
    access: {
        canToggle: false
    },
    renderer: ( new SyncDescriptor(CustomEditorsDataRenderer)),
});

export { customEditorsExtensionPoint };
