
import { CallHierarchyModel, CallHierarchyDirection } from '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/callHierarchy/common/callHierarchy';
import { CancellationToken } from '@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation';
import { createMatches } from '@codingame/monaco-vscode-api/vscode/vs/base/common/filters';
import { IconLabel } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/ui/iconLabel/iconLabel';
import { SymbolTag, SymbolKinds } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/languages';
import { compare } from '@codingame/monaco-vscode-api/vscode/vs/base/common/strings';
import { Range } from '@codingame/monaco-vscode-api/vscode/vs/editor/common/core/range';
import { localize } from '@codingame/monaco-vscode-api/vscode/vs/nls';
import { ThemeIcon } from '@codingame/monaco-vscode-api/vscode/vs/base/common/themables';
import { createElement } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/dom';

class Call {
    constructor(item, locations, model, parent) {
        this.item = item;
        this.locations = locations;
        this.model = model;
        this.parent = parent;
    }
    static compare(a, b) {
        let res = compare(( a.item.uri.toString()), ( b.item.uri.toString()));
        if (res === 0) {
            res = Range.compareRangesUsingStarts(a.item.range, b.item.range);
        }
        return res;
    }
}
class DataSource {
    constructor(getDirection) {
        this.getDirection = getDirection;
    }
    hasChildren() {
        return true;
    }
    async getChildren(element) {
        if (element instanceof CallHierarchyModel) {
            return ( element.roots.map(root => ( new Call(root, undefined, element, undefined))));
        }
        const { model, item } = element;
        if (this.getDirection() === CallHierarchyDirection.CallsFrom) {
            return ( (await model.resolveOutgoingCalls(item, CancellationToken.None)).map(call => {
                return ( new Call(call.to, ( call.fromRanges.map(range => ({ range, uri: item.uri }))), model, element));
            }));
        }
        else {
            return ( (await model.resolveIncomingCalls(item, CancellationToken.None)).map(call => {
                return ( new Call(call.from, ( call.fromRanges.map(range => ({ range, uri: call.from.uri }))), model, element));
            }));
        }
    }
}
class Sorter {
    compare(element, otherElement) {
        return Call.compare(element, otherElement);
    }
}
class IdentityProvider {
    constructor(getDirection) {
        this.getDirection = getDirection;
    }
    getId(element) {
        let res = this.getDirection() + JSON.stringify(element.item.uri) + JSON.stringify(element.item.range);
        if (element.parent) {
            res += this.getId(element.parent);
        }
        return res;
    }
}
class CallRenderingTemplate {
    constructor(icon, label) {
        this.icon = icon;
        this.label = label;
    }
}
class CallRenderer {
    constructor() {
        this.templateId = CallRenderer.id;
    }
    static { this.id = 'CallRenderer'; }
    renderTemplate(container) {
        container.classList.add('callhierarchy-element');
        const icon = createElement('div');
        container.appendChild(icon);
        const label = ( new IconLabel(container, { supportHighlights: true }));
        return ( new CallRenderingTemplate(icon, label));
    }
    renderElement(node, _index, template) {
        const { element, filterData } = node;
        const deprecated = element.item.tags?.includes(SymbolTag.Deprecated);
        template.icon.className = '';
        template.icon.classList.add('inline', ...ThemeIcon.asClassNameArray(SymbolKinds.toIcon(element.item.kind)));
        template.label.setLabel(element.item.name, element.item.detail, { labelEscapeNewLines: true, matches: createMatches(filterData), strikethrough: deprecated });
    }
    disposeTemplate(template) {
        template.label.dispose();
    }
}
class VirtualDelegate {
    getHeight(_element) {
        return 22;
    }
    getTemplateId(_element) {
        return CallRenderer.id;
    }
}
class AccessibilityProvider {
    constructor(getDirection) {
        this.getDirection = getDirection;
    }
    getWidgetAriaLabel() {
        return localize(4570, "Call Hierarchy");
    }
    getAriaLabel(element) {
        if (this.getDirection() === CallHierarchyDirection.CallsFrom) {
            return localize(4571, "calls from {0}", element.item.name);
        }
        else {
            return localize(4572, "callers of {0}", element.item.name);
        }
    }
}

export { AccessibilityProvider, Call, CallRenderer, DataSource, IdentityProvider, Sorter, VirtualDelegate };
