import { type IEditorOverrideServices } from "@codingame/monaco-vscode-api/vscode/vs/editor/standalone/browser/standaloneServices";
import { InMemoryFileSystemProvider } from "@codingame/monaco-vscode-api/vscode/vs/platform/files/common/inMemoryFilesystemProvider";
import { URI } from "@codingame/monaco-vscode-api/vscode/vs/base/common/uri";
import { FileChangeType, FilePermission, FileSystemProviderCapabilities, FileType, type IFileSystemProvider, FileSystemProviderError, FileSystemProviderErrorCode, type IFileChange, type IFileDeleteOptions, type IFileOverwriteOptions, type IFileSystemProviderWithFileReadWriteCapability, type IFileWriteOptions, type IStat, type IWatchOptions, type IFileSystemProviderWithOpenReadWriteCloseCapability, type IFileSystemProviderWithFileReadStreamCapability, type IFileReadStreamOptions, type IFileSystemProviderWithFileAtomicReadCapability, type IFileSystemProviderWithFileAtomicWriteCapability, type IFileSystemProviderWithFileAtomicDeleteCapability, type IFileStat } from "@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files";
import { type IDisposable, Disposable } from "@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle";
import { Emitter, Event } from "@codingame/monaco-vscode-api/vscode/vs/base/common/event";
import { HTMLFileSystemProvider } from "@codingame/monaco-vscode-api/vscode/vs/platform/files/browser/htmlFileSystemProvider";
import { IndexedDBFileSystemProvider } from "./vscode/src/vs/platform/files/browser/indexedDBFileSystemProvider.js";
import { IndexedDB } from "@codingame/monaco-vscode-api/vscode/vs/base/browser/indexedDB";
import { type ReadableStreamEvents } from "@codingame/monaco-vscode-api/vscode/vs/base/common/stream";
import { CancellationToken } from "@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation";
interface _RegisteredNode {
    type: FileType;
    stats(): Promise<IStat>;
    onDidDelete: Event<void>;
    onDidChange: Event<void>;
}
interface RegisteredFileNode extends _RegisteredNode {
    type: FileType.File;
    uri: URI;
    read(): Promise<Uint8Array>;
    readStream?(): Promise<ReadableStream<Uint8Array>>;
    write(content: Uint8Array): Promise<void>;
    delete(): void;
}
interface RegisteredDirectoryNode extends _RegisteredNode {
    type: FileType.Directory;
    addChild(name: string, node: RegisteredNode): IDisposable;
    deleteChild(name: string): boolean;
    getChildren(name: string): RegisteredNode | undefined;
    read(): [
        string,
        FileType
    ][];
}
type RegisteredNode = RegisteredFileNode | RegisteredDirectoryNode;
declare abstract class RegisteredFile implements RegisteredFileNode {
    uri: URI;
    private readonly;
    protected ctime: number;
    protected mtime: number;
    readonly type = FileType.File;
    protected _onDidChange: Emitter<void>;
    onDidChange: Event<void>;
    protected _onDidDelete: Emitter<void>;
    onDidDelete: Event<void>;
    constructor(uri: URI, readonly: boolean);
    stats(): Promise<IStat>;
    abstract getSize(): Promise<number>;
    delete(): Promise<void>;
    abstract read(): Promise<Uint8Array>;
    abstract write(content: Uint8Array): Promise<void>;
}
declare class RegisteredReadOnlyFile extends RegisteredFile {
    read: () => Promise<Uint8Array>;
    private size;
    constructor(uri: URI, read: () => Promise<Uint8Array>, size: number);
    getSize(): Promise<number>;
    write(): Promise<void>;
    delete(): Promise<void>;
}
export interface ExtensionFileMetadata {
    mimeType?: string;
    size?: number;
}
declare class RegisteredUriFile extends RegisteredFile {
    private url;
    private metadata?;
    constructor(location: URI, url: string, metadata?: ExtensionFileMetadata | undefined);
    private fetch;
    getSize(): Promise<number>;
    read(): Promise<Uint8Array>;
    readStream(): Promise<ReadableStream<Uint8Array>>;
    write(): Promise<void>;
    delete(): Promise<void>;
}
declare class RegisteredMemoryFile extends RegisteredFile {
    private content;
    constructor(uri: URI, content: string | Uint8Array);
    getSize(): Promise<number>;
    read(): Promise<Uint8Array>;
    write(content: Uint8Array): Promise<void>;
}
declare class RegisteredFileSystemProvider extends Disposable implements IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileAtomicWriteCapability, IFileSystemProviderWithFileAtomicDeleteCapability {
    private memoryFdCounter;
    private readonly fdMemory;
    private rootByAuthority;
    onDidChangeCapabilities: Event<any>;
    _onDidChangeFile: Emitter<readonly IFileChange[]>;
    onDidChangeFile: Event<readonly IFileChange[]>;
    capabilities: number;
    constructor(readonly: boolean);
    open(resource: URI): Promise<number>;
    close(fd: number): Promise<void>;
    read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;
    write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;
    private _lookupRoot;
    private _lookup;
    private _lookupAsDirectory;
    private _lookupAsFile;
    registerFile(file: RegisteredFileNode): IDisposable;
    stat(resource: URI): Promise<IStat>;
    readdirSync(resource: URI): [
        string,
        FileType
    ][];
    readdir(resource: URI): Promise<[
        string,
        FileType
    ][]>;
    readFile(resource: URI): Promise<Uint8Array>;
    readFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;
    watch(): IDisposable;
    writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void>;
    rename(): Promise<void>;
    mkdirSync(resource: URI): RegisteredDirectoryNode;
    mkdir(): Promise<void>;
    private deleteSync;
    delete(resource: URI): Promise<void>;
    private _bufferedChanges;
    private _fireSoonHandle?;
    private _fireSoon;
}
declare class OverlayFileSystemProvider implements IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileAtomicWriteCapability, IFileSystemProviderWithFileAtomicDeleteCapability {
    private providers;
    register(priority: number, provider: IFileSystemProviderWithFileReadWriteCapability): IDisposable;
    get delegates(): IFileSystemProviderWithFileReadWriteCapability[];
    onDidChangeCapabilities: Event<any>;
    _onDidChangeFile: Emitter<readonly IFileChange[]>;
    onDidChangeFile: Event<readonly IFileChange[]>;
    _onDidChangeOverlays: Emitter<void>;
    onDidChangeOverlays: Event<void>;
    capabilities: number;
    private readFromDelegates;
    private writeToDelegates;
    stat(resource: URI): Promise<IStat>;
    readFile(resource: URI): Promise<Uint8Array>;
    readFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;
    readdir(resource: URI): Promise<[
        string,
        FileType
    ][]>;
    watch(resource: URI, opts: IWatchOptions): IDisposable;
    writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void>;
    mkdir(resource: URI): Promise<void>;
    delete(resource: URI, opts: IFileDeleteOptions): Promise<void>;
    rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;
}
declare class DelegateFileSystemProvider implements IFileSystemProvider {
    private options;
    constructor(options: {
        delegate: IFileSystemProvider;
        toDelegate: (uri: URI) => URI;
        fromDeletate: (uri: URI) => URI;
    });
    get capabilities(): FileSystemProviderCapabilities;
    onDidChangeCapabilities: Event<void>;
    onDidChangeFile: Event<{
        type: FileChangeType;
        resource: URI;
    }[]>;
    readFile: ((resource: URI) => Promise<Uint8Array>) | undefined;
    writeFile: ((resource: URI, content: Uint8Array, opts: IFileWriteOptions) => Promise<void>) | undefined;
    watch(resource: URI, opts: IWatchOptions): IDisposable;
    stat(resource: URI): Promise<IStat>;
    mkdir(resource: URI): Promise<void>;
    readdir(resource: URI): Promise<[
        string,
        FileType
    ][]>;
    delete(resource: URI, opts: IFileDeleteOptions): Promise<void>;
    rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;
}
declare class EmptyFileSystemProvider implements IFileSystemProviderWithFileReadWriteCapability {
    readFile(): Promise<Uint8Array>;
    writeFile(): Promise<void>;
    capabilities: number;
    onDidChangeCapabilities: Event<any>;
    onDidChangeFile: Event<any>;
    watch(): IDisposable;
    stat(): Promise<IStat>;
    mkdir(): Promise<void>;
    readdir(): Promise<[
        string,
        FileType
    ][]>;
    delete(): Promise<void>;
    rename(): Promise<void>;
}
export declare namespace CustomSchemas {
    /**
     * A schema that is used for models that exist in memory
     * only and that have no correspondence on a server or such.
     */
    const extensionFile = "extension-file";
}
export interface FileServiceOptions {
    statMiddleware?: (resource: URI, next: () => Promise<IFileStat>) => Promise<IFileStat>;
}
export default function getServiceOverride(options?: FileServiceOptions): IEditorOverrideServices;
/**
 * Register a custom file system provider for the given scheme. This allows us to override
 * the default file system provider for a given scheme.
 */
export declare function registerCustomProvider(scheme: string, provider: IFileSystemProvider): void;
export declare function registerExtensionFile(file: RegisteredFileNode): IDisposable;
/**
 * Can be used to create a file before the fileService is initialized
 */
export declare function initFile(file: URI, content: Uint8Array | string, options?: Partial<IFileWriteOptions>): Promise<void>;
/**
 * Can be used to replace memory providers by indexeddb providers before the fileService is initialized
 */
export declare function createIndexedDBProviders(): Promise<IndexedDBFileSystemProvider>;
/**
 * Can be used to replace the default filesystem provider by the HTMLFileSystemProvider before the fileService is initialized
 * Should be called "after" createIndexedDBProviders if used
 */
export declare function registerHTMLFileSystemProvider(): void;
/**
 * Register a file system overlay
 *
 * By default, a memory filesystem is used to read and write file
 *
 * This method allows to register another fileSystemProvider in front OR behind the default memory one.
 *
 * The default one is registered as priority: 0, so:
 * - any provider registered with a positive priority will be in front of the default one
 * - any provider registered with a negative priority will be behind the default one
 */
export declare function registerFileSystemOverlay(priority: number, provider: IFileSystemProviderWithFileReadWriteCapability): IDisposable;
export { FileSystemProviderCapabilities, FileType, FileSystemProviderError, FileSystemProviderErrorCode, FileChangeType, FilePermission, HTMLFileSystemProvider, InMemoryFileSystemProvider, IndexedDB, IndexedDBFileSystemProvider, RegisteredFileSystemProvider, RegisteredFile, RegisteredReadOnlyFile, RegisteredUriFile, RegisteredMemoryFile, DelegateFileSystemProvider, OverlayFileSystemProvider, EmptyFileSystemProvider };
export type { IFileSystemProviderWithFileReadWriteCapability, IStat, IWatchOptions, IFileWriteOptions, IFileDeleteOptions, IFileOverwriteOptions, IFileChange, IFileStat };
