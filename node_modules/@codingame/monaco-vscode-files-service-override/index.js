
import { StandaloneServices } from '@codingame/monaco-vscode-api/vscode/vs/editor/standalone/browser/standaloneServices';
import { SyncDescriptor } from '@codingame/monaco-vscode-api/vscode/vs/platform/instantiation/common/descriptors';
import { mkdirp, FileService } from './vscode/src/vs/platform/files/common/fileService.js';
import '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log';
import { ILogService } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/log.service';
import { InMemoryFileSystemProvider } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/inMemoryFilesystemProvider';
export { InMemoryFileSystemProvider } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/inMemoryFilesystemProvider';
import { URI } from '@codingame/monaco-vscode-api/vscode/vs/base/common/uri';
import { IFileService } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files.service';
import { FileType, FilePermission, createFileSystemProviderError, FileSystemProviderErrorCode, FileSystemProviderCapabilities, FileChangeType, FileSystemProviderError, hasFileReadStreamCapability } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files';
export { FileChangeType, FilePermission, FileSystemProviderCapabilities, FileSystemProviderError, FileSystemProviderErrorCode, FileType } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/common/files';
import { Disposable, DisposableStore, toDisposable } from '@codingame/monaco-vscode-api/vscode/vs/base/common/lifecycle';
import { extUri, basename, dirname } from '@codingame/monaco-vscode-api/vscode/vs/base/common/resources';
import { Emitter, Event } from '@codingame/monaco-vscode-api/vscode/vs/base/common/event';
import { HTMLFileSystemProvider } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/browser/htmlFileSystemProvider';
export { HTMLFileSystemProvider } from '@codingame/monaco-vscode-api/vscode/vs/platform/files/browser/htmlFileSystemProvider';
import { Schemas } from '@codingame/monaco-vscode-api/vscode/vs/base/common/network';
import { IndexedDBFileSystemProvider } from './vscode/src/vs/platform/files/browser/indexedDBFileSystemProvider.js';
import { IndexedDB } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/indexedDB';
export { IndexedDB } from '@codingame/monaco-vscode-api/vscode/vs/base/browser/indexedDB';
import { BufferLogger } from '@codingame/monaco-vscode-api/vscode/vs/platform/log/common/bufferLog';
import { ITextFileService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/textfile/common/textfiles.service';
import { BrowserTextFileService } from './vscode/src/vs/workbench/services/textfile/browser/browserTextFileService.js';
import { FilesConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/filesConfiguration/common/filesConfigurationService';
import { IFilesConfigurationService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/filesConfiguration/common/filesConfigurationService.service';
import { BrowserElevatedFileService } from './vscode/src/vs/workbench/services/files/browser/elevatedFileService.js';
import { IElevatedFileService } from '@codingame/monaco-vscode-api/vscode/vs/workbench/services/files/common/elevatedFileService.service';
import { VSBuffer } from '@codingame/monaco-vscode-api/vscode/vs/base/common/buffer';
import { newWriteableStream, listenStream } from '@codingame/monaco-vscode-api/vscode/vs/base/common/stream';
import '@codingame/monaco-vscode-api/vscode/vs/base/common/cancellation';
import { registerServiceInitializePreParticipant, checkServicesNotInitialized } from '@codingame/monaco-vscode-api/lifecycle';
import { logsPath } from '@codingame/monaco-vscode-api/workbench';
import '@codingame/monaco-vscode-api/vscode/vs/workbench/contrib/files/browser/files.contribution._configuration';

class RegisteredDirectory {
    constructor() {
        this.type = FileType.Directory;
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._onDidDelete = new Emitter();
        this.onDidDelete = this._onDidDelete.event;
        this.ctime = Date.now();
        this.mtime = Date.now();
        this.type = FileType.Directory;
        this.entries = new Map();
    }
    async stats() {
        return {
            ctime: this.ctime,
            mtime: this.mtime,
            size: 0,
            type: FileType.Directory
        };
    }
    delete() {
        this._onDidDelete.fire();
    }
    addChild(name, node) {
        this.entries.set(name, node);
        this._onDidChange.fire();
        const disposable = {
            dispose: () => {
                this.deleteChild(name);
            }
        };
        node.onDidDelete(() => {
            disposable.dispose();
        });
        return disposable;
    }
    deleteChild(name) {
        if (this.entries.delete(name)) {
            this.mtime = Date.now();
            this._onDidChange.fire();
            if (this.entries.size === 0) {
                this.delete();
            }
            return true;
        }
        return false;
    }
    getChildren(name) {
        return this.entries.get(name);
    }
    read() {
        return Array.from(this.entries.entries()).map(([name, child]) => [name, child.type]);
    }
}
class RegisteredFile {
    constructor(uri, readonly) {
        this.uri = uri;
        this.readonly = readonly;
        this.type = FileType.File;
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._onDidDelete = new Emitter();
        this.onDidDelete = this._onDidDelete.event;
        this.ctime = Date.now();
        this.mtime = Date.now();
        this.onDidChange(() => {
            this.mtime = Date.now();
        });
    }
    async stats() {
        return {
            ctime: this.ctime,
            mtime: this.mtime,
            size: await this.getSize(),
            type: FileType.File,
            permissions: this.readonly ? FilePermission.Readonly : undefined
        };
    }
    async delete() {
        if (this.readonly) {
            throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
        }
        this._onDidDelete.fire();
    }
}
class RegisteredReadOnlyFile extends RegisteredFile {
    constructor(uri, read, size) {
        super(uri, true);
        this.read = read;
        this.size = size;
    }
    async getSize() {
        return this.size;
    }
    write() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
    async delete() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
}
class RegisteredUriFile extends RegisteredFile {
    constructor(location, url, metadata) {
        super(location, true);
        this.url = url;
        this.metadata = metadata;
    }
    async fetch() {
        const response = await fetch(this.url, {
            headers: this.metadata?.mimeType != null
                ? {
                    Accept: this.metadata.mimeType
                }
                : {}
        });
        if (response.status !== 200) {
            throw new Error(response.statusText);
        }
        return response;
    }
    async getSize() {
        return this.metadata?.size ?? 0;
    }
    async read() {
        const response = await this.fetch();
        return new Uint8Array(await response.arrayBuffer());
    }
    async readStream() {
        const response = await this.fetch();
        return response.body;
    }
    write() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
    async delete() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
}
const encoder = new TextEncoder();
function encode(data) {
    if (data instanceof Uint8Array) {
        return data;
    }
    else {
        return encoder.encode(data);
    }
}
class RegisteredMemoryFile extends RegisteredFile {
    constructor(uri, content) {
        super(uri, false);
        this.content = encode(content);
    }
    async getSize() {
        return this.content.length;
    }
    async read() {
        return this.content;
    }
    async write(content) {
        this.content = content;
        this._onDidChange.fire();
    }
}
class RegisteredFileSystemProvider extends Disposable {
    constructor(readonly) {
        super();
        this.memoryFdCounter = 0;
        this.fdMemory = new Map();
        this.onDidChangeCapabilities = Event.None;
        this._onDidChangeFile = new Emitter();
        this.onDidChangeFile = this._onDidChangeFile.event;
        this._bufferedChanges = [];
        this.rootByAuthority = new Map();
        this.capabilities =
            FileSystemProviderCapabilities.FileReadWrite |
                FileSystemProviderCapabilities.PathCaseSensitive |
                FileSystemProviderCapabilities.FileReadStream;
        if (readonly) {
            this.capabilities |= FileSystemProviderCapabilities.Readonly;
        }
    }
    async open(resource) {
        const data = await this.readFile(resource);
        const fd = this.memoryFdCounter++;
        this.fdMemory.set(fd, data);
        return fd;
    }
    async close(fd) {
        this.fdMemory.delete(fd);
    }
    async read(fd, pos, data, offset, length) {
        const memory = this.fdMemory.get(fd);
        if (memory == null) {
            throw createFileSystemProviderError('No file with that descriptor open', FileSystemProviderErrorCode.Unavailable);
        }
        const toWrite = VSBuffer.wrap(memory).slice(pos, pos + length);
        data.set(toWrite.buffer, offset);
        return toWrite.byteLength;
    }
    write(fd, pos, data, offset, length) {
        const memory = this.fdMemory.get(fd);
        if (memory == null) {
            throw createFileSystemProviderError('No file with that descriptor open', FileSystemProviderErrorCode.Unavailable);
        }
        const toWrite = VSBuffer.wrap(data).slice(offset, offset + length);
        memory.set(toWrite.buffer, pos);
        return Promise.resolve(toWrite.byteLength);
    }
    _lookupRoot(authority) {
        const _authority = authority.toLowerCase();
        let root = this.rootByAuthority.get(_authority);
        if (root == null) {
            root = new RegisteredDirectory();
            this.rootByAuthority.set(_authority, root);
        }
        return root;
    }
    _lookup(uri, silent) {
        const parts = uri.path.split('/');
        const root = this._lookupRoot(uri.authority);
        let entry = root;
        for (const part of parts) {
            if (part.length === 0) {
                continue;
            }
            let child;
            if (entry instanceof RegisteredDirectory) {
                child = entry.getChildren(part);
            }
            if (child == null) {
                if (!silent) {
                    throw createFileSystemProviderError('file not found', FileSystemProviderErrorCode.FileNotFound);
                }
                else {
                    return undefined;
                }
            }
            entry = child;
        }
        return entry;
    }
    _lookupAsDirectory(uri, silent) {
        const entry = this._lookup(uri, silent);
        if (entry instanceof RegisteredDirectory) {
            return entry;
        }
        throw createFileSystemProviderError('file not a directory', FileSystemProviderErrorCode.FileNotADirectory);
    }
    _lookupAsFile(uri, silent) {
        const entry = this._lookup(uri, silent);
        if (entry != null && entry.type === FileType.File) {
            return entry;
        }
        throw createFileSystemProviderError('file is a directory', FileSystemProviderErrorCode.FileIsADirectory);
    }
    registerFile(file) {
        const parts = file.uri.path.split('/');
        let directory = this._lookupRoot(file.uri.authority);
        let uri = file.uri.with({ path: '/' });
        for (const part of parts.slice(0, -1)) {
            if (part === '') {
                continue;
            }
            uri = extUri.joinPath(uri, part);
            let children = directory.getChildren(part);
            if (children == null) {
                const newDirectory = this.mkdirSync(uri);
                children = newDirectory;
            }
            if (!(children instanceof RegisteredDirectory)) {
                throw new Error(`file '${uri.toString()}' is not a directory`);
            }
            directory = children;
        }
        const name = parts[parts.length - 1];
        if (directory.getChildren(name) != null) {
            throw new Error(`file '${extUri.joinPath(uri, name).toString()}/' already exists`);
        }
        const disposableStore = new DisposableStore();
        disposableStore.add(toDisposable(() => {
            this._fireSoon({
                resource: file.uri,
                type: FileChangeType.DELETED
            });
        }));
        disposableStore.add(file.onDidDelete(() => {
            disposableStore.dispose();
        }));
        disposableStore.add(file.onDidChange(() => {
            this._fireSoon({
                resource: file.uri,
                type: FileChangeType.UPDATED
            });
        }));
        disposableStore.add(directory.addChild(name, file));
        this._fireSoon({
            resource: file.uri,
            type: FileChangeType.ADDED
        });
        return disposableStore;
    }
    async stat(resource) {
        const node = this._lookup(resource, false);
        return await node.stats();
    }
    readdirSync(resource) {
        const directory = this._lookupAsDirectory(resource, false);
        return directory.read();
    }
    async readdir(resource) {
        return this.readdirSync(resource);
    }
    async readFile(resource) {
        const file = this._lookupAsFile(resource, false);
        return await file.read();
    }
    readFileStream(resource, opts, token) {
        const file = this._lookupAsFile(resource, false);
        const stream = newWriteableStream((data) => VSBuffer.concat(data.map((data) => VSBuffer.wrap(data))).buffer, {
            highWaterMark: 10
        });
        void (async () => {
            try {
                if (file.readStream == null ||
                    typeof opts.length === 'number' ||
                    typeof opts.position === 'number') {
                    let buffer = await file.read();
                    if (typeof opts.position === 'number' || typeof opts.length === 'number') {
                        buffer = buffer.slice(opts.position ?? 0, opts.length);
                    }
                    stream.end(buffer);
                }
                else {
                    const reader = (await file.readStream()).getReader();
                    let res = await reader.read();
                    while (!res.done) {
                        if (token.isCancellationRequested) {
                            break;
                        }
                        await stream.write(res.value);
                        if (token.isCancellationRequested) {
                            break;
                        }
                        res = await reader.read();
                    }
                    stream.end(undefined);
                }
            }
            catch (error) {
                stream.error(createFileSystemProviderError(error, FileSystemProviderErrorCode.Unknown));
                stream.end();
            }
        })();
        return stream;
    }
    watch() {
        return Disposable.None;
    }
    async writeFile(resource, content, opts) {
        const node = this._lookup(resource, true);
        if (node != null && !(node instanceof RegisteredFile)) {
            throw createFileSystemProviderError('file is directory', FileSystemProviderErrorCode.FileIsADirectory);
        }
        if (node == null) {
            throw createFileSystemProviderError('file not found', FileSystemProviderErrorCode.FileNotFound);
        }
        if (!opts.overwrite) {
            throw createFileSystemProviderError('file exists already', FileSystemProviderErrorCode.FileExists);
        }
        await node.write(content);
    }
    async rename() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    mkdirSync(resource) {
        if (this._lookup(resource, true) != null) {
            throw createFileSystemProviderError('file exists already', FileSystemProviderErrorCode.FileExists);
        }
        const basename$1 = basename(resource);
        const dirname$1 = dirname(resource);
        const parent = this._lookupAsDirectory(dirname$1, false);
        const directory = new RegisteredDirectory();
        const disposable = new DisposableStore();
        disposable.add(directory.onDidDelete(() => {
            disposable.dispose();
            this._fireSoon({
                resource,
                type: FileChangeType.DELETED
            });
        }));
        disposable.add(directory.onDidChange(() => {
            this._fireSoon({
                resource,
                type: FileChangeType.UPDATED
            });
        }));
        parent.addChild(basename$1, directory);
        this._fireSoon({ type: FileChangeType.ADDED, resource });
        return directory;
    }
    async mkdir() {
        throw createFileSystemProviderError("Can' create a directory", FileSystemProviderErrorCode.NoPermissions);
    }
    deleteSync(resource) {
        const node = this._lookup(resource, true);
        if (node == null) {
            throw createFileSystemProviderError('Not found', FileSystemProviderErrorCode.FileNotFound);
        }
        else if (node.type === FileType.Directory) {
            throw createFileSystemProviderError("Can't delete a directory", FileSystemProviderErrorCode.NoPermissions);
        }
        node.delete();
    }
    async delete(resource) {
        this.deleteSync(resource);
    }
    _fireSoon(...changes) {
        this._bufferedChanges.push(...changes);
        if (this._fireSoonHandle != null) {
            clearTimeout(this._fireSoonHandle);
            this._fireSoonHandle = undefined;
        }
        this._fireSoonHandle = window.setTimeout(() => {
            this._onDidChangeFile.fire(this._bufferedChanges);
            this._bufferedChanges.length = 0;
        }, 5);
    }
}
function isFullfiled(result) {
    return result.status === 'fulfilled';
}
class OverlayFileSystemProvider {
    constructor() {
        this.providers = [];
        this.onDidChangeCapabilities = Event.None;
        this._onDidChangeFile = new Emitter();
        this.onDidChangeFile = this._onDidChangeFile.event;
        this._onDidChangeOverlays = new Emitter();
        this.onDidChangeOverlays = this._onDidChangeOverlays.event;
        this.capabilities = FileSystemProviderCapabilities.FileReadWrite |
            FileSystemProviderCapabilities.PathCaseSensitive |
            FileSystemProviderCapabilities.FileReadStream;
    }
    register(priority, provider) {
        const item = { priority, provider };
        this.providers.push(item);
        this.providers.sort((a, b) => b.priority - a.priority);
        const disposableStore = new DisposableStore();
        disposableStore.add(provider.onDidChangeFile((e) => {
            this._onDidChangeFile.fire(e);
        }));
        disposableStore.add({
            dispose: () => {
                const index = this.providers.indexOf(item);
                if (index >= 0) {
                    this.providers.splice(index, 1);
                    this._onDidChangeOverlays.fire();
                }
            }
        });
        this._onDidChangeOverlays.fire();
        return disposableStore;
    }
    get delegates() {
        return this.providers.map(({ provider }) => provider);
    }
    async readFromDelegates(caller, token) {
        if (this.delegates.length === 0) {
            throw createFileSystemProviderError('No delegate', FileSystemProviderErrorCode.Unavailable);
        }
        let firstError;
        for (const delegate of this.delegates) {
            if (token != null && token.isCancellationRequested) {
                throw new Error('Cancelled');
            }
            try {
                return await caller(delegate);
            }
            catch (err) {
                firstError ?? (firstError = err);
                if (err instanceof FileSystemProviderError &&
                    [
                        FileSystemProviderErrorCode.NoPermissions,
                        FileSystemProviderErrorCode.FileNotFound,
                        FileSystemProviderErrorCode.Unavailable
                    ].includes(err.code)) {
                    continue;
                }
                throw err;
            }
        }
        throw firstError;
    }
    async writeToDelegates(resource, caller) {
        if (this.delegates.length === 0) {
            throw createFileSystemProviderError('No delegate', FileSystemProviderErrorCode.Unavailable);
        }
        for (const provider of this.delegates) {
            if ((provider.capabilities & FileSystemProviderCapabilities.Readonly) > 0) {
                continue;
            }
            try {
                await mkdirp(extUri, provider, extUri.dirname(resource));
            }
            catch {
            }
            try {
                return await caller(provider);
            }
            catch (err) {
                if (err instanceof FileSystemProviderError &&
                    [
                        FileSystemProviderErrorCode.NoPermissions,
                        FileSystemProviderErrorCode.FileNotFound,
                        FileSystemProviderErrorCode.Unavailable
                    ].includes(err.code)) {
                    continue;
                }
                throw err;
            }
        }
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async stat(resource) {
        return await this.readFromDelegates(async (delegate) => {
            const result = await delegate.stat(resource);
            const readOnly = (delegate.capabilities & FileSystemProviderCapabilities.Readonly) > 0;
            return {
                ...result,
                permissions: result.permissions ?? (readOnly ? FilePermission.Readonly : undefined)
            };
        });
    }
    async readFile(resource) {
        return await this.readFromDelegates((delegate) => delegate.readFile(resource));
    }
    readFileStream(resource, opts, token) {
        const writableStream = newWriteableStream((data) => VSBuffer.concat(data.map((data) => VSBuffer.wrap(data))).buffer);
        this.readFromDelegates(async (delegate) => {
            if (hasFileReadStreamCapability(delegate)) {
                const stream = delegate.readFileStream(resource, opts, token);
                await new Promise((resolve, reject) => {
                    let dataReceived = false;
                    listenStream(stream, {
                        onData(data) {
                            dataReceived = true;
                            void writableStream.write(data);
                        },
                        onEnd() {
                            writableStream.end();
                            resolve();
                        },
                        onError(err) {
                            if (!dataReceived) {
                                reject(err);
                            }
                            else {
                                writableStream.error(err);
                            }
                        }
                    }, token);
                });
            }
            else {
                let data = await this.readFile(resource);
                if (typeof opts.position === 'number' || typeof opts.length === 'number') {
                    data = data.slice(opts.position ?? 0, opts.length);
                }
                return writableStream.end(data);
            }
        }, token).catch((err) => {
            writableStream.error(err);
        });
        return writableStream;
    }
    async readdir(resource) {
        const results = await Promise.allSettled(this.delegates.map(async (delegate) => await delegate.readdir(resource)));
        if (!results.some(isFullfiled)) {
            throw results[0].reason;
        }
        return Object.entries(Object.fromEntries(results
            .filter(isFullfiled)
            .map((result) => result.value)
            .flat()));
    }
    watch(resource, opts) {
        const store = new DisposableStore();
        for (const delegate of this.delegates) {
            store.add(delegate.watch(resource, opts));
        }
        return store;
    }
    async writeFile(resource, content, opts) {
        await this.writeToDelegates(resource, async (delegate) => {
            let stats;
            try {
                stats = await delegate.stat(resource);
            }
            catch {
            }
            if (stats != null && ((stats.permissions ?? 0) & FilePermission.Readonly) > 0) {
                throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
            }
            return await delegate.writeFile(resource, content, opts);
        });
    }
    async mkdir(resource) {
        await this.writeToDelegates(resource, (delegate) => delegate.mkdir(resource));
    }
    async delete(resource, opts) {
        await this.writeToDelegates(resource, (delegate) => delegate.delete(resource, opts));
    }
    async rename(from, to, opts) {
        await this.writeToDelegates(to, (delegate) => delegate.rename(from, to, opts));
    }
}
class DelegateFileSystemProvider {
    constructor(options) {
        this.options = options;
        this.onDidChangeCapabilities = this.options.delegate.onDidChangeCapabilities;
        this.onDidChangeFile = Event.map(this.options.delegate.onDidChangeFile, (changes) => changes.map((change) => ({
            type: change.type,
            resource: this.options.fromDeletate(change.resource)
        })));
        this.readFile = this.options.delegate.readFile != null
            ? (resource) => {
                return this.options.delegate.readFile(this.options.toDelegate(resource));
            }
            : undefined;
        this.writeFile = this.options.delegate.writeFile != null
            ? (resource, content, opts) => {
                return this.options.delegate.writeFile(this.options.toDelegate(resource), content, opts);
            }
            : undefined;
    }
    get capabilities() {
        return this.options.delegate.capabilities;
    }
    watch(resource, opts) {
        return this.options.delegate.watch(this.options.toDelegate(resource), opts);
    }
    stat(resource) {
        return this.options.delegate.stat(this.options.toDelegate(resource));
    }
    mkdir(resource) {
        return this.options.delegate.mkdir(this.options.toDelegate(resource));
    }
    readdir(resource) {
        return this.options.delegate.readdir(this.options.toDelegate(resource));
    }
    delete(resource, opts) {
        return this.options.delegate.delete(this.options.toDelegate(resource), opts);
    }
    rename(from, to, opts) {
        return this.options.delegate.rename(this.options.toDelegate(from), this.options.toDelegate(to), opts);
    }
}
class EmptyFileSystemProvider {
    constructor() {
        this.capabilities = FileSystemProviderCapabilities.FileReadWrite | FileSystemProviderCapabilities.PathCaseSensitive;
        this.onDidChangeCapabilities = Event.None;
        this.onDidChangeFile = Event.None;
    }
    async readFile() {
        throw createFileSystemProviderError('Not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async writeFile() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    watch() {
        return Disposable.None;
    }
    async stat() {
        throw createFileSystemProviderError('Not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async mkdir() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async readdir() {
        throw createFileSystemProviderError('Not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async delete() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async rename() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
}
const overlayFileSystemProvider = new OverlayFileSystemProvider();
overlayFileSystemProvider.register(0, new InMemoryFileSystemProvider());
const extensionFileSystemProvider = new RegisteredFileSystemProvider(true);
const userDataFileSystemProvider = new InMemoryFileSystemProvider();
void userDataFileSystemProvider.mkdir(URI.from({ scheme: Schemas.vscodeUserData, path: '/User/' }));
var CustomSchemas;
(function (CustomSchemas) {
    CustomSchemas.extensionFile = 'extension-file';
})(CustomSchemas || (CustomSchemas = {}));
const providers = {
    [CustomSchemas.extensionFile]: extensionFileSystemProvider,
    [logsPath.scheme]: new InMemoryFileSystemProvider(),
    [Schemas.vscodeUserData]: userDataFileSystemProvider,
    [Schemas.tmp]: new InMemoryFileSystemProvider(),
    [Schemas.file]: overlayFileSystemProvider
};
class FileServiceOverride extends FileService {
    constructor(logService, options) {
        super(logService);
        this.options = options;
        for (const [scheme, provider] of Object.entries(providers)) {
            let disposable = this.registerProvider(scheme, provider);
            if (provider instanceof OverlayFileSystemProvider) {
                provider.onDidChangeOverlays(() => {
                    disposable.dispose();
                    disposable = this.registerProvider(scheme, provider);
                });
            }
        }
    }
    async withProvider(resource) {
        if (resource.scheme === 'data') {
            const httpProvider = this.getProvider('http');
            if (httpProvider != null) {
                return httpProvider;
            }
        }
        return super.withProvider(resource);
    }
    async toFileStat(provider, resource, stat, siblings, resolveMetadata, recurse) {
        const next = async () => {
            return await super.toFileStat(provider, resource, stat, siblings, resolveMetadata, recurse);
        };
        return this.options.statMiddleware?.(resource, next) ?? next();
    }
}
FileServiceOverride.$di$dependencies = [];
const fileLogger = new BufferLogger();
registerServiceInitializePreParticipant(async (accessor) => {
    fileLogger.logger = accessor.get(ILogService);
});
function getServiceOverride(options = {}) {
    return {
        [IFileService.toString()]: new SyncDescriptor(FileServiceOverride, [fileLogger, options], true),
        [ITextFileService.toString()]: new SyncDescriptor(BrowserTextFileService, [], true),
        [IFilesConfigurationService.toString()]: new SyncDescriptor(FilesConfigurationService, [], true),
        [IElevatedFileService.toString()]: new SyncDescriptor(BrowserElevatedFileService, [], true)
    };
}
function registerCustomProvider(scheme, provider) {
    checkServicesNotInitialized();
    providers[scheme] = provider;
}
function registerExtensionFile(file) {
    return extensionFileSystemProvider.registerFile(file);
}
async function initFile(file, content, options) {
    checkServicesNotInitialized();
    const provider = providers[file.scheme];
    if (provider == null || provider.writeFile == null) {
        throw new Error(`${file.scheme} provider doesn't exist or doesn't support writing files`);
    }
    if (!(options?.overwrite ?? false)) {
        try {
            await provider.stat(file);
            return;
        }
        catch (error) {
            if (!(error instanceof FileSystemProviderError) ||
                error.code !== FileSystemProviderErrorCode.FileNotFound) {
                console.error('Unable to check if file exists', error);
            }
        }
    }
    await provider.writeFile(file, encode(content), {
        atomic: false,
        create: true,
        overwrite: false,
        unlock: false,
        ...options
    });
}
let indexedDB;
const userDataStore = 'vscode-userdata-store';
const logsStore = 'vscode-logs-store';
const handlesStore = 'vscode-filehandles-store';
async function createIndexedDBProviders() {
    indexedDB = await IndexedDB.create('vscode-web-db', 3, [userDataStore, logsStore, handlesStore]);
    registerCustomProvider(logsPath.scheme, new IndexedDBFileSystemProvider(logsPath.scheme, indexedDB, logsStore, false));
    const userDataProvider = new IndexedDBFileSystemProvider(Schemas.vscodeUserData, indexedDB, userDataStore, true);
    registerCustomProvider(Schemas.vscodeUserData, userDataProvider);
    return userDataProvider;
}
function registerHTMLFileSystemProvider() {
    class LazyLogService {
        get onDidChangeLogLevel() {
            return StandaloneServices.get(ILogService).onDidChangeLogLevel;
        }
        getLevel() {
            return StandaloneServices.get(ILogService).getLevel();
        }
        setLevel(level) {
            StandaloneServices.get(ILogService).setLevel(level);
        }
        trace(message, ...args) {
            StandaloneServices.get(ILogService).trace(message, ...args);
        }
        debug(message, ...args) {
            StandaloneServices.get(ILogService).debug(message, ...args);
        }
        info(message, ...args) {
            StandaloneServices.get(ILogService).info(message, ...args);
        }
        warn(message, ...args) {
            StandaloneServices.get(ILogService).warn(message, ...args);
        }
        error(message, ...args) {
            StandaloneServices.get(ILogService).error(message, ...args);
        }
        flush() {
            StandaloneServices.get(ILogService).flush();
        }
        dispose() {
            StandaloneServices.get(ILogService).dispose();
        }
    }
    registerCustomProvider(Schemas.file, new HTMLFileSystemProvider(indexedDB, handlesStore, new LazyLogService()));
}
function registerFileSystemOverlay(priority, provider) {
    const overlayProvider = providers.file;
    if (!(overlayProvider instanceof OverlayFileSystemProvider)) {
        throw new Error('The overlay filesystem provider was replaced');
    }
    return overlayProvider.register(priority, provider);
}

export { CustomSchemas, DelegateFileSystemProvider, EmptyFileSystemProvider, IndexedDBFileSystemProvider, OverlayFileSystemProvider, RegisteredFile, RegisteredFileSystemProvider, RegisteredMemoryFile, RegisteredReadOnlyFile, RegisteredUriFile, createIndexedDBProviders, getServiceOverride as default, initFile, registerCustomProvider, registerExtensionFile, registerFileSystemOverlay, registerHTMLFileSystemProvider };
