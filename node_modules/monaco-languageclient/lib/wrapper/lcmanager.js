/* --------------------------------------------------------------------------------------------
 * Copyright (c) 2025 TypeFox and others.
 * Licensed under the MIT License. See LICENSE in the package root for license information.
 * ------------------------------------------------------------------------------------------ */
import { LogLevel } from '@codingame/monaco-vscode-api';
import { ConsoleLogger } from '@codingame/monaco-vscode-log-service-override';
import { LanguageClientWrapper } from './lcwrapper.js';
export class LanguageClientManager {
    logger = new ConsoleLogger();
    languageClientConfigs;
    languageClientWrappers = new Map();
    setLogLevel(logLevel) {
        this.logger.setLevel(logLevel ?? LogLevel.Off);
    }
    haveLanguageClients() {
        return this.languageClientWrappers.size > 0;
    }
    getLanguageClientWrapper(languageId) {
        return this.languageClientWrappers.get(languageId);
    }
    getLanguageClient(languageId) {
        return this.languageClientWrappers.get(languageId)?.getLanguageClient();
    }
    getWorker(languageId) {
        return this.languageClientWrappers.get(languageId)?.getWorker();
    }
    setConfig(languageClientConfig) {
        if (languageClientConfig === undefined)
            return;
        const languageId = languageClientConfig.languageId;
        let lcw = this.languageClientWrappers.get(languageId);
        if (lcw === undefined) {
            lcw = new LanguageClientWrapper(languageClientConfig);
            this.languageClientWrappers.set(languageId, lcw);
        }
    }
    setConfigs(languageClientConfigs) {
        this.languageClientConfigs = languageClientConfigs;
        const lccs = Object.values(this.languageClientConfigs.configs);
        if (lccs.length > 0) {
            for (const lcc of lccs) {
                this.setConfig(lcc);
            }
        }
    }
    async start() {
        this.logger.debug('Starting all LanguageClientWrappers...');
        const allPromises = [];
        for (const lcw of this.languageClientWrappers.values()) {
            if (!lcw.isStarted()) {
                allPromises.push(lcw.start());
            }
        }
        return Promise.all(allPromises);
    }
    isStarted() {
        // fast-fail
        if (this.languageClientWrappers.size === 0)
            return false;
        for (const lcw of this.languageClientWrappers.values()) {
            // as soon as one is not started return
            if (!lcw.isStarted()) {
                return false;
            }
        }
        return true;
    }
    async dispose(clearClients = false) {
        this.logger.debug('Disposing all LanguageClientWrappers...');
        const allPromises = [];
        for (const lcw of this.languageClientWrappers.values()) {
            if (lcw.haveLanguageClient()) {
                allPromises.push(lcw.dispose());
            }
        }
        await Promise.all(allPromises);
        if (clearClients) {
            this.languageClientWrappers.clear();
        }
    }
}
//# sourceMappingURL=lcmanager.js.map