import { type ITextFileEditorModel } from '@codingame/monaco-vscode-api/monaco';
import * as monaco from '@codingame/monaco-vscode-editor-api';
import type { IReference } from '@codingame/monaco-vscode-editor-service-override';
import type { ILogger } from '@codingame/monaco-vscode-log-service-override';
import type { CodeContent, CodeResources, EditorAppConfig, TextContents, TextModels } from './config.js';
/**
 * This is the base class for both Monaco Editor Apps:
 * - EditorAppClassic
 * - EditorAppExtended
 *
 * It provides the generic functionality for both implementations.
 */
export declare class EditorApp {
    private id;
    private config;
    protected logger: ILogger;
    private editor;
    private diffEditor;
    private modelRefs;
    private onTextChanged?;
    private textChangedDisposables;
    private modelDisposables;
    private modelRefDisposeTimeout;
    private startingAwait?;
    private disposingAwait?;
    constructor(userAppConfig?: EditorAppConfig);
    isDiffEditor(): boolean;
    getConfig(): EditorAppConfig;
    getEditor(): monaco.editor.IStandaloneCodeEditor | undefined;
    getDiffEditor(): monaco.editor.IStandaloneDiffEditor | undefined;
    getTextModels(): TextModels;
    registerOnTextChangedCallback(onTextChanged?: (textChanges: TextContents) => void): void;
    setModelRefDisposeTimeout(modelRefDisposeTimeout: number): void;
    isStarting(): boolean;
    getStartingAwait(): Promise<void> | undefined;
    isStarted(): boolean;
    /**
     * Starts the single editor application.
     */
    start(htmlContainer: HTMLElement): Promise<undefined>;
    createEditors(htmlContainer: HTMLElement): Promise<void>;
    updateCode(code: {
        modified?: string;
        original?: string;
    }): void;
    updateCodeResources(codeResources?: CodeResources): Promise<boolean>;
    buildModelReference(codeContent: CodeContent): Promise<IReference<ITextFileEditorModel>>;
    private announceModelUpdate;
    dispose(): Promise<void>;
    isDisposed(): boolean;
    isDisposing(): boolean;
    getDisposingAwait(): Promise<void> | undefined;
    disposeModelRefs(): Promise<void>;
    updateLayout(dimension?: monaco.editor.IDimension, postponeRendering?: boolean): void;
    reportStatus(): string[];
}
export declare const didModelContentChange: (textModels: TextModels, onTextChanged?: ((textChanges: TextContents) => void) | undefined) => void;
//# sourceMappingURL=editorApp.d.ts.map